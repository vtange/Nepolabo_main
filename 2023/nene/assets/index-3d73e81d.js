function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$2 = Symbol.for("react.element"), n$3 = Symbol.for("react.portal"), p$3 = Symbol.for("react.fragment"), q$1 = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t$1 = Symbol.for("react.provider"), u$2 = Symbol.for("react.context"), v$2 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z$1 = Symbol.iterator;
function A$2(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$1 && a2[z$1] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$2 = {};
function E$1(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$2;
  this.updater = e2 || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$1.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$1() {
}
F$1.prototype = E$1.prototype;
function G$2(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$2;
  this.updater = e2 || B$1;
}
var H$1 = G$2.prototype = new F$1();
H$1.constructor = G$2;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$2 = Array.isArray, J$1 = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$2(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J$1.call(b2, d2) && !L$1.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$2, type: a2, key: k2, ref: h2, props: c2, _owner: K$1.current };
}
function N$1(a2, b2) {
  return { $$typeof: l$2, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$2(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$2;
}
function escape$1(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$2 = /\/+/g;
function Q$2(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$1("" + a2.key) : b2.toString(36);
}
function R$1(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$2:
          case n$3:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$2(h2, 0) : d2, I$2(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$2, "$&/") + "/"), R$1(c2, b2, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O$2(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$2(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$2(k2, g2);
      h2 += R$1(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$2(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$2(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$2(a2, b2, e2) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$1(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$2(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$2 = { current: null }, V$2 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$2, ReactCurrentOwner: K$1 };
react_production_min.Children = { map: S$2, forEach: function(a2, b2, e2) {
  S$2(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$2(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$2(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$2(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$3;
react_production_min.Profiler = r;
react_production_min.PureComponent = G$2;
react_production_min.StrictMode = q$1;
react_production_min.Suspense = w$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$1({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J$1.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$2, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$2, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$1, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$2;
react_production_min.createFactory = function(a2) {
  var b2 = M$2.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$2, render: a2 };
};
react_production_min.isValidElement = O$2;
react_production_min.lazy = function(a2) {
  return { $$typeof: y, _payload: { _status: -1, _result: a2 }, _init: T$2 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$2.transition;
  V$2.transition = {};
  try {
    a2();
  } finally {
    V$2.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$2.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$2.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$2.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$2.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$2.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$2.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$2.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$2.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$2.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$2.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$2.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$2.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$2.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$2.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$1 = reactExports, k = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$2 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
function q(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$2.call(a2, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k, type: c2, key: e2, ref: h2, props: d2, _owner: n$2.current };
}
reactJsxRuntime_production_min.Fragment = l$1;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$1(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$1(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z[a2] = new v$1(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z[b2] = new v$1(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z[a2] = new v$1(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z[a2] = new v$1(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z[a2] = new v$1(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z[a2] = new v$1(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z[a2] = new v$1(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z[a2] = new v$1(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z[a2] = new v$1(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z[b2] = new v$1(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z[b2] = new v$1(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z[b2] = new v$1(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z[a2] = new v$1(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z.xlinkHref = new v$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z[a2] = new v$1(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e2 = z.hasOwnProperty(b2) ? z[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$1 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$1(91));
  return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$1(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$1(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$1(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$1(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$1(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$1(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$1(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$1(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$1(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$1(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$1(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a2;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$1(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$1(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$1(190));
  }
  if (3 !== c2.tag)
    throw Error(p$1(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a2, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a2, b2, c2, d2);
  } finally {
    C = e2, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2)
      hd(a2, b2, d2, id$2, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id$2, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id$2 = null;
function Yc(a2, b2, c2, d2) {
  id$2 = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id$2 = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$1(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$1({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be$1 = null;
ia && "documentMode" in document && (be$1 = document.documentMode);
var ce = ia && "TextEvent" in window && !be$1, de$1 = ia && (!ae || be$1 && 8 < be$1 && 11 >= be$1), ee$1 = String.fromCharCode(32), fe$1 = false;
function ge$1(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$1(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie = false;
function je(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$1(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$1 = true;
      return ee$1;
    case "textInput":
      return a2 = b2.data, a2 === ee$1 && fe$1 ? null : a2;
    default:
      return null;
  }
}
function ke(a2, b2) {
  if (ie)
    return "compositionend" === a2 || !ae && ge$1(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$1 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le$1[a2.type] : "textarea" === b2 ? true : false;
}
function ne$1(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe$1(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe$1 = null, qe = null;
function re$1(a2) {
  se$1(a2, 0);
}
function te(a2) {
  var b2 = ue$1(a2);
  if (Wa(b2))
    return a2;
}
function ve$1(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we = false;
if (ia) {
  var xe$1;
  if (ia) {
    var ye$1 = "oninput" in document;
    if (!ye$1) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye$1 = "function" === typeof ze.oninput;
    }
    xe$1 = ye$1;
  } else
    xe$1 = false;
  we = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe$1 && (pe$1.detachEvent("onpropertychange", Be), qe = pe$1 = null);
}
function Be(a2) {
  if ("value" === a2.propertyName && te(qe)) {
    var b2 = [];
    ne$1(b2, qe, a2, xb(a2));
    Jb(re$1, b2);
  }
}
function Ce(a2, b2, c2) {
  "focusin" === a2 ? (Ae$1(), pe$1 = b2, qe = c2, pe$1.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae$1();
}
function De(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te(qe);
}
function Ee$1(a2, b2) {
  if ("click" === a2)
    return te(b2);
}
function Fe(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te(b2);
}
function Ge(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie$1(a2, b2) {
  if (He(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a2[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke(a2, b2) {
  var c2 = Je(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe(a2) {
  var b2 = Me(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re$1 = null, Se$1 = null, Te$1 = false;
function Ue(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te$1 || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$1 && Ie$1(Se$1, d2) || (Se$1 = d2, d2 = oe$1(Re$1, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a2) {
  if (Xe[a2])
    return Xe[a2];
  if (!We[a2])
    return a2;
  var b2 = We[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye)
      return Xe[a2] = b2[c2];
  return a2;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se$1(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$1(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue$1(k3);
            u2 = null == n2 ? h3 : ue$1(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue$1(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve$1;
        else if (me(h3))
          if (we)
            na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee$1);
        if (na && (na = na(a2, d3))) {
          ne$1(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue$1(d3) : window;
      switch (a2) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe = xa, Re$1 = d3, Se$1 = null;
          break;
        case "focusout":
          Se$1 = Re$1 = Qe = null;
          break;
        case "mousedown":
          Te$1 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$1 = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie ? ge$1(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de$1 && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe$1(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$1(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a2, c2) : ke(a2, c2))
        d3 = oe$1(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se$1(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe$1(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$1(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue$1(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$1(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$1(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a2, b2, c2) {
  if (H.current !== Vf)
    throw Error(p$1(168));
  G$1(H, b2);
  G$1(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$1(108, Ra(a2) || "Unknown", e2));
  return A$1({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G$1(H, a2);
  G$1(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$1(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E(Wf), E(H), G$1(H, a2)) : E(Wf);
  G$1(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C;
    try {
      var c2 = eg;
      for (C = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$1 = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$1) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$1(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$1 = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$1(418));
      a2.flags = a2.flags & -4097 | 2;
      I$1 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I$1)
    return Fg(a2), I$1 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$1(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$1(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$1 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$1({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$1(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$1({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$1(191, e2));
        e2.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L(), d2 = lh(a2), e2 = ch(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a2, e2, d2);
  null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$1(c2, d2) || !Ie$1(e2, f2) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$1(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$1(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$1(284));
    if (!c2._owner)
      throw Error(p$1(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$1(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh$1(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I$1 && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$1 && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$1 && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$1(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$1(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I$1 && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$1 && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$1 && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = sh(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh$1(true), Ch = vh$1(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$1(174));
  return a2;
}
function Ih(a2, b2) {
  G$1(Gh, b2);
  G$1(Fh, a2);
  G$1(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E(Eh);
  G$1(Eh, b2);
}
function Jh() {
  E(Eh);
  E(Fh);
  E(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G$1(Fh, a2), G$1(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E(Eh), E(Fh));
}
var M$1 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O$1 = null, P$1 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$1() {
  throw Error(p$1(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e2, f2) {
  Rh = f2;
  N = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$1(301));
      f2 += 1;
      P$1 = O$1 = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O$1 && null !== O$1.next;
  Rh = 0;
  P$1 = O$1 = N = null;
  Sh = false;
  if (b2)
    throw Error(p$1(300));
  return a2;
}
function bi() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$1 ? N.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  return P$1;
}
function di() {
  if (null === O$1) {
    var a2 = N.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O$1.next;
  var b2 = null === P$1 ? N.memoizedState : P$1.next;
  if (null !== b2)
    P$1 = b2, O$1 = a2;
  else {
    if (null === a2)
      throw Error(p$1(310));
    O$1 = a2;
    a2 = { memoizedState: O$1.memoizedState, baseState: O$1.baseState, baseQueue: O$1.baseQueue, queue: O$1.queue, next: null };
    null === P$1 ? N.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  }
  return P$1;
}
function ei(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$1(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$1, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, N.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$1(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi() {
}
function ii(a2, b2) {
  var c2 = N, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== P$1 && P$1.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === R)
      throw Error(p$1(349));
    0 !== (Rh & 30) || ni(c2, b2, e2);
  }
  return e2;
}
function ni(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi(b2) && pi(a2);
}
function ki(a2, b2, c2) {
  return c2(function() {
    oi(b2) && pi(a2);
  });
}
function oi(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi(a2) {
  var b2 = ci();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri.bind(null, N, a2);
  return [b2.memoizedState, a2];
}
function li(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si() {
  return di().memoizedState;
}
function ti(a2, b2, c2, d2) {
  var e2 = ci();
  N.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui(a2, b2, c2, d2) {
  var e2 = di();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O$1) {
    var g2 = O$1.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e2.memoizedState = li(b2, c2, f2, d2);
      return;
    }
  }
  N.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, f2, d2);
}
function vi(a2, b2) {
  return ti(8390656, 8, a2, b2);
}
function ji(a2, b2) {
  return ui(2048, 8, a2, b2);
}
function wi(a2, b2) {
  return ui(4, 2, a2, b2);
}
function xi(a2, b2) {
  return ui(4, 4, a2, b2);
}
function yi(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui(4, 4, yi.bind(null, b2, a2), c2);
}
function Ai() {
}
function Bi(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), N.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei(a2, b2) {
  var c2 = C;
  C = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e2 = L();
    mh(c2, a2, d2, e2);
    Ji(c2, b2, d2);
  }
}
function ri(a2, b2, c2) {
  var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e2, d2);
    null !== c2 && (e2 = L(), mh(c2, a2, d2, e2), Ji(c2, b2, d2));
  }
}
function Hi(a2) {
  var b2 = a2.alternate;
  return a2 === N || null !== b2 && b2 === N;
}
function Ii(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q$1, useContext: Q$1, useEffect: Q$1, useImperativeHandle: Q$1, useInsertionEffect: Q$1, useLayoutEffect: Q$1, useMemo: Q$1, useReducer: Q$1, useRef: Q$1, useState: Q$1, useDebugValue: Q$1, useDeferredValue: Q$1, useTransition: Q$1, useMutableSource: Q$1, useSyncExternalStore: Q$1, useId: Q$1, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi.bind(null, N, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
  return ci().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi(false), b2 = a2[0];
  a2 = Ei.bind(null, a2[1]);
  ci().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N, e2 = ci();
  if (I$1) {
    if (void 0 === c2)
      throw Error(p$1(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R)
      throw Error(p$1(349));
    0 !== (Rh & 30) || ni(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  vi(ki.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci(), b2 = R.identifierPrefix;
  if (I$1) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a2) {
    var b2 = di();
    return Di(b2, O$1.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi(ei)[0], b2 = di().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a2) {
  var b2 = di();
  return null === O$1 ? b2.memoizedState = a2 : Di(b2, O$1.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi(ei)[0], b2 = di().memoizedState;
  return [a2, b2];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Li(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a2, b2);
  };
  return c2;
}
function Ri(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi(a2, b2);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d2 = Xh(a2, b2, c2, d2, f2, e2);
  c2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$1 && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, d2, e2);
  return b2.child;
}
function aj(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie$1;
    if (c2(g2, d2) && a2.ref === b2.ref)
      return $i(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = wh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie$1(f2, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i(a2, b2, e2);
  }
  return dj(a2, b2, c2, d2, e2);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$1(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$1(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G$1(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$1(fj, gj), gj |= d2;
  Yi(a2, b2, e2, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c2 = Xh(a2, b2, c2, d2, f2, e2);
  d2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$1 && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, c2, e2);
  return b2.child;
}
function ij(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f2, e2);
}
function kj(a2, b2, c2, d2, e2, f2) {
  hj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b2, c2, false), $i(a2, b2, f2);
  d2 = b2.stateNode;
  Xi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a2, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = M$1.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e2 |= 1;
  G$1(M$1, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li(Error(p$1(422))), tj(a2, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Ah(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$1(419));
    d2 = Li(f2, d2, void 0);
    return tj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (Ug || h2) {
    d2 = R;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
    }
    uj();
    d2 = Li(Error(p$1(421)));
    return tj(a2, b2, g2, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I$1 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Yi(a2, b2, d2.children, c2);
  d2 = M$1.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G$1(M$1, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$1(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G$1(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G$1(M$1, M$1.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G$1(M$1, M$1.current & 1);
        a2 = $i(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G$1(M$1, M$1.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G$1(M$1, M$1.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$1({}, e2, { value: void 0 });
        d2 = A$1({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$1("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I$1)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S$1(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$1(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E(Wf);
      E(H);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S$1(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$1(166));
          S$1(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$1("cancel", d2);
              D$1("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$1("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D$1(lf[e2], d2);
              break;
            case "source":
              D$1("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$1(
                "error",
                d2
              );
              D$1("load", d2);
              break;
            case "details":
              D$1("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D$1("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$1("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$1("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$1("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$1("cancel", a2);
                D$1("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$1("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$1(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D$1("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$1(
                  "error",
                  a2
                );
                D$1("load", a2);
                e2 = d2;
                break;
              case "details":
                D$1("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D$1("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$1({}, d2, { value: void 0 });
                D$1("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D$1("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$1("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$1(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$1(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$1(b2);
      return null;
    case 13:
      E(M$1);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$1 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$1(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$1(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$1(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$1.current & 1) ? 0 === T$1 && (T$1 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$1(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$1(b2), null;
    case 10:
      return Rg(b2.type._context), S$1(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 19:
      E(M$1);
      f2 = b2.memoizedState;
      if (null === f2)
        return S$1(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T$1 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g2 = Mh(a2);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G$1(M$1, M$1.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$1)
              return S$1(b2), null;
          } else
            2 * B() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = M$1.current, G$1(M$1, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$1(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$1(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$1(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$1(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E(Wf), E(H), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E(M$1);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$1(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E(M$1), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$1 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$1 = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W$1(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$1(a2, b2, d2);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me();
  if (Ne(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$1 = b2; null !== V$1; )
    if (b2 = V$1, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V$1 = a2;
    else
      for (; null !== V$1; ) {
        b2 = V$1;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$1(163));
            }
        } catch (F2) {
          W$1(b2, b2.return, F2);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V$1 = a2;
          break;
        }
        V$1 = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X$1 = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U$1 || Mj(c2, b2);
    case 6:
      var d2 = X$1, e2 = Yj;
      X$1 = null;
      Zj(a2, b2, c2);
      X$1 = d2;
      Yj = e2;
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$1.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$1, c2.stateNode));
      break;
    case 4:
      d2 = X$1;
      e2 = Yj;
      X$1 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X$1 = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$1 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U$1 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$1(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$1 = (d2 = U$1) || null !== c2.memoizedState, Zj(a2, b2, c2), U$1 = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$1 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$1)
          throw Error(p$1(160));
        ak(f2, g2, e2);
        X$1 = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W$1(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$1(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$1 = (l2 = U$1) || m2, dk(b2, a2), U$1 = l2) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V$1 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V$1 = m2; null !== V$1; ) {
              r2 = V$1;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$1(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V$1 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$1(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$1(161));
      }
    } catch (k2) {
      W$1(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V$1 = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V$1; ) {
    var e2 = V$1, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$1;
        h2 = Kj;
        var l2 = U$1;
        Kj = g2;
        if ((U$1 = k2) && !l2)
          for (V$1 = e2; null !== V$1; )
            g2 = V$1, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V$1 = k2) : kk(e2);
        for (; null !== f2; )
          V$1 = f2, jk(f2), f2 = f2.sibling;
        V$1 = e2;
        Kj = h2;
        U$1 = l2;
      }
      lk(a2);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$1 = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$1 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$1)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$1(163));
          }
        U$1 || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$1(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function hk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function kk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$1(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$1(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$1(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$1 = h2;
      break;
    }
    V$1 = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R = null, Y$1 = null, Z$1 = 0, gj = 0, fj = Uf(0), T$1 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L() {
  return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K & 2) && 0 !== Z$1)
    return Z$1 & -Z$1;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$1(185));
  Ac(a2, c2, d2);
  if (0 === (K & 2) || a2 !== R)
    a2 === R && (0 === (K & 2) && (rk |= c2), 4 === T$1 && Dk(a2, Z$1)), Ek(a2, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Hj = B() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R ? Z$1 : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K & 6))
    throw Error(p$1(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R ? Z$1 : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e2 = K;
    K |= 2;
    var f2 = Kk();
    if (R !== a2 || Z$1 !== b2)
      vk = null, Hj = B() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K = e2;
    null !== Y$1 ? b2 = 0 : (R = null, Z$1 = 0, b2 = T$1);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$1(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$1(329));
      }
    }
  }
  Ek(a2, B());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K & 6))
    throw Error(p$1(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B()), c2;
  if (6 === c2)
    throw Error(p$1(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B());
  return null;
}
function Rk(a2, b2) {
  var c2 = K;
  K |= 1;
  try {
    return a2(b2);
  } finally {
    K = c2, 0 === K && (Hj = B() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
  var b2 = K;
  K |= 1;
  var c2 = pk.transition, d2 = C;
  try {
    if (pk.transition = null, C = 1, a2)
      return a2();
  } finally {
    C = d2, pk.transition = c2, K = b2, 0 === (K & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y$1)
    for (c2 = Y$1.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E(Wf);
          E(H);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E(M$1);
          break;
        case 19:
          E(M$1);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R = a2;
  Y$1 = a2 = wh(a2.current, null);
  Z$1 = gj = b2;
  T$1 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y$1;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$1 = O$1 = N = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T$1 = 1;
        qk = b2;
        Y$1 = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z$1;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$1(426));
          }
        } else if (I$1 && h2.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T$1 && (T$1 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y$1 === c2 && null !== c2 && (Y$1 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai;
  return null === a2 ? ai : a2;
}
function uj() {
  if (0 === T$1 || 3 === T$1 || 2 === T$1)
    T$1 = 4;
  null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z$1);
}
function Jk(a2, b2) {
  var c2 = K;
  K |= 2;
  var d2 = Kk();
  if (R !== a2 || Z$1 !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  Qg();
  K = c2;
  nk.current = d2;
  if (null !== Y$1)
    throw Error(p$1(261));
  R = null;
  Z$1 = 0;
  return T$1;
}
function Uk() {
  for (; null !== Y$1; )
    Vk(Y$1);
}
function Mk() {
  for (; null !== Y$1 && !cc(); )
    Vk(Y$1);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y$1 = b2;
  ok.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y$1 = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$1 = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$1 = 6;
        Y$1 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a2;
  } while (null !== b2);
  0 === T$1 && (T$1 = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C, e2 = pk.transition;
  try {
    pk.transition = null, C = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e2, C = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K & 6))
    throw Error(p$1(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$1(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === R && (Y$1 = R = null, Z$1 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C;
    C = 1;
    var h2 = K;
    K |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K = h2;
    C = g2;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Si = null);
  mc(c2.stateNode);
  Ek(a2, B());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a2 = Qi, Qi = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C;
    try {
      pk.transition = null;
      C = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K & 6))
          throw Error(p$1(331));
        var e2 = K;
        K |= 4;
        for (V$1 = a2.current; null !== V$1; ) {
          var f2 = V$1, g2 = f2.child;
          if (0 !== (V$1.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$1 = l2; null !== V$1; ) {
                  var m2 = V$1;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$1 = q2;
                  else
                    for (; null !== V$1; ) {
                      m2 = V$1;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$1 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V$1 = r2;
                        break;
                      }
                      V$1 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$1 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V$1 = g2;
          else
            b:
              for (; null !== V$1; ) {
                f2 = V$1;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V$1 = x2;
                  break b;
                }
                V$1 = f2.return;
              }
        }
        var w2 = a2.current;
        for (V$1 = w2; null !== V$1; ) {
          g2 = V$1;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V$1 = u2;
          else
            b:
              for (g2 = w2; null !== V$1; ) {
                h2 = V$1;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$1(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V$1 = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V$1 = F2;
                  break b;
                }
                V$1 = h2.return;
              }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W$1(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a2 = Ki(c2, a2);
          a2 = Ri(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R === a2 && (Z$1 & c2) === c2 && (4 === T$1 || 3 === T$1 && (Z$1 & 130023424) === Z$1 && 500 > B() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$1(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$1 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H.current);
      Tg(b2, c2);
      e2 = Xh(null, b2, d2, a2, e2, c2);
      var f2 = bi();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$1 && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$1(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$1(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a2, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki(Error(p$1(423)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki(Error(p$1(424)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$1 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = $i(a2, b2, c2);
            break a;
          }
          Yi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b2, d2, e2, c2);
    case 7:
      return Yi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G$1(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$1(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$1(156, b2.tag));
};
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$1(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$1(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$1(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = cl(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L();
  e2 = lh(c2);
  f2 = ch(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = L(), g2 = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e2, b2, g2);
  null !== a2 && (mh(a2, e2, g2, f2), eh(a2, e2, g2));
  return g2;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$1(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = hl(g2);
        f2.call(a3);
      };
    }
    var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = hl(g2);
        h2.call(a3);
      };
    }
    gl(b2, g2, a2, e2);
  } else
    g2 = rl(c2, b2, a2, e2, d2);
  return hl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d2 = L();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
};
Hc = function() {
  return C;
};
Ic = function(a2, b2) {
  var c2 = C;
  try {
    return C = a2, b2();
  } finally {
    C = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$1(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue$1, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$1(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$1(299));
  var c2 = false, d2 = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$1(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$1(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$1(200));
  return sl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$1(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$1(200));
  return sl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$1(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$1(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$1(38));
  return sl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
var m$1 = reactDomExports;
{
  client.createRoot = m$1.createRoot;
  client.hydrateRoot = m$1.hydrateRoot;
}
/**
 * @remix-run/router v1.7.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function invariant$1(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning$1(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$1({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index = getIndex();
  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends$1({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    invariant$1(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
    matches = matchRouteBranch(
      branches[i2],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant$1(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant$1(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0)
    return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s2) => s2 === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning$1(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (_2, paramName) => {
    paramNames.push(paramName);
    return "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning$1(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning$1(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.14.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant$1(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState) {
  !useInRouterContext() ? invariant$1(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant$1(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
    ]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
    ])
  })), parentMatches, dataRouterState);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error || state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  var _dataRouterState2;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (matches == null) {
    var _dataRouterState;
    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
    !(errorIndex >= 0) ? invariant$1(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match, index) => {
    let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null;
    let errorElement = null;
    if (dataRouterState) {
      errorElement = match.route.errorElement || defaultErrorElement;
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (match.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook$1;
(function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
})(DataRouterHook$1 || (DataRouterHook$1 = {}));
var DataRouterStateHook$1;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
})(DataRouterStateHook$1 || (DataRouterStateHook$1 = {}));
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant$1(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant$1(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant$1(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  if (error) {
    return error;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function Route(_props) {
  invariant$1(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref5;
  !!useInRouterContext() ? invariant$1(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location);
}
var AwaitRenderStatus;
(function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2["pending"] = 0] = "pending";
  AwaitRenderStatus2[AwaitRenderStatus2["success"] = 1] = "success";
  AwaitRenderStatus2[AwaitRenderStatus2["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children, (element, index) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? invariant$1(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant$1(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.14.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
const START_TRANSITION = "startTransition";
const startTransitionImpl = React$1[START_TRANSITION];
function BrowserRouter(_ref) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/2023/nene/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links.length - 1; i2 >= 0; i2--) {
        const link2 = links[i2];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
const MotionConfigContext = reactExports.createContext({
  transformPagePoint: (p2) => p2,
  isStatic: false,
  reducedMotion: "never"
});
const MotionContext = reactExports.createContext({});
const PresenceContext = reactExports.createContext(null);
const isBrowser = typeof document !== "undefined";
const useIsomorphicLayoutEffect = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect;
const LazyContext = reactExports.createContext({ strict: false });
function useVisualElement(Component, visualState, props, createVisualElement) {
  const { visualElement: parent } = reactExports.useContext(MotionContext);
  const lazyContext = reactExports.useContext(LazyContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = reactExports.useRef();
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  reactExports.useInsertionEffect(() => {
    visualElement && visualElement.update(props, presenceContext);
  });
  useIsomorphicLayoutEffect(() => {
    visualElement && visualElement.render();
  });
  reactExports.useEffect(() => {
    visualElement && visualElement.updateFeatures();
  });
  const useAnimateChangesEffect = window.HandoffAppearAnimations ? useIsomorphicLayoutEffect : reactExports.useEffect;
  useAnimateChangesEffect(() => {
    if (visualElement && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  return visualElement;
}
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return reactExports.useCallback(
    (instance2) => {
      instance2 && visualState.mount && visualState.mount(instance2);
      if (visualElement) {
        instance2 ? visualElement.mount(instance2) : visualElement.unmount();
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance2);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance2;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
function isVariantLabel(v2) {
  return typeof v2 === "string" || Array.isArray(v2);
}
function isAnimationControls(v2) {
  return typeof v2 === "object" && typeof v2.start === "function";
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
const variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
  return reactExports.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
const featureDefinitions = {};
for (const key in featureProps) {
  featureDefinitions[key] = {
    isEnabled: (props) => featureProps[key].some((name) => !!props[name])
  };
}
function loadFeatures(features) {
  for (const key in features) {
    featureDefinitions[key] = {
      ...featureDefinitions[key],
      ...features[key]
    };
  }
}
const LayoutGroupContext = reactExports.createContext({});
const SwitchLayoutGroupContext = reactExports.createContext({});
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createMotionComponent({ preloadedFeatures: preloadedFeatures2, createVisualElement, useRender, useVisualState, Component }) {
  preloadedFeatures2 && loadFeatures(preloadedFeatures2);
  function MotionComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...reactExports.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser) {
      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);
      const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
      const isStrict = reactExports.useContext(LazyContext).strict;
      if (context.visualElement) {
        MeasureLayout2 = context.visualElement.loadFeatures(
          // Note: Pass the full new combined props to correctly re-render dynamic feature components.
          configAndProps,
          isStrict,
          preloadedFeatures2,
          initialLayoutGroupConfig
        );
      }
    }
    return reactExports.createElement(
      MotionContext.Provider,
      { value: context },
      MeasureLayout2 && context.visualElement ? reactExports.createElement(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null,
      useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)
    );
  }
  const ForwardRefComponent = reactExports.forwardRef(MotionComponent);
  ForwardRefComponent[motionComponentSymbol] = Component;
  return ForwardRefComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function createMotionProxy(createConfig) {
  function custom(Component, customMotionComponentConfig = {}) {
    return createMotionComponent(createConfig(Component, customMotionComponentConfig));
  }
  if (typeof Proxy === "undefined") {
    return custom;
  }
  const componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => {
      if (!componentCache.has(key)) {
        componentCache.set(key, custom(key));
      }
      return componentCache.get(key);
    }
  });
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/.test(Component)
  ) {
    return true;
  }
  return false;
}
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
const transformProps = new Set(transformPropOrder);
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
const isMotionValue = (value) => Boolean(value && value.getVelocity);
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const numTransforms = transformPropOrder.length;
function buildTransform(transform, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {
  let transformString = "";
  for (let i2 = 0; i2 < numTransforms; i2++) {
    const key = transformPropOrder[i2];
    if (transform[key] !== void 0) {
      const transformName = translateAlias[key] || key;
      transformString += `${transformName}(${transform[key]}) `;
    }
  }
  if (enableHardwareAcceleration && !transform.z) {
    transformString += "translateZ(0)";
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
const checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
const isCSSVariableName = checkStringStartsWith("--");
const isCSSVariableToken = checkStringStartsWith("var(--");
const cssVariableRegex = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g;
const getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};
const clamp = (min, max, v2) => Math.min(Math.max(v2, min), max);
const number = {
  test: (v2) => typeof v2 === "number",
  parse: parseFloat,
  transform: (v2) => v2
};
const alpha = {
  ...number,
  transform: (v2) => clamp(0, 1, v2)
};
const scale = {
  ...number,
  default: 1
};
const sanitize = (v2) => Math.round(v2 * 1e5) / 1e5;
const floatRegex = /(-)?([\d]*\.?[\d])+/g;
const colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
const singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString(v2) {
  return typeof v2 === "string";
}
const createUnitType = (unit) => ({
  test: (v2) => isString(v2) && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
});
const degrees = createUnitType("deg");
const percent = createUnitType("%");
const px = createUnitType("px");
const vh = createUnitType("vh");
const vw = createUnitType("vw");
const progressPercentage = {
  ...percent,
  parse: (v2) => percent.parse(v2) / 100,
  transform: (v2) => percent.transform(v2 * 100)
};
const int = {
  ...number,
  transform: Math.round
};
const numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
function buildHTMLStyles(state, latestValues, options, transformTemplate) {
  const { style, vars, transform, transformOrigin } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  let transformIsNone = true;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    }
    const valueType = numberValueTypes[key];
    const valueAsType = getValueAsType(value, valueType);
    if (transformProps.has(key)) {
      hasTransform2 = true;
      transform[key] = valueAsType;
      if (!transformIsNone)
        continue;
      if (value !== (valueType.default || 0))
        transformIsNone = false;
    } else if (key.startsWith("origin")) {
      hasTransformOrigin = true;
      transformOrigin[key] = valueAsType;
    } else {
      style[key] = valueAsType;
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform(state.transform, options, transformIsNone, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState, isStatic) {
  return reactExports.useMemo(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
  return props.transformValues ? props.transformValues(style) : style;
}
function useHTMLProps(props, visualState, isStatic) {
  const htmlProps = {};
  const style = useStyle(props, visualState, isStatic);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || validMotionProps.has(key);
}
let shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch (_a) {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (key === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
function calcOrigin$1(origin, offset, size) {
  return typeof origin === "string" ? origin : px.transform(offset + size * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset);
  const pathLength = px.transform(length);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, options, isSVGTag2, transformTemplate) {
  buildHTMLStyles(state, latest, options, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style, dimensions } = state;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
function useSVGProps(props, visualState, _isStatic, Component) {
  const visualProps = reactExports.useMemo(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, isSVGTag(Component), props.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component, props, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component);
    const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    const elementProps = {
      ...filteredProps,
      ...visualProps,
      ref
    };
    const { children } = props;
    const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    return reactExports.createElement(Component, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function renderHTML(element, { style, vars }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
function scrapeMotionValuesFromProps$1(props, prevProps) {
  const { style } = props;
  const newValues = {};
  for (const key in style) {
    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props)) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}
function scrapeMotionValuesFromProps(props, prevProps) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
function resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {
  if (typeof definition === "function") {
    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  return definition;
}
function useConstant(init) {
  const ref = reactExports.useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}
const isKeyframesTarget = (v2) => {
  return Array.isArray(v2);
};
const isCustomValue = (v2) => {
  return Boolean(v2 && typeof v2 === "object" && v2.mix && v2.toValue);
};
const resolveFinalValueInKeyframes = (v2) => {
  return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
};
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onMount }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = (instance2) => onMount(props, instance2, state);
  }
  return state;
}
const makeUseVisualState = (config) => (props, isStatic) => {
  const context = reactExports.useContext(MotionContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const make = () => makeState(config, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate === void 0)
      animate = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list.forEach((definition) => {
      const resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      const { transitionEnd, transition, ...target } = resolved;
      for (const key in target) {
        let valueTarget = target[key];
        if (Array.isArray(valueTarget)) {
          const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index];
        }
        if (valueTarget !== null) {
          values[key] = valueTarget;
        }
      }
      for (const key in transitionEnd)
        values[key] = transitionEnd[key];
    });
  }
  return values;
}
const svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onMount: (props, instance2, { renderState, latestValues }) => {
      try {
        renderState.dimensions = typeof instance2.getBBox === "function" ? instance2.getBBox() : instance2.getBoundingClientRect();
      } catch (e2) {
        renderState.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, isSVGTag(instance2.tagName), props.transformTemplate);
      renderSVG(instance2, renderState);
    }
  })
};
const htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function createDomMotionConfig(Component, { forwardMotionProps = false }, preloadedFeatures2, createVisualElement) {
  const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
  return {
    ...baseConfig,
    preloadedFeatures: preloadedFeatures2,
    useRender: createUseRender(forwardMotionProps),
    createVisualElement,
    Component
  };
}
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
const isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};
function extractEventInfo(event, pointType = "page") {
  return {
    point: {
      x: event[pointType + "X"],
      y: event[pointType + "Y"]
    }
  };
}
const addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
const combineFunctions = (a2, b2) => (v2) => b2(a2(v2));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
function createLock(name) {
  let lock = null;
  return () => {
    const openLock = () => {
      lock = null;
    };
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
const globalHorizontalLock = createLock("dragHorizontal");
const globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    const openHorizontal = globalHorizontalLock();
    const openVertical = globalVerticalLock();
    if (openHorizontal && openVertical) {
      lock = () => {
        openHorizontal();
        openVertical();
      };
    } else {
      if (openHorizontal)
        openHorizontal();
      if (openVertical)
        openVertical();
    }
  }
  return lock;
}
function isDragActive() {
  const openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}
class Feature {
  constructor(node) {
    this.isMounted = false;
    this.node = node;
  }
  update() {
  }
}
function createRenderStep(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing)
          numToRun = toRun.length;
      }
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      const index = toRunNextFrame.indexOf(callback);
      if (index !== -1)
        toRunNextFrame.splice(index, 1);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i2 = 0; i2 < numToRun; i2++) {
          const callback = toRun[i2];
          callback(frameData2);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}
const frameData = {
  delta: 0,
  timestamp: 0,
  isProcessing: false
};
const maxElapsed = 40;
let useDefaultElapsed = true;
let runNextFrame = false;
const stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
const steps = stepsOrder.reduce((acc, key) => {
  acc[key] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
const processStep = (stepId) => steps[stepId].process(frameData);
const processFrame = (timestamp) => {
  runNextFrame = false;
  frameData.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - frameData.timestamp, maxElapsed), 1);
  frameData.timestamp = timestamp;
  frameData.isProcessing = true;
  stepsOrder.forEach(processStep);
  frameData.isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    requestAnimationFrame(processFrame);
  }
};
const startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!frameData.isProcessing)
    requestAnimationFrame(processFrame);
};
const frame = stepsOrder.reduce((acc, key) => {
  const step = steps[key];
  acc[key] = (process, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step.schedule(process, keepAlive, immediate);
  };
  return acc;
}, {});
function cancelFrame(process) {
  stepsOrder.forEach((key) => steps[key].cancel(process));
}
function addHoverEvent(node, isActive) {
  const eventName = "pointer" + (isActive ? "enter" : "leave");
  const callbackName = "onHover" + (isActive ? "Start" : "End");
  const handleEvent = (event, info) => {
    if (event.type === "touch" || isDragActive())
      return;
    const props = node.getProps();
    if (node.animationState && props.whileHover) {
      node.animationState.setActive("whileHover", isActive);
    }
    if (props[callbackName]) {
      frame.update(() => props[callbackName](event, info));
    }
  };
  return addPointerEvent(node.current, eventName, handleEvent, {
    passive: !node.getProps()[callbackName]
  });
}
class HoverGesture extends Feature {
  mount() {
    this.unmount = pipe(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible = false;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch (e2) {
      isFocusVisible = true;
    }
    if (!isFocusVisible || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const isNodeOrChild = (parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};
const noop$1 = (any) => any;
function fireSyntheticPointerEvent(name, handler) {
  if (!handler)
    return;
  const syntheticPointerEvent = new PointerEvent("pointer" + name);
  handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
}
class PressGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removeStartListeners = noop$1;
    this.removeEndListeners = noop$1;
    this.removeAccessibleListeners = noop$1;
    this.startPointerPress = (startEvent, startInfo) => {
      this.removeEndListeners();
      if (this.isPressing)
        return;
      const props = this.node.getProps();
      const endPointerPress = (endEvent, endInfo) => {
        if (!this.checkPressEnd())
          return;
        const { onTap, onTapCancel } = this.node.getProps();
        frame.update(() => {
          !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel && onTapCancel(endEvent, endInfo) : onTap && onTap(endEvent, endInfo);
        });
      };
      const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, { passive: !(props.onTap || props["onPointerUp"]) });
      const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), { passive: !(props.onTapCancel || props["onPointerCancel"]) });
      this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
      this.startPress(startEvent, startInfo);
    };
    this.startAccessiblePress = () => {
      const handleKeydown = (keydownEvent) => {
        if (keydownEvent.key !== "Enter" || this.isPressing)
          return;
        const handleKeyup = (keyupEvent) => {
          if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
            return;
          fireSyntheticPointerEvent("up", (event, info) => {
            const { onTap } = this.node.getProps();
            if (onTap) {
              frame.update(() => onTap(event, info));
            }
          });
        };
        this.removeEndListeners();
        this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup);
        fireSyntheticPointerEvent("down", (event, info) => {
          this.startPress(event, info);
        });
      };
      const removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown);
      const handleBlur = () => {
        if (!this.isPressing)
          return;
        fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
      };
      const removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
      this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
    };
  }
  startPress(event, info) {
    this.isPressing = true;
    const { onTapStart, whileTap } = this.node.getProps();
    if (whileTap && this.node.animationState) {
      this.node.animationState.setActive("whileTap", true);
    }
    if (onTapStart) {
      frame.update(() => onTapStart(event, info));
    }
  }
  checkPressEnd() {
    this.removeEndListeners();
    this.isPressing = false;
    const props = this.node.getProps();
    if (props.whileTap && this.node.animationState) {
      this.node.animationState.setActive("whileTap", false);
    }
    return !isDragActive();
  }
  cancelPress(event, info) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel } = this.node.getProps();
    if (onTapCancel) {
      frame.update(() => onTapCancel(event, info));
    }
  }
  mount() {
    const props = this.node.getProps();
    const removePointerListener = addPointerEvent(this.node.current, "pointerdown", this.startPointerPress, { passive: !(props.onTapStart || props["onPointerStart"]) });
    const removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
  }
  unmount() {
    this.removeStartListeners();
    this.removeEndListeners();
    this.removeAccessibleListeners();
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
const fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root, ...options }) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps();
    const { root, margin: rootMargin, amount = "some", once } = viewport;
    const options = {
      root: root ? root.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting)
        return;
      this.isInView = isIntersecting;
      if (once && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined")
      return;
    const { props, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (let i2 = 0; i2 < prevLength; i2++) {
    if (prev[i2] !== next[i2])
      return false;
  }
  return true;
}
function getCurrent(visualElement) {
  const current = {};
  visualElement.values.forEach((value, key) => current[key] = value.get());
  return current;
}
function getVelocity$1(visualElement) {
  const velocity = {};
  visualElement.values.forEach((value, key) => velocity[key] = value.getVelocity());
  return velocity;
}
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));
}
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
let warning = noop$1;
let invariant = noop$1;
const secondsToMilliseconds = (seconds) => seconds * 1e3;
const millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;
const instantAnimationState = {
  current: false
};
const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
function isWaapiSupportedEasing(easing) {
  return Boolean(!easing || typeof easing === "string" && supportedWaapiEasing[easing] || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
}
const cubicBezierAsString = ([a2, b2, c2, d2]) => `cubic-bezier(${a2}, ${b2}, ${c2}, ${d2})`;
const supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing) {
  if (!easing)
    return void 0;
  return isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map(mapEasingToNativeEasing) : supportedWaapiEasing[easing];
}
function animateStyle(element, valueName, keyframes2, { delay: delay2 = 0, duration, repeat = 0, repeatType = "loop", ease: ease2, times } = {}) {
  const keyframeOptions = { [valueName]: keyframes2 };
  if (times)
    keyframeOptions.offset = times;
  const easing = mapEasingToNativeEasing(ease2);
  if (Array.isArray(easing))
    keyframeOptions.easing = easing;
  return element.animate(keyframeOptions, {
    delay: delay2,
    duration,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}
const featureTests = {
  waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate")
};
const results = {};
const supports = {};
for (const key in featureTests) {
  supports[key] = () => {
    if (results[key] === void 0)
      results[key] = featureTests[key]();
    return results[key];
  };
}
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }) {
  const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : keyframes2.length - 1;
  return keyframes2[index];
}
const calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2;
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i2 = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x2;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop$1;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
const easeIn = cubicBezier(0.42, 0, 1, 1);
const easeOut = cubicBezier(0, 0, 0.58, 1);
const easeInOut = cubicBezier(0.42, 0, 0.58, 1);
const isEasingArray = (ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
};
const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;
const reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);
const circIn = (p2) => 1 - Math.sin(Math.acos(p2));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circOut);
const backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = reverseEasing(backOut);
const backInOut = mirrorEasing(backIn);
const anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
const easingLookup = {
  linear: noop$1,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
const easingDefinitionToFunction = (definition) => {
  if (Array.isArray(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    return easingLookup[definition];
  }
  return definition;
};
const isColorString = (type, testProp) => (v2) => {
  return Boolean(isString(v2) && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v2, testProp));
};
const splitColor = (aName, bName, cName) => (v2) => {
  if (!isString(v2))
    return v2;
  const [a2, b2, c2, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const clampRgbUnit = (v2) => clamp(0, 255, v2);
const rgbUnit = {
  ...number,
  transform: (v2) => Math.round(clampRgbUnit(v2))
};
const rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v2) {
  let r2 = "";
  let g2 = "";
  let b2 = "";
  let a2 = "";
  if (v2.length > 5) {
    r2 = v2.substring(1, 3);
    g2 = v2.substring(3, 5);
    b2 = v2.substring(5, 7);
    a2 = v2.substring(7, 9);
  } else {
    r2 = v2.substring(1, 2);
    g2 = v2.substring(2, 3);
    b2 = v2.substring(3, 4);
    a2 = v2.substring(4, 5);
    r2 += r2;
    g2 += g2;
    b2 += b2;
    a2 += a2;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
const hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
const color = {
  test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => {
    if (rgba.test(v2)) {
      return rgba.parse(v2);
    } else if (hsla.test(v2)) {
      return hsla.parse(v2);
    } else {
      return hex.parse(v2);
    }
  },
  transform: (v2) => {
    return isString(v2) ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
  }
};
const mix = (from, to, progress2) => -progress2 * from + progress2 * to + from;
function hueToRgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  return p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q2;
    red = hueToRgb(p2, q2, hue + 1 / 3);
    green = hueToRgb(p2, q2, hue);
    blue = hueToRgb(p2, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
const mixLinearColor = (from, to, v2) => {
  const fromExpo = from * from;
  return Math.sqrt(Math.max(0, v2 * (to * to - fromExpo) + fromExpo));
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v2) => colorTypes.find((type) => type.test(v2));
function asRGBA(color2) {
  const type = getColorType(color2);
  let model = type.parse(color2);
  if (type === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
const mixColor = (from, to) => {
  const fromRGBA = asRGBA(from);
  const toRGBA = asRGBA(to);
  const blended = { ...fromRGBA };
  return (v2) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
    blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v2);
    return rgba.transform(blended);
  };
};
function test(v2) {
  var _a, _b;
  return isNaN(v2) && isString(v2) && (((_a = v2.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v2.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
}
const cssVarTokeniser = {
  regex: cssVariableRegex,
  countKey: "Vars",
  token: "${v}",
  parse: noop$1
};
const colorTokeniser = {
  regex: colorRegex,
  countKey: "Colors",
  token: "${c}",
  parse: color.parse
};
const numberTokeniser = {
  regex: floatRegex,
  countKey: "Numbers",
  token: "${n}",
  parse: number.parse
};
function tokenise(info, { regex, countKey, token, parse }) {
  const matches = info.tokenised.match(regex);
  if (!matches)
    return;
  info["num" + countKey] = matches.length;
  info.tokenised = info.tokenised.replace(regex, token);
  info.values.push(...matches.map(parse));
}
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const info = {
    value: originalValue,
    tokenised: originalValue,
    values: [],
    numVars: 0,
    numColors: 0,
    numNumbers: 0
  };
  if (info.value.includes("var(--"))
    tokenise(info, cssVarTokeniser);
  tokenise(info, colorTokeniser);
  tokenise(info, numberTokeniser);
  return info;
}
function parseComplexValue(v2) {
  return analyseComplexValue(v2).values;
}
function createTransformer(source) {
  const { values, numColors, numVars, tokenised } = analyseComplexValue(source);
  const numValues = values.length;
  return (v2) => {
    let output = tokenised;
    for (let i2 = 0; i2 < numValues; i2++) {
      if (i2 < numVars) {
        output = output.replace(cssVarTokeniser.token, v2[i2]);
      } else if (i2 < numVars + numColors) {
        output = output.replace(colorTokeniser.token, color.transform(v2[i2]));
      } else {
        output = output.replace(numberTokeniser.token, sanitize(v2[i2]));
      }
    }
    return output;
  };
}
const convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : v2;
function getAnimatableNone$1(v2) {
  const parsed = parseComplexValue(v2);
  const transformer = createTransformer(v2);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
};
const mixImmediate = (origin, target) => (p2) => `${p2 > 0 ? target : origin}`;
function getMixer(origin, target) {
  if (typeof origin === "number") {
    return (v2) => mix(origin, target, v2);
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return origin.startsWith("var(") ? mixImmediate(origin, target) : mixComplex(origin, target);
  }
}
const mixArray = (from, to) => {
  const output = [...from];
  const numValues = output.length;
  const blendValue = from.map((fromThis, i2) => getMixer(fromThis, to[i2]));
  return (v2) => {
    for (let i2 = 0; i2 < numValues; i2++) {
      output[i2] = blendValue[i2](v2);
    }
    return output;
  };
};
const mixObject = (origin, target) => {
  const output = { ...origin, ...target };
  const blendValue = {};
  for (const key in output) {
    if (origin[key] !== void 0 && target[key] !== void 0) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }
  return (v2) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v2);
    }
    return output;
  };
};
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.numVars === targetStats.numVars && originStats.numColors === targetStats.numColors && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe(mixArray(originStats.values, targetStats.values), template);
  } else {
    return mixImmediate(origin, target);
  }
};
const progress = (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
const mixNumber = (from, to) => (p2) => mix(from, to, p2);
function detectMixerFactory(v2) {
  if (typeof v2 === "number") {
    return mixNumber;
  } else if (typeof v2 === "string") {
    return color.test(v2) ? mixColor : mixComplex;
  } else if (Array.isArray(v2)) {
    return mixArray;
  } else if (typeof v2 === "object") {
    return mixObject;
  }
  return mixNumber;
}
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output[0]);
  const numMixers = output.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output[i2], output[i2 + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop$1 : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length);
  if (inputLength === 1)
    return () => output[0];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = (v2) => {
    let i2 = 0;
    if (numMixers > 1) {
      for (; i2 < input.length - 2; i2++) {
        if (v2 < input[i2 + 1])
          break;
      }
    }
    const progressInRange = progress(input[i2], input[i2 + 1], v2);
    return mixers[i2](progressInRange);
  };
  return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
}
function fillOffset(offset, remaining) {
  const min = offset[offset.length - 1];
  for (let i2 = 1; i2 <= remaining; i2++) {
    const offsetProgress = progress(0, remaining, i2);
    offset.push(mix(min, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset = [0];
  fillOffset(offset, arr.length - 1);
  return offset;
}
function convertOffsetToTimes(offset, duration) {
  return offset.map((o2) => o2 * duration);
}
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t2) => {
      state.value = mapTimeToKeyframe(t2);
      state.done = t2 >= duration;
      return state;
    }
  };
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t2, current) {
  const prevT = Math.max(t2 - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t2 - prevT);
}
const safeMin = 1e-3;
const minDuration = 0.01;
const maxDuration$1 = 10;
const minDamping = 0.05;
const maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning(duration <= secondsToMilliseconds(maxDuration$1));
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
  duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration));
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a2 = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a2 / b2 * c2;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d2 = delta * velocity + velocity;
      const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d2 - e2) * f2) / g2;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a2 * b2;
    };
    derivative = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (velocity - undampedFreq2) * (duration * duration);
      return a2 * b2;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = secondsToMilliseconds(duration);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = {
      ...springOptions,
      ...derived,
      velocity: 0,
      mass: 1
    };
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring({ keyframes: keyframes2, restDelta, restSpeed, ...options }) {
  const origin = keyframes2[0];
  const target = keyframes2[keyframes2.length - 1];
  const state = { done: false, value: origin };
  const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);
  const initialVelocity = velocity ? -millisecondsToSeconds(velocity) : 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
  restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
    };
  } else if (dampingRatio === 1) {
    resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      const freqForT = Math.min(dampedAngularFreq * t2, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  return {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        let currentVelocity = initialVelocity;
        if (t2 !== 0) {
          if (dampingRatio < 1) {
            currentVelocity = calcGeneratorVelocity(resolveSpring, t2, current);
          } else {
            currentVelocity = 0;
          }
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t2 >= duration;
      }
      state.value = state.done ? target : current;
      return state;
    }
  };
}
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0];
  const state = {
    done: false,
    value: origin
  };
  const isOutOfBounds = (v2) => min !== void 0 && v2 < min || max !== void 0 && v2 > max;
  const nearestBoundary = (v2) => {
    if (min === void 0)
      return max;
    if (max === void 0)
      return min;
    return Math.abs(min - v2) < Math.abs(max - v2) ? min : max;
  };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant);
  const calcLatest = (t2) => target + calcDelta(t2);
  const applyFriction = (t2) => {
    const delta = calcDelta(t2);
    const latest = calcLatest(t2);
    state.done = Math.abs(delta) <= restDelta;
    state.value = state.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t2) => {
    if (!isOutOfBounds(state.value))
      return;
    timeReachedBoundary = t2;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t2, state.value),
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t2) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t2);
        checkCatchBoundary(t2);
      }
      if (timeReachedBoundary !== void 0 && t2 > timeReachedBoundary) {
        return spring$1.next(t2 - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t2);
        return state;
      }
    }
  };
}
const frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: () => frame.update(passTimestamp, true),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : performance.now()
  };
};
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  while (!state.done && duration < maxGeneratorDuration) {
    duration += timeStep;
    state = generator.next(duration);
  }
  return duration >= maxGeneratorDuration ? Infinity : duration;
}
const types = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
function animateValue({ autoplay = true, delay: delay2 = 0, driver = frameloopDriver, keyframes: keyframes$1, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", onPlay, onStop, onComplete, onUpdate, ...options }) {
  let speed = 1;
  let hasStopped = false;
  let resolveFinishedPromise;
  let currentFinishedPromise;
  const updateFinishedPromise = () => {
    resolveFinishedPromise && resolveFinishedPromise();
    currentFinishedPromise = new Promise((resolve) => {
      resolveFinishedPromise = resolve;
    });
  };
  updateFinishedPromise();
  let animationDriver;
  const generatorFactory = types[type] || keyframes;
  let mapNumbersToKeyframes;
  if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
    mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {
      clamp: false
    });
    keyframes$1 = [0, 100];
  }
  const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
  let mirroredGenerator;
  if (repeatType === "mirror") {
    mirroredGenerator = generatorFactory({
      ...options,
      keyframes: [...keyframes$1].reverse(),
      velocity: -(options.velocity || 0)
    });
  }
  let playState = "idle";
  let holdTime = null;
  let startTime = null;
  let cancelTime = null;
  if (generator.calculatedDuration === null && repeat) {
    generator.calculatedDuration = calcGeneratorDuration(generator);
  }
  const { calculatedDuration } = generator;
  let resolvedDuration = Infinity;
  let totalDuration = Infinity;
  if (calculatedDuration !== null) {
    resolvedDuration = calculatedDuration + repeatDelay;
    totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
  }
  let currentTime = 0;
  const tick = (timestamp) => {
    if (startTime === null)
      return;
    if (speed > 0)
      startTime = Math.min(startTime, timestamp);
    if (speed < 0)
      startTime = Math.min(timestamp - totalDuration / speed, startTime);
    if (holdTime !== null) {
      currentTime = holdTime;
    } else {
      currentTime = Math.round(timestamp - startTime) * speed;
    }
    const timeWithoutDelay = currentTime - delay2 * (speed >= 0 ? 1 : -1);
    const isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    currentTime = Math.max(timeWithoutDelay, 0);
    if (playState === "finished" && holdTime === null) {
      currentTime = totalDuration;
    }
    let elapsed = currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = currentTime / resolvedDuration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const iterationIsOdd = Boolean(currentIteration % 2);
      if (iterationIsOdd) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      let p2 = clamp(0, 1, iterationProgress);
      if (currentTime > totalDuration) {
        p2 = repeatType === "reverse" && iterationIsOdd ? 1 : 0;
      }
      elapsed = p2 * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: false, value: keyframes$1[0] } : frameGenerator.next(elapsed);
    if (mapNumbersToKeyframes) {
      state.value = mapNumbersToKeyframes(state.value);
    }
    let { done } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;
    }
    const isAnimationFinished = holdTime === null && (playState === "finished" || playState === "running" && done);
    if (onUpdate) {
      onUpdate(state.value);
    }
    if (isAnimationFinished) {
      finish();
    }
    return state;
  };
  const stopAnimationDriver = () => {
    animationDriver && animationDriver.stop();
    animationDriver = void 0;
  };
  const cancel = () => {
    playState = "idle";
    stopAnimationDriver();
    updateFinishedPromise();
    startTime = cancelTime = null;
  };
  const finish = () => {
    playState = "finished";
    onComplete && onComplete();
    stopAnimationDriver();
    updateFinishedPromise();
  };
  const play = () => {
    if (hasStopped)
      return;
    if (!animationDriver)
      animationDriver = driver(tick);
    const now = animationDriver.now();
    onPlay && onPlay();
    if (holdTime !== null) {
      startTime = now - holdTime;
    } else if (!startTime || playState === "finished") {
      startTime = now;
    }
    cancelTime = startTime;
    holdTime = null;
    playState = "running";
    animationDriver.start();
  };
  if (autoplay) {
    play();
  }
  const controls = {
    then(resolve, reject) {
      return currentFinishedPromise.then(resolve, reject);
    },
    get time() {
      return millisecondsToSeconds(currentTime);
    },
    set time(newTime) {
      newTime = secondsToMilliseconds(newTime);
      currentTime = newTime;
      if (holdTime !== null || !animationDriver || speed === 0) {
        holdTime = newTime;
      } else {
        startTime = animationDriver.now() - newTime / speed;
      }
    },
    get duration() {
      const duration = generator.calculatedDuration === null ? calcGeneratorDuration(generator) : generator.calculatedDuration;
      return millisecondsToSeconds(duration);
    },
    get speed() {
      return speed;
    },
    set speed(newSpeed) {
      if (newSpeed === speed || !animationDriver)
        return;
      speed = newSpeed;
      controls.time = millisecondsToSeconds(currentTime);
    },
    get state() {
      return playState;
    },
    play,
    pause: () => {
      playState = "paused";
      holdTime = currentTime;
    },
    stop: () => {
      hasStopped = true;
      if (playState === "idle")
        return;
      playState = "idle";
      onStop && onStop();
      cancel();
    },
    cancel: () => {
      if (cancelTime !== null)
        tick(cancelTime);
      cancel();
    },
    complete: () => {
      playState = "finished";
    },
    sample: (elapsed) => {
      startTime = 0;
      return tick(elapsed);
    }
  };
  return controls;
}
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform",
  "backgroundColor"
]);
const sampleDelta = 10;
const maxDuration = 2e4;
const requiresPregeneratedKeyframes = (valueName, options) => options.type === "spring" || valueName === "backgroundColor" || !isWaapiSupportedEasing(options.ease);
function createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options }) {
  const canAccelerateAnimation = supports.waapi() && acceleratedValues.has(valueName) && !options.repeatDelay && options.repeatType !== "mirror" && options.damping !== 0 && options.type !== "inertia";
  if (!canAccelerateAnimation)
    return false;
  let hasStopped = false;
  let resolveFinishedPromise;
  let currentFinishedPromise;
  const updateFinishedPromise = () => {
    currentFinishedPromise = new Promise((resolve) => {
      resolveFinishedPromise = resolve;
    });
  };
  updateFinishedPromise();
  let { keyframes: keyframes2, duration = 300, ease: ease2, times } = options;
  if (requiresPregeneratedKeyframes(valueName, options)) {
    const sampleAnimation = animateValue({
      ...options,
      repeat: 0,
      delay: 0
    });
    let state = { done: false, value: keyframes2[0] };
    const pregeneratedKeyframes = [];
    let t2 = 0;
    while (!state.done && t2 < maxDuration) {
      state = sampleAnimation.sample(t2);
      pregeneratedKeyframes.push(state.value);
      t2 += sampleDelta;
    }
    times = void 0;
    keyframes2 = pregeneratedKeyframes;
    duration = t2 - sampleDelta;
    ease2 = "linear";
  }
  const animation = animateStyle(value.owner.current, valueName, keyframes2, {
    ...options,
    duration,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: ease2,
    times
  });
  const cancelAnimation = () => animation.cancel();
  const safeCancel = () => {
    frame.update(cancelAnimation);
    resolveFinishedPromise();
    updateFinishedPromise();
  };
  animation.onfinish = () => {
    value.set(getFinalKeyframe(keyframes2, options));
    onComplete && onComplete();
    safeCancel();
  };
  return {
    then(resolve, reject) {
      return currentFinishedPromise.then(resolve, reject);
    },
    get time() {
      return millisecondsToSeconds(animation.currentTime || 0);
    },
    set time(newTime) {
      animation.currentTime = secondsToMilliseconds(newTime);
    },
    get speed() {
      return animation.playbackRate;
    },
    set speed(newSpeed) {
      animation.playbackRate = newSpeed;
    },
    get duration() {
      return millisecondsToSeconds(duration);
    },
    play: () => {
      if (hasStopped)
        return;
      animation.play();
      cancelFrame(cancelAnimation);
    },
    pause: () => animation.pause(),
    stop: () => {
      hasStopped = true;
      if (animation.playState === "idle")
        return;
      const { currentTime } = animation;
      if (currentTime) {
        const sampleAnimation = animateValue({
          ...options,
          autoplay: false
        });
        value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);
      }
      safeCancel();
    },
    complete: () => animation.finish(),
    cancel: safeCancel
  };
}
function createInstantAnimation({ keyframes: keyframes2, delay: delay2, onUpdate, onComplete }) {
  const setValue = () => {
    onUpdate && onUpdate(keyframes2[keyframes2.length - 1]);
    onComplete && onComplete();
    return {
      time: 0,
      speed: 1,
      duration: 0,
      play: noop$1,
      pause: noop$1,
      stop: noop$1,
      then: (resolve) => {
        resolve();
        return Promise.resolve();
      },
      cancel: noop$1,
      complete: noop$1
    };
  };
  return delay2 ? animateValue({
    keyframes: [0, 1],
    duration: 0,
    delay: delay2,
    onComplete: setValue
  }) : setValue();
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
const criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
const ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
  }
  return ease;
};
const isAnimatable = (key, value) => {
  if (key === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  (complex.test(value) || value === "0") && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  const [name, value] = v2.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
const functionRegex = /([a-z-]*)\(.*?\)/g;
const filter = {
  ...complex,
  getAnimatableNone: (v2) => {
    const functions = v2.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
  }
};
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
};
const getDefaultValueType = (key) => defaultValueTypes[key];
function getAnimatableNone(key, value) {
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const isZeroValueString = (v2) => /^0[^.\s]+$/.test(v2);
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  }
}
function getKeyframes(value, valueName, target, transition) {
  const isTargetAnimatable = isAnimatable(valueName, target);
  let keyframes2;
  if (Array.isArray(target)) {
    keyframes2 = [...target];
  } else {
    keyframes2 = [null, target];
  }
  const defaultOrigin = transition.from !== void 0 ? transition.from : value.get();
  let animatableTemplateValue = void 0;
  const noneKeyframeIndexes = [];
  for (let i2 = 0; i2 < keyframes2.length; i2++) {
    if (keyframes2[i2] === null) {
      keyframes2[i2] = i2 === 0 ? defaultOrigin : keyframes2[i2 - 1];
    }
    if (isNone(keyframes2[i2])) {
      noneKeyframeIndexes.push(i2);
    }
    if (typeof keyframes2[i2] === "string" && keyframes2[i2] !== "none" && keyframes2[i2] !== "0") {
      animatableTemplateValue = keyframes2[i2];
    }
  }
  if (isTargetAnimatable && noneKeyframeIndexes.length && animatableTemplateValue) {
    for (let i2 = 0; i2 < noneKeyframeIndexes.length; i2++) {
      const index = noneKeyframeIndexes[i2];
      keyframes2[index] = getAnimatableNone(valueName, animatableTemplateValue);
    }
  }
  return keyframes2;
}
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
function getValueTransition(transition, key) {
  return transition[key] || transition["default"] || transition;
}
const animateMotionValue = (valueName, value, target, transition = {}) => {
  return (onComplete) => {
    const valueTransition = getValueTransition(transition, valueName) || {};
    const delay2 = valueTransition.delay || transition.delay || 0;
    let { elapsed = 0 } = transition;
    elapsed = elapsed - secondsToMilliseconds(delay2);
    const keyframes2 = getKeyframes(value, valueName, target, valueTransition);
    const originKeyframe = keyframes2[0];
    const targetKeyframe = keyframes2[keyframes2.length - 1];
    const isOriginAnimatable = isAnimatable(valueName, originKeyframe);
    const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);
    let options = {
      keyframes: keyframes2,
      velocity: value.getVelocity(),
      ease: "easeOut",
      ...valueTransition,
      delay: -elapsed,
      onUpdate: (v2) => {
        value.set(v2);
        valueTransition.onUpdate && valueTransition.onUpdate(v2);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      }
    };
    if (!isTransitionDefined(valueTransition)) {
      options = {
        ...options,
        ...getDefaultTransition(valueName, options)
      };
    }
    if (options.duration) {
      options.duration = secondsToMilliseconds(options.duration);
    }
    if (options.repeatDelay) {
      options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
    }
    if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false) {
      return createInstantAnimation(options);
    }
    if (value.owner && value.owner.current instanceof HTMLElement && !value.owner.getProps().onUpdate) {
      const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);
      if (acceleratedAnimation)
        return acceleratedAnimation;
    }
    return animateValue(options);
  };
};
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
const isNumericalString = (v2) => /^\-?\d*\.?\d+$/.test(v2);
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
function removeItem(arr, item) {
  const index = arr.indexOf(item);
  if (index > -1)
    arr.splice(index, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a2, b2, c2) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a2, b2, c2);
    } else {
      for (let i2 = 0; i2 < numSubscriptions; i2++) {
        const handler = this.subscriptions[i2];
        handler && handler(a2, b2, c2);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init, options = {}) {
    this.version = "10.12.17";
    this.timeDelta = 0;
    this.lastUpdated = 0;
    this.canTrackVelocity = false;
    this.events = {};
    this.updateAndNotify = (v2, render = true) => {
      this.prev = this.current;
      this.current = v2;
      const { delta, timestamp } = frameData;
      if (this.lastUpdated !== timestamp) {
        this.timeDelta = delta;
        this.lastUpdated = timestamp;
        frame.postRender(this.scheduleVelocityCheck);
      }
      if (this.prev !== this.current && this.events.change) {
        this.events.change.notify(this.current);
      }
      if (this.events.velocityChange) {
        this.events.velocityChange.notify(this.getVelocity());
      }
      if (render && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current);
      }
    };
    this.scheduleVelocityCheck = () => frame.postRender(this.velocityCheck);
    this.velocityCheck = ({ timestamp }) => {
      if (timestamp !== this.lastUpdated) {
        this.prev = this.current;
        if (this.events.velocityChange) {
          this.events.velocityChange.notify(this.getVelocity());
        }
      }
    };
    this.hasAnimated = false;
    this.prev = this.current = init;
    this.canTrackVelocity = isFloat(this.current);
    this.owner = options.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v2, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v2, render);
    } else {
      this.passiveEffect(v2, this.updateAndNotify);
    }
  }
  setWithVelocity(prev, current, delta) {
    this.set(current);
    this.prev = prev;
    this.timeDelta = delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v2) {
    this.updateAndNotify(v2);
    this.prev = v2;
    this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init, options) {
  return new MotionValue(init, options);
}
const testValueType = (v2) => (type) => type.test(v2);
const auto = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
};
const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
const findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));
const valueTypes = [...dimensionValueTypes, color, complex];
const findValueType = (v2) => valueTypes.find(testValueType(v2));
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
function checkTargetForNewValues(visualElement, target, origin) {
  var _a, _b;
  const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));
  const numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (let i2 = 0; i2 < numNewValues; i2++) {
    const key = newValueKeys[i2];
    const targetValue = target[key];
    let value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone(key, targetValue);
    }
    visualElement.addValue(key, motionValue(value, { owner: visualElement }));
    if (origin[key] === void 0) {
      origin[key] = value;
    }
    if (value !== null)
      visualElement.setBaseTarget(key, value);
  }
}
function getOriginFromTransition(key, transition) {
  if (!transition)
    return;
  const valueTransition = transition[key] || transition["default"] || transition;
  return valueTransition.from;
}
function getOrigin(target, transition, visualElement) {
  const origin = {};
  for (const key in target) {
    const transitionOrigin = getOriginFromTransition(key, transition);
    if (transitionOrigin !== void 0) {
      origin[key] = transitionOrigin;
    } else {
      const value = visualElement.getValue(key);
      if (value) {
        origin[key] = value.get();
      }
    }
  }
  return origin;
}
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
function animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);
  const willChange = visualElement.getValue("willChange");
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key in target) {
    const value = visualElement.getValue(key);
    const valueTarget = target[key];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    const valueTransition = { delay: delay2, elapsed: 0, ...transition };
    if (window.HandoffAppearAnimations && !value.hasAnimated) {
      const appearId = visualElement.getProps()[optimizedAppearDataAttribute];
      if (appearId) {
        valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key, value, frame);
      }
    }
    value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? { type: false } : valueTransition));
    const animation = value.animation;
    if (isWillChangeMotionValue(willChange)) {
      willChange.add(key);
      animation.then(() => willChange.remove(key));
    }
    animations2.push(animation);
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      transitionEnd && setTarget(visualElement, transitionEnd);
    });
  }
  return animations2;
}
function animateVariant(visualElement, variant, options = {}) {
  const resolved = resolveVariant(visualElement, variant, options.custom);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i2)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => visualElement.notify("AnimationComplete", definition));
}
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate = animateList(visualElement);
  const state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (acc, definition) => {
    const resolved = resolveVariant(visualElement, definition);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  function animateChanges(options, changedActiveType) {
    const props = visualElement.getProps();
    const context = visualElement.getVariantContext(true) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i2 = 0; i2 < numAnimationTypes; i2++) {
      const type = reversePriorityOrder[i2];
      const typeState = state[type];
      const prop = props[type] !== void 0 ? props[type] : context[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i2;
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key) => {
        shouldAnimateType = true;
        removedKeys.delete(key);
        typeState.needsAnimating[key] = true;
      };
      for (const key in allKeys) {
        const next = resolvedValues[key];
        const prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        if (next !== prev) {
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            if (!shallowCompare(next, prev) || variantDidChange) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          } else if (next !== void 0) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push(...definitionList.map((animation) => ({
          animation,
          options: { type, ...options }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key);
        if (fallbackTarget !== void 0) {
          fallbackAnimation[key] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  function setActive(type, isActive, options) {
    var _a;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
      var _a2;
      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    const animations2 = animateChanges(options, type);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (Array.isArray(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node) {
    super(node);
    node.animationState || (node.animationState = createAnimationState(node));
  }
  updateAnimationControlsSubscription() {
    const { animate } = this.node.getProps();
    this.unmount();
    if (isAnimationControls(animate)) {
      this.unmount = animate.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments);
    this.id = id$1++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete, custom } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent, { custom: custom !== null && custom !== void 0 ? custom : this.node.getProps().custom });
    if (onExitComplete && !isPresent) {
      exitAnimation.then(() => onExitComplete(this.id));
    }
  }
  mount() {
    const { register } = this.node.presenceContext || {};
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};
const distance = (a2, b2) => Math.abs(a2 - b2);
function distance2D(a2, b2) {
  const xDelta = distance(a2.x, b2.x);
  const yDelta = distance(a2.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers, { transformPagePoint } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const { onEnd, onSessionEnd } = this.handlers;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i2 = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i2 >= 0) {
    timestampedPoint = history[i2];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i2--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target = 0, maxDistance = 0.01) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mix(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
    delta.scale = 1;
  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;
  if (isNear(delta.translate) || isNaN(delta.translate))
    delta.translate = 0;
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
function applyConstraints(point, { min, max }, elastic) {
  if (min !== void 0 && point < min) {
    point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);
  } else if (max !== void 0 && point > max) {
    point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min = constraintsAxis.min - layoutAxis.min;
  let max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min, max] = [max, min];
  }
  return { min, max };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i2 = 0; i2 < treeLength; i2++) {
    node = treePath[i2];
    delta = node.projectionDelta;
    const instance2 = node.instance;
    if (instance2 && instance2.style && instance2.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
  treeScale.x = snapToDefault(treeScale.x);
  treeScale.y = snapToDefault(treeScale.y);
}
function snapToDefault(scale2) {
  if (Number.isInteger(scale2))
    return scale2;
  return scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, transforms, [key, scaleKey, originKey]) {
  const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
  const originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
}
const xKeys$1 = ["x", "scaleX", "originX"];
const yKeys$1 = ["y", "scaleY", "originY"];
function transformBox(box, transform) {
  transformAxis(box.x, transform, xKeys$1);
  transformAxis(box.y, transform, yKeys$1);
}
function measureViewportBox(instance2, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance2.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll } = rootProjectionNode2;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.offset.x);
    translateAxis(viewportBox.y, scroll.offset.y);
  }
  return viewportBox;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false)
      return;
    const onSessionStart = (event) => {
      this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event, "page").point);
      }
    };
    const onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openGlobalLock)
          this.openGlobalLock();
        this.openGlobalLock = getGlobalLock(drag2);
        if (!this.openGlobalLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length = calcLength(measuredAxis);
              current = length * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame.update(() => onDragStart(event, info), false, true);
      }
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    };
    const onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset);
      this.updateAxis("y", info.point, offset);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd
    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
  }
  stop(event, info) {
    const isDragging = this.isDragging;
    this.cancel();
    if (!isDragging)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.update(() => onDragEnd(event, info));
    }
  }
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset) {
    const { drag: drag2 } = this.getProps();
    if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  }
  resolveConstraints() {
    const { dragConstraints, dragElastic } = this.getProps();
    const { layout: layout2 } = this.visualElement.projection || {};
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = "_drag" + axis.toUpperCase();
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min, max } = projection.layout.layoutBox[axis];
        axisValue.set(point[axis] - mix(min, max, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min, max } = this.constraints[axis];
      axisValue.set(mix(min, max, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints)) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    measureDragConstraints();
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
class DragGesture extends Feature {
  constructor(node) {
    super(node);
    this.removeGroupControls = noop$1;
    this.removeListeners = noop$1;
    this.controls = new VisualElementDragControls(node);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop$1;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
}
const asyncHandler = (handler) => (event, info) => {
  if (handler) {
    frame.update(() => handler(event, info));
  }
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop$1;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint() });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame.update(() => onPanEnd(event, info));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
}
function usePresence() {
  const context = reactExports.useContext(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent, onExitComplete, register } = context;
  const id2 = reactExports.useId();
  reactExports.useEffect(() => register(id2), []);
  const safeToRemove = () => onExitComplete && onExitComplete(id2);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x2 = pixelsToPercent(latest, node.target.x);
    const y2 = pixelsToPercent(latest, node.target.y);
    return `${x2}% ${y2}%`;
  }
};
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale;
    shadow[1 + offset] /= yScale;
    const averageScale = mix(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset] === "number")
      shadow[2 + offset] /= averageScale;
    if (typeof shadow[3 + offset] === "number")
      shadow[3 + offset] /= averageScale;
    return template(shadow);
  }
};
class MeasureLayoutWithContext extends React.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
    const projection = visualElement.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      queueMicrotask(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence();
  const layoutGroup = reactExports.useContext(LayoutGroupContext);
  return React.createElement(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mix(
      0,
      // TODO Reinstate this if only child
      lead.opacity !== void 0 ? lead.opacity : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mix(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mix(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
  }
  for (let i2 = 0; i2 < numBorders; i2++) {
    const borderLabel = `border${borders[i2]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
const easeCrossfadeIn = compress(0, 0.5, circOut);
const easeCrossfadeOut = compress(0.5, 0.95, noop$1);
function compress(min, max, easing) {
  return (p2) => {
    if (p2 < min)
      return 0;
    if (p2 > max)
      return 1;
    return easing(progress(min, max, p2));
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mix(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function boxEquals(a2, b2) {
  return a2.x.min === b2.x.min && a2.x.max === b2.x.max && a2.y.min === b2.y.min && a2.y.max === b2.y.max;
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i2 = indexOfNode; i2 >= 0; i2--) {
      const member = this.members[i2];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node.root && node.root.isUpdating) {
        node.isLayoutDirty = true;
      }
      const { crossfade } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      const { options, resumingFrom } = node;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  if (xTranslate || yTranslate) {
    transform = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { rotate, rotateX, rotateY } = latestTransform;
    if (rotate)
      transform += `rotate(${rotate}deg) `;
    if (rotateX)
      transform += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform += `rotateY(${rotateY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform || "none";
}
const compareByDepth = (a2, b2) => a2.depth - b2.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
function delay(callback, timeout) {
  const start = performance.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame.read(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}
function record(data) {
  if (window.MotionDebug) {
    window.MotionDebug.record(data);
  }
}
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
  return motionValue$1.animation;
}
const transformAxes = ["", "X", "Y", "Z"];
const animationTarget = 1e3;
let id = 0;
const projectionFrameData = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      this.id = id++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0;
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
        record(projectionFrameData);
      };
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        this.path[i2].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance2, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance2);
      this.instance = instance2;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance2);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (isLayoutDirty && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance2, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const targetChanged = !this.targetLayout || !boxEquals(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        node.shouldResetTransform = true;
        node.updateScroll("snapshot");
        if (node.options.layoutRoot) {
          node.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      }
      this.isUpdating = false;
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      const now = performance.now();
      frameData.delta = clamp(0, 1e3 / 60, now - frameData.timestamp);
      frameData.timestamp = now;
      frameData.isProcessing = true;
      steps.update.process(frameData);
      steps.preRender.process(frameData);
      steps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        queueMicrotask(() => this.update());
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      frame.preRender(this.updateProjection, false, true);
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node = this.path[i2];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot: checkIsScrollRoot(this.instance),
          offset: measureScroll(this.instance)
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const { scroll } = this.root;
      if (scroll) {
        translateAxis(box.x, scroll.offset.x);
        translateAxis(box.y, scroll.offset.y);
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        const { scroll, options } = node;
        if (node !== this.root && scroll && options.layoutScroll) {
          if (scroll.isRoot) {
            copyBoxInto(boxWithoutScroll, box);
            const { scroll: rootScroll } = this.root;
            if (rootScroll) {
              translateAxis(boxWithoutScroll.x, -rootScroll.offset.x);
              translateAxis(boxWithoutScroll.y, -rootScroll.offset.y);
            }
          }
          translateAxis(boxWithoutScroll.x, scroll.offset.x);
          translateAxis(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      projectionFrameData.resolvedTargetDeltas++;
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
      }
      const { target } = lead;
      if (!target) {
        if (this.projectionTransform) {
          this.projectionDelta = createDelta();
          this.projectionTransform = "none";
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta) {
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      const prevProjectionTransform = this.projectionTransform;
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
      projectionFrameData.recalculatedProjection++;
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      this.options.scheduleRender && this.options.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart");
      this.currentAnimation && this.currentAnimation.stop();
      if (this.resumingFrom && this.resumingFrom.currentAnimation) {
        this.resumingFrom.currentAnimation.stop();
      }
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          },
          onComplete: () => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      const config = node.options.initialPromotionConfig;
      node.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
    }
    getPrevLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasRotate = false;
      const { latestValues } = visualElement;
      if (latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ) {
        hasRotate = true;
      }
      if (!hasRotate)
        return;
      const resetValues = {};
      for (let i2 = 0; i2 < transformAxes.length; i2++) {
        const key = "rotate" + transformAxes[i2];
        if (latestValues[key]) {
          resetValues[key] = latestValues[key];
          visualElement.setStaticValue(key, 0);
        }
      }
      visualElement.render();
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp = {}) {
      var _a, _b;
      const styles = {};
      if (!this.instance || this.isSVG)
        return styles;
      if (!this.isVisible) {
        return { visibility: "hidden" };
      } else {
        styles.visibility = "";
      }
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles.opacity = "";
        styles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles.transform = transformTemplate(valuesToRender, styles.transform);
      }
      const { x: x2, y: y2 } = this.projectionDelta;
      styles.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
      if (lead.animationValues) {
        styles.opacity = lead === this ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key];
        const corrected = styles.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i2 = 0; i2 < num; i2++) {
            styles[applyTo[i2]] = corrected;
          }
        } else {
          styles[key] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none";
      }
      return styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node) => {
        var _a;
        return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a;
  const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
    const { animationType } = node.options;
    const isShared = snapshot.source !== node.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
        if (node.relativeTarget && !node.currentAnimation) {
          node.isProjectionDirty = true;
          node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEquals(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    const { onExitComplete } = node.options;
    onExitComplete && onExitComplete();
  }
  node.options.transition = void 0;
}
function propagateDirtyNodes(node) {
  projectionFrameData.totalNodes++;
  if (!node.parent)
    return;
  if (!node.isProjecting()) {
    node.isProjectionDirty = node.parent.isProjectionDirty;
  }
  node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
  node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
}
function cleanDirtyNodes(node) {
  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function clearIsLayoutDirty(node) {
  node.isLayoutDirty = false;
}
function resetTransformStyle(node) {
  const { visualElement } = node.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
  node.isProjectionDirty = true;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetRotation(node) {
  node.resetRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p2) {
  output.translate = mix(delta.translate, 0, p2);
  output.scale = mix(delta.scale, 1, p2);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to, p2) {
  output.min = mix(from.min, to.min, p2);
  output.max = mix(from.max, to.max, p2);
}
function mixBox(output, from, to, p2) {
  mixAxis(output.x, from.x, to.x, p2);
  mixAxis(output.y, from.y, to.y, p2);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function roundAxis(axis) {
  axis.min = Math.round(axis.min);
  axis.max = Math.round(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance2) => ({
    x: instance2.scrollLeft,
    y: instance2.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance2, value) => {
    instance2.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance2) => Boolean(window.getComputedStyle(instance2).position === "fixed")
});
const drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const splitCSSVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  const match = splitCSSVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token, fallback] = match;
  return [token, fallback];
}
function getVariableValue(current, element, depth = 1) {
  const [token, fallback] = parseCSSVariable(current);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariableToken(fallback)) {
    return getVariableValue(fallback, element, depth + 1);
  } else {
    return fallback;
  }
}
function resolveCSSVariables(visualElement, { ...target }, transitionEnd) {
  const element = visualElement.current;
  if (!(element instanceof Element))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = { ...transitionEnd };
  }
  visualElement.values.forEach((value) => {
    const current = value.get();
    if (!isCSSVariableToken(current))
      return;
    const resolved = getVariableValue(current, element);
    if (resolved)
      value.set(resolved);
  });
  for (const key in target) {
    const current = target[key];
    if (!isCSSVariableToken(current))
      continue;
    const resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key] = resolved;
    if (!transitionEnd)
      transitionEnd = {};
    if (transitionEnd[key] === void 0) {
      transitionEnd[key] = current;
    }
  }
  return { target, transitionEnd };
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]);
const isPositionalKey = (key) => positionalKeys.has(key);
const hasPositionalKey = (target) => {
  return Object.keys(target).some(isPositionalKey);
};
const isNumOrPxType = (v2) => v2 === number || v2 === px;
const getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
const getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {
  if (transform === "none" || !transform)
    return 0;
  const matrix3d = transform.match(/^matrix3d\((.+)\)$/);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3);
  } else {
    const matrix = transform.match(/^matrix\((.+)\)$/);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2);
    } else {
      return 0;
    }
  }
};
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement.render();
  return removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
const convertChangedValueTypes = (target, visualElement, changedKeys) => {
  const originBbox = visualElement.measureViewportBox();
  const element = visualElement.current;
  const elementComputedStyle = getComputedStyle(element);
  const { display } = elementComputedStyle;
  const origin = {};
  if (display === "none") {
    visualElement.setStaticValue("display", target.display || "block");
  }
  changedKeys.forEach((key) => {
    origin[key] = positionalValues[key](originBbox, elementComputedStyle);
  });
  visualElement.render();
  const targetBbox = visualElement.measureViewportBox();
  changedKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    value && value.jump(origin[key]);
    target[key] = positionalValues[key](targetBbox, elementComputedStyle);
  });
  return target;
};
const checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {
  target = { ...target };
  transitionEnd = { ...transitionEnd };
  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  let removedTransformValues = [];
  let hasAttemptedToRemoveTransformValues = false;
  const changedValueTypeKeys = [];
  targetPositionalKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (!visualElement.hasValue(key))
      return;
    let from = origin[key];
    let fromType = findDimensionValueType(from);
    const to = target[key];
    let toType;
    if (isKeyframesTarget(to)) {
      const numKeyframes = to.length;
      const fromIndex = to[0] === null ? 1 : 0;
      from = to[fromIndex];
      fromType = findDimensionValueType(from);
      for (let i2 = fromIndex; i2 < numKeyframes; i2++) {
        if (to[i2] === null)
          break;
        if (!toType) {
          toType = findDimensionValueType(to[i2]);
        } else {
          invariant(findDimensionValueType(to[i2]) === toType);
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        const current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target[key] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {
        if (from === 0) {
          value.set(toType.transform(from));
        } else {
          target[key] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key);
        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
        value.jump(to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    const scrollY = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(([key, value]) => {
        visualElement.getValue(key).set(value);
      });
    }
    visualElement.render();
    if (isBrowser && scrollY !== null) {
      window.scrollTo({ top: scrollY });
    }
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : { target, transitionEnd };
}
const parseDomVariant = (visualElement, target, origin, transitionEnd) => {
  const resolved = resolveCSSVariables(visualElement, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement, target, origin, transitionEnd);
};
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
function updateMotionValuesFromProps(element, next, prev) {
  const { willChange } = next;
  for (const key in next) {
    const nextValue = next[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
      if (isWillChangeMotionValue(willChange)) {
        willChange.add(key);
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue, { owner: element }));
      if (isWillChangeMotionValue(willChange)) {
        willChange.remove(key);
      }
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}
const visualElementStore = /* @__PURE__ */ new WeakMap();
const featureNames = Object.keys(featureDefinitions);
const numFeatures = featureNames.length;
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
const numVariantProps = variantProps.length;
class VisualElement {
  constructor({ parent, props, presenceContext, reducedMotionConfig, visualState }, options = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.scheduleRender = () => frame.render(this.render, false, true);
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {});
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
        if (isWillChangeMotionValue(willChange)) {
          willChange.add(key);
        }
      }
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps) {
    return {};
  }
  mount(instance2) {
    this.current = instance2;
    visualElementStore.set(instance2, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance2);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (this.parent)
      this.parent.children.add(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    visualElementStore.delete(this.current);
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    for (const key in this.features) {
      this.features[key].unmount();
    }
    this.current = null;
  }
  bindToMotionValue(key, value) {
    const valueIsTransform = transformProps.has(key);
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && frame.update(this.notifyUpdate, false, true);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      removeOnRenderRequest();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures2, initialLayoutGroupConfig) {
    let ProjectionNodeConstructor;
    let MeasureLayout2;
    for (let i2 = 0; i2 < numFeatures; i2++) {
      const name = featureNames[i2];
      const { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent } = featureDefinitions[name];
      if (ProjectionNode)
        ProjectionNodeConstructor = ProjectionNode;
      if (isEnabled(renderedProps)) {
        if (!this.features[name] && FeatureConstructor) {
          this.features[name] = new FeatureConstructor(this);
        }
        if (MeasureLayoutComponent) {
          MeasureLayout2 = MeasureLayoutComponent;
        }
      }
    }
    if (!this.projection && ProjectionNodeConstructor) {
      this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);
      const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = renderedProps;
      this.projection.setOptions({
        layoutId,
        layout: layout2,
        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof layout2 === "string" ? layout2 : "both",
        initialPromotionConfig: initialLayoutGroupConfig,
        layoutScroll,
        layoutRoot
      });
    }
    return MeasureLayout2;
  }
  updateFeatures() {
    for (const key in this.features) {
      const feature = this.features[key];
      if (feature.isMounted) {
        feature.update();
      } else {
        feature.mount();
        feature.isMounted = true;
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(target, canMutate = true) {
    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
      const key = propEventHandlers[i2];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listener = props["on" + key];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(startAtParent = false) {
    if (startAtParent) {
      return this.parent ? this.parent.getVariantContext() : void 0;
    }
    if (!this.isControllingVariants) {
      const context2 = this.parent ? this.parent.getVariantContext() || {} : {};
      if (this.props.initial !== void 0) {
        context2.initial = this.props.initial;
      }
      return context2;
    }
    const context = {};
    for (let i2 = 0; i2 < numVariantProps; i2++) {
      const name = variantProps[i2];
      const prop = this.props[name];
      if (isVariantLabel(prop) || prop === false) {
        context[name] = prop;
      }
    }
    return context;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    if (value !== this.values.get(key)) {
      this.removeValue(key);
      this.bindToMotionValue(key, value);
    }
    this.values.set(key, value);
    this.latestValues[key] = value.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key);
    }
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue, { owner: this });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key) {
    return this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.readValueFromInstance(this.current, key, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a;
    const { initial } = this.props;
    const valueFromInitial = typeof initial === "string" || typeof initial === "object" ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key] : void 0;
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
}
class DOMVisualElement extends VisualElement {
  sortInstanceNodePosition(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    return props.style ? props.style[key] : void 0;
  }
  removeValueFromRenderState(key, { vars, style }) {
    delete vars[key];
    delete style[key];
  }
  makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target }, { transformValues }, isMounted) {
    let origin = getOrigin(target, transition || {}, this);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(this, target, origin);
      const parsed = parseDomVariant(this, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return {
      transition,
      transitionEnd,
      ...target
    };
  }
}
function getComputedStyle$1(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  readValueFromInstance(instance2, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle$1(instance2);
      const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance2, { transformPagePoint }) {
    return measureViewportBox(instance2, transformPagePoint);
  }
  build(renderState, latestValues, options, props) {
    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps$1(props, prevProps);
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current)
          this.current.textContent = `${latest}`;
      });
    }
  }
  renderInstance(instance2, renderState, styleProp, projection) {
    renderHTML(instance2, renderState, styleProp, projection);
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.isSVGTag = false;
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance2, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return instance2.getAttribute(key);
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps(props, prevProps);
  }
  build(renderState, latestValues, options, props) {
    buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance2, renderState, styleProp, projection) {
    renderSVG(instance2, renderState, styleProp, projection);
  }
  mount(instance2) {
    this.isSVGTag = isSVGTag(instance2.tagName);
    super.mount(instance2);
  }
}
const createDomVisualElement = (Component, options) => {
  return isSVGComponent(Component) ? new SVGVisualElement(options, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options, { enableHardwareAcceleration: true });
};
const layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const preloadedFeatures = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
};
const motion = /* @__PURE__ */ createMotionProxy((Component, config) => createDomMotionConfig(Component, config, preloadedFeatures, createDomVisualElement));
function useIsMounted() {
  const isMounted = reactExports.useRef(false);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}
function useForceUpdate() {
  const isMounted = useIsMounted();
  const [forcedRenderCount, setForcedRenderCount] = reactExports.useState(0);
  const forceRender = reactExports.useCallback(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  const deferredForceRender = reactExports.useCallback(() => frame.postRender(forceRender), [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}
class PopChildMeasure extends reactExports.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size = this.props.sizeRef.current;
      size.height = element.offsetHeight || 0;
      size.width = element.offsetWidth || 0;
      size.top = element.offsetTop;
      size.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children, isPresent }) {
  const id2 = reactExports.useId();
  const ref = reactExports.useRef(null);
  const size = reactExports.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  reactExports.useInsertionEffect(() => {
    const { width, height, top, left } = size.current;
    if (isPresent || !ref.current || !width || !height)
      return;
    ref.current.dataset.motionPopId = id2;
    const style = document.createElement("style");
    document.head.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `);
    }
    return () => {
      document.head.removeChild(style);
    };
  }, [isPresent]);
  return reactExports.createElement(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size }, reactExports.cloneElement(children, { ref }));
}
const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id2 = reactExports.useId();
  const context = reactExports.useMemo(
    () => ({
      id: id2,
      initial,
      isPresent,
      custom,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete of presenceChildren.values()) {
          if (!isComplete)
            return;
        }
        onExitComplete && onExitComplete();
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? void 0 : [isPresent]
  );
  reactExports.useMemo(() => {
    presenceChildren.forEach((_2, key) => presenceChildren.set(key, false));
  }, [isPresent]);
  reactExports.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]);
  if (mode === "popLayout") {
    children = reactExports.createElement(PopChild, { isPresent }, children);
  }
  return reactExports.createElement(PresenceContext.Provider, { value: context }, children);
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
function useUnmountEffect(callback) {
  return reactExports.useEffect(() => () => callback(), []);
}
const getChildKey = (child) => child.key || "";
function updateChildLookup(children, allChildren) {
  children.forEach((child) => {
    const key = getChildKey(child);
    allChildren.set(key, child);
  });
}
function onlyElements(children) {
  const filtered = [];
  reactExports.Children.forEach(children, (child) => {
    if (reactExports.isValidElement(child))
      filtered.push(child);
  });
  return filtered;
}
const AnimatePresence = ({ children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = "sync" }) => {
  const forceRender = reactExports.useContext(LayoutGroupContext).forceRender || useForceUpdate()[0];
  const isMounted = useIsMounted();
  const filteredChildren = onlyElements(children);
  let childrenToRender = filteredChildren;
  const exitingChildren = reactExports.useRef(/* @__PURE__ */ new Map()).current;
  const presentChildren = reactExports.useRef(childrenToRender);
  const allChildren = reactExports.useRef(/* @__PURE__ */ new Map()).current;
  const isInitialRender = reactExports.useRef(true);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = false;
    updateChildLookup(filteredChildren, allChildren);
    presentChildren.current = childrenToRender;
  });
  useUnmountEffect(() => {
    isInitialRender.current = true;
    allChildren.clear();
    exitingChildren.clear();
  });
  if (isInitialRender.current) {
    return reactExports.createElement(reactExports.Fragment, null, childrenToRender.map((child) => reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout, mode }, child)));
  }
  childrenToRender = [...childrenToRender];
  const presentKeys = presentChildren.current.map(getChildKey);
  const targetKeys = filteredChildren.map(getChildKey);
  const numPresent = presentKeys.length;
  for (let i2 = 0; i2 < numPresent; i2++) {
    const key = presentKeys[i2];
    if (targetKeys.indexOf(key) === -1 && !exitingChildren.has(key)) {
      exitingChildren.set(key, void 0);
    }
  }
  if (mode === "wait" && exitingChildren.size) {
    childrenToRender = [];
  }
  exitingChildren.forEach((component, key) => {
    if (targetKeys.indexOf(key) !== -1)
      return;
    const child = allChildren.get(key);
    if (!child)
      return;
    const insertionIndex = presentKeys.indexOf(key);
    let exitingComponent = component;
    if (!exitingComponent) {
      const onExit = () => {
        allChildren.delete(key);
        exitingChildren.delete(key);
        const removeIndex = presentChildren.current.findIndex((presentChild) => presentChild.key === key);
        presentChildren.current.splice(removeIndex, 1);
        if (!exitingChildren.size) {
          presentChildren.current = filteredChildren;
          if (isMounted.current === false)
            return;
          forceRender();
          onExitComplete && onExitComplete();
        }
      };
      exitingComponent = reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom, presenceAffectsLayout, mode }, child);
      exitingChildren.set(key, exitingComponent);
    }
    childrenToRender.splice(insertionIndex, 0, exitingComponent);
  });
  childrenToRender = childrenToRender.map((child) => {
    const key = child.key;
    return exitingChildren.has(key) ? child : reactExports.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout, mode }, child);
  });
  return reactExports.createElement(reactExports.Fragment, null, exitingChildren.size ? childrenToRender : childrenToRender.map((child) => reactExports.cloneElement(child)));
};
let e = { data: "" }, t = (t2) => "object" == typeof window ? ((t2 ? t2.querySelector("#_goober") : window._goober) || Object.assign((t2 || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : t2 || e, l = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, a = /\/\*[^]*?\*\/|  +/g, n$1 = /\n+/g, o = (e2, t2) => {
  let r2 = "", l2 = "", a2 = "";
  for (let n2 in e2) {
    let c2 = e2[n2];
    "@" == n2[0] ? "i" == n2[1] ? r2 = n2 + " " + c2 + ";" : l2 += "f" == n2[1] ? o(c2, n2) : n2 + "{" + o(c2, "k" == n2[1] ? "" : t2) + "}" : "object" == typeof c2 ? l2 += o(c2, t2 ? t2.replace(/([^,])+/g, (e3) => n2.replace(/(^:.*)|([^,])+/g, (t3) => /&/.test(t3) ? t3.replace(/&/g, e3) : e3 ? e3 + " " + t3 : t3)) : n2) : null != c2 && (n2 = /^--/.test(n2) ? n2 : n2.replace(/[A-Z]/g, "-$&").toLowerCase(), a2 += o.p ? o.p(n2, c2) : n2 + ":" + c2 + ";");
  }
  return r2 + (t2 && a2 ? t2 + "{" + a2 + "}" : a2) + l2;
}, c = {}, s = (e2) => {
  if ("object" == typeof e2) {
    let t2 = "";
    for (let r2 in e2)
      t2 += r2 + s(e2[r2]);
    return t2;
  }
  return e2;
}, i = (e2, t2, r2, i2, p2) => {
  let u2 = s(e2), d2 = c[u2] || (c[u2] = ((e3) => {
    let t3 = 0, r3 = 11;
    for (; t3 < e3.length; )
      r3 = 101 * r3 + e3.charCodeAt(t3++) >>> 0;
    return "go" + r3;
  })(u2));
  if (!c[d2]) {
    let t3 = u2 !== e2 ? e2 : ((e3) => {
      let t4, r3, o2 = [{}];
      for (; t4 = l.exec(e3.replace(a, "")); )
        t4[4] ? o2.shift() : t4[3] ? (r3 = t4[3].replace(n$1, " ").trim(), o2.unshift(o2[0][r3] = o2[0][r3] || {})) : o2[0][t4[1]] = t4[2].replace(n$1, " ").trim();
      return o2[0];
    })(e2);
    c[d2] = o(p2 ? { ["@keyframes " + d2]: t3 } : t3, r2 ? "" : "." + d2);
  }
  let f2 = r2 && c.g ? c.g : null;
  return r2 && (c.g = c[d2]), ((e3, t3, r3, l2) => {
    l2 ? t3.data = t3.data.replace(l2, e3) : -1 === t3.data.indexOf(e3) && (t3.data = r3 ? e3 + t3.data : t3.data + e3);
  })(c[d2], t2, i2, f2), d2;
}, p = (e2, t2, r2) => e2.reduce((e3, l2, a2) => {
  let n2 = t2[a2];
  if (n2 && n2.call) {
    let e4 = n2(r2), t3 = e4 && e4.props && e4.props.className || /^go/.test(e4) && e4;
    n2 = t3 ? "." + t3 : e4 && "object" == typeof e4 ? e4.props ? "" : o(e4, "") : false === e4 ? "" : e4;
  }
  return e3 + l2 + (null == n2 ? "" : n2);
}, "");
function u$1(e2) {
  let r2 = this || {}, l2 = e2.call ? e2(r2.p) : e2;
  return i(l2.unshift ? l2.raw ? p(l2, [].slice.call(arguments, 1), r2.p) : l2.reduce((e3, t2) => Object.assign(e3, t2 && t2.call ? t2(r2.p) : t2), {}) : l2, t(r2.target), r2.g, r2.o, r2.k);
}
let d, f, g;
u$1.bind({ g: 1 });
let h$1 = u$1.bind({ k: 1 });
function m(e2, t2, r2, l2) {
  o.p = t2, d = e2, f = r2, g = l2;
}
function j(e2, t2) {
  let r2 = this || {};
  return function() {
    let l2 = arguments;
    function a2(n2, o2) {
      let c2 = Object.assign({}, n2), s2 = c2.className || a2.className;
      r2.p = Object.assign({ theme: f && f() }, c2), r2.o = / *go\d+/.test(s2), c2.className = u$1.apply(r2, l2) + (s2 ? " " + s2 : ""), t2 && (c2.ref = o2);
      let i2 = e2;
      return e2[0] && (i2 = c2.as || e2, delete c2.as), g && i2[0] && g(c2), d(i2, c2);
    }
    return t2 ? t2(a2) : a2;
  };
}
var W = (e2) => typeof e2 == "function", T = (e2, t2) => W(e2) ? e2(t2) : e2;
var U = (() => {
  let e2 = 0;
  return () => (++e2).toString();
})(), b = (() => {
  let e2;
  return () => {
    if (e2 === void 0 && typeof window < "u") {
      let t2 = matchMedia("(prefers-reduced-motion: reduce)");
      e2 = !t2 || t2.matches;
    }
    return e2;
  };
})();
var Q = 20;
var S = /* @__PURE__ */ new Map(), X = 1e3, $ = (e2) => {
  if (S.has(e2))
    return;
  let t2 = setTimeout(() => {
    S.delete(e2), u({ type: 4, toastId: e2 });
  }, X);
  S.set(e2, t2);
}, J = (e2) => {
  let t2 = S.get(e2);
  t2 && clearTimeout(t2);
}, v = (e2, t2) => {
  switch (t2.type) {
    case 0:
      return { ...e2, toasts: [t2.toast, ...e2.toasts].slice(0, Q) };
    case 1:
      return t2.toast.id && J(t2.toast.id), { ...e2, toasts: e2.toasts.map((r2) => r2.id === t2.toast.id ? { ...r2, ...t2.toast } : r2) };
    case 2:
      let { toast: o2 } = t2;
      return e2.toasts.find((r2) => r2.id === o2.id) ? v(e2, { type: 1, toast: o2 }) : v(e2, { type: 0, toast: o2 });
    case 3:
      let { toastId: s2 } = t2;
      return s2 ? $(s2) : e2.toasts.forEach((r2) => {
        $(r2.id);
      }), { ...e2, toasts: e2.toasts.map((r2) => r2.id === s2 || s2 === void 0 ? { ...r2, visible: false } : r2) };
    case 4:
      return t2.toastId === void 0 ? { ...e2, toasts: [] } : { ...e2, toasts: e2.toasts.filter((r2) => r2.id !== t2.toastId) };
    case 5:
      return { ...e2, pausedAt: t2.time };
    case 6:
      let a2 = t2.time - (e2.pausedAt || 0);
      return { ...e2, pausedAt: void 0, toasts: e2.toasts.map((r2) => ({ ...r2, pauseDuration: r2.pauseDuration + a2 })) };
  }
}, A = [], P = { toasts: [], pausedAt: void 0 }, u = (e2) => {
  P = v(P, e2), A.forEach((t2) => {
    t2(P);
  });
}, Y = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, I = (e2 = {}) => {
  let [t2, o2] = reactExports.useState(P);
  reactExports.useEffect(() => (A.push(o2), () => {
    let a2 = A.indexOf(o2);
    a2 > -1 && A.splice(a2, 1);
  }), [t2]);
  let s2 = t2.toasts.map((a2) => {
    var r2, c2;
    return { ...e2, ...e2[a2.type], ...a2, duration: a2.duration || ((r2 = e2[a2.type]) == null ? void 0 : r2.duration) || (e2 == null ? void 0 : e2.duration) || Y[a2.type], style: { ...e2.style, ...(c2 = e2[a2.type]) == null ? void 0 : c2.style, ...a2.style } };
  });
  return { ...t2, toasts: s2 };
};
var G = (e2, t2 = "blank", o2) => ({ createdAt: Date.now(), visible: true, type: t2, ariaProps: { role: "status", "aria-live": "polite" }, message: e2, pauseDuration: 0, ...o2, id: (o2 == null ? void 0 : o2.id) || U() }), h = (e2) => (t2, o2) => {
  let s2 = G(t2, e2, o2);
  return u({ type: 2, toast: s2 }), s2.id;
}, n = (e2, t2) => h("blank")(e2, t2);
n.error = h("error");
n.success = h("success");
n.loading = h("loading");
n.custom = h("custom");
n.dismiss = (e2) => {
  u({ type: 3, toastId: e2 });
};
n.remove = (e2) => u({ type: 4, toastId: e2 });
n.promise = (e2, t2, o2) => {
  let s2 = n.loading(t2.loading, { ...o2, ...o2 == null ? void 0 : o2.loading });
  return e2.then((a2) => (n.success(T(t2.success, a2), { id: s2, ...o2, ...o2 == null ? void 0 : o2.success }), a2)).catch((a2) => {
    n.error(T(t2.error, a2), { id: s2, ...o2, ...o2 == null ? void 0 : o2.error });
  }), e2;
};
var Z = (e2, t2) => {
  u({ type: 1, toast: { id: e2, height: t2 } });
}, ee = () => {
  u({ type: 5, time: Date.now() });
}, D = (e2) => {
  let { toasts: t2, pausedAt: o2 } = I(e2);
  reactExports.useEffect(() => {
    if (o2)
      return;
    let r2 = Date.now(), c2 = t2.map((i2) => {
      if (i2.duration === 1 / 0)
        return;
      let d2 = (i2.duration || 0) + i2.pauseDuration - (r2 - i2.createdAt);
      if (d2 < 0) {
        i2.visible && n.dismiss(i2.id);
        return;
      }
      return setTimeout(() => n.dismiss(i2.id), d2);
    });
    return () => {
      c2.forEach((i2) => i2 && clearTimeout(i2));
    };
  }, [t2, o2]);
  let s2 = reactExports.useCallback(() => {
    o2 && u({ type: 6, time: Date.now() });
  }, [o2]), a2 = reactExports.useCallback((r2, c2) => {
    let { reverseOrder: i2 = false, gutter: d2 = 8, defaultPosition: p2 } = c2 || {}, g2 = t2.filter((m2) => (m2.position || p2) === (r2.position || p2) && m2.height), E2 = g2.findIndex((m2) => m2.id === r2.id), x2 = g2.filter((m2, R2) => R2 < E2 && m2.visible).length;
    return g2.filter((m2) => m2.visible).slice(...i2 ? [x2 + 1] : [0, x2]).reduce((m2, R2) => m2 + (R2.height || 0) + d2, 0);
  }, [t2]);
  return { toasts: t2, handlers: { updateHeight: Z, startPause: ee, endPause: s2, calculateOffset: a2 } };
};
var oe = h$1`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, re = h$1`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, se = h$1`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, _$1 = j("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e2) => e2.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${oe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${re} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e2) => e2.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${se} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`;
var ne = h$1`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, V = j("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e2) => e2.secondary || "#e0e0e0"};
  border-right-color: ${(e2) => e2.primary || "#616161"};
  animation: ${ne} 1s linear infinite;
`;
var pe = h$1`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, de = h$1`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, w = j("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e2) => e2.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${pe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${de} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e2) => e2.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`;
var ue = j("div")`
  position: absolute;
`, le = j("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Te = h$1`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, fe = j("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Te} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, M = ({ toast: e2 }) => {
  let { icon: t2, type: o2, iconTheme: s2 } = e2;
  return t2 !== void 0 ? typeof t2 == "string" ? reactExports.createElement(fe, null, t2) : t2 : o2 === "blank" ? null : reactExports.createElement(le, null, reactExports.createElement(V, { ...s2 }), o2 !== "loading" && reactExports.createElement(ue, null, o2 === "error" ? reactExports.createElement(_$1, { ...s2 }) : reactExports.createElement(w, { ...s2 })));
};
var ye = (e2) => `
0% {transform: translate3d(0,${e2 * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, ge = (e2) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e2 * -150}%,-1px) scale(.6); opacity:0;}
`, he = "0%{opacity:0;} 100%{opacity:1;}", xe = "0%{opacity:1;} 100%{opacity:0;}", be = j("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Se = j("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Ae = (e2, t2) => {
  let s2 = e2.includes("top") ? 1 : -1, [a2, r2] = b() ? [he, xe] : [ye(s2), ge(s2)];
  return { animation: t2 ? `${h$1(a2)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${h$1(r2)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, F = reactExports.memo(({ toast: e2, position: t2, style: o2, children: s2 }) => {
  let a2 = e2.height ? Ae(e2.position || t2 || "top-center", e2.visible) : { opacity: 0 }, r2 = reactExports.createElement(M, { toast: e2 }), c2 = reactExports.createElement(Se, { ...e2.ariaProps }, T(e2.message, e2));
  return reactExports.createElement(be, { className: e2.className, style: { ...a2, ...o2, ...e2.style } }, typeof s2 == "function" ? s2({ icon: r2, message: c2 }) : reactExports.createElement(reactExports.Fragment, null, r2, c2));
});
m(reactExports.createElement);
var Ee = ({ id: e2, className: t2, style: o2, onHeightUpdate: s2, children: a2 }) => {
  let r2 = reactExports.useCallback((c2) => {
    if (c2) {
      let i2 = () => {
        let d2 = c2.getBoundingClientRect().height;
        s2(e2, d2);
      };
      i2(), new MutationObserver(i2).observe(c2, { subtree: true, childList: true, characterData: true });
    }
  }, [e2, s2]);
  return reactExports.createElement("div", { ref: r2, className: t2, style: o2 }, a2);
}, Re = (e2, t2) => {
  let o2 = e2.includes("top"), s2 = o2 ? { top: 0 } : { bottom: 0 }, a2 = e2.includes("center") ? { justifyContent: "center" } : e2.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: b() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t2 * (o2 ? 1 : -1)}px)`, ...s2, ...a2 };
}, ve = u$1`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, O = 16, Ie = ({ reverseOrder: e2, position: t2 = "top-center", toastOptions: o2, gutter: s2, children: a2, containerStyle: r2, containerClassName: c2 }) => {
  let { toasts: i2, handlers: d2 } = D(o2);
  return reactExports.createElement("div", { style: { position: "fixed", zIndex: 9999, top: O, left: O, right: O, bottom: O, pointerEvents: "none", ...r2 }, className: c2, onMouseEnter: d2.startPause, onMouseLeave: d2.endPause }, i2.map((p2) => {
    let g2 = p2.position || t2, E2 = d2.calculateOffset(p2, { reverseOrder: e2, gutter: s2, defaultPosition: t2 }), x2 = Re(g2, E2);
    return reactExports.createElement(Ee, { id: p2.id, key: p2.id, onHeightUpdate: d2.updateHeight, className: p2.visible ? ve : "", style: x2 }, p2.type === "custom" ? T(p2.message, p2) : a2 ? a2(p2) : reactExports.createElement(F, { toast: p2, position: g2 }));
  }));
};
var _t = n;
function warn() {
  if (console && console.warn) {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === "string")
      args[0] = `react-i18next:: ${args[0]}`;
    console.warn(...args);
  }
}
const alreadyWarned = {};
function warnOnce() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (typeof args[0] === "string" && alreadyWarned[args[0]])
    return;
  if (typeof args[0] === "string")
    alreadyWarned[args[0]] = /* @__PURE__ */ new Date();
  warn(...args);
}
const loadedClb = (i18n, cb2) => () => {
  if (i18n.isInitialized) {
    cb2();
  } else {
    const initialized = () => {
      setTimeout(() => {
        i18n.off("initialized", initialized);
      }, 0);
      cb2();
    };
    i18n.on("initialized", initialized);
  }
};
function loadNamespaces(i18n, ns, cb2) {
  i18n.loadNamespaces(ns, loadedClb(i18n, cb2));
}
function loadLanguages(i18n, lng, ns, cb2) {
  if (typeof ns === "string")
    ns = [ns];
  ns.forEach((n2) => {
    if (i18n.options.ns.indexOf(n2) < 0)
      i18n.options.ns.push(n2);
  });
  i18n.loadLanguages(lng, loadedClb(i18n, cb2));
}
function oldI18nextHasLoadedNamespace(ns, i18n) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const lng = i18n.languages[0];
  const fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
  const lastLng = i18n.languages[i18n.languages.length - 1];
  if (lng.toLowerCase() === "cimode")
    return true;
  const loadNotPending = (l2, n2) => {
    const loadState = i18n.services.backendConnector.state[`${l2}|${n2}`];
    return loadState === -1 || loadState === 2;
  };
  if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns))
    return false;
  if (i18n.hasResourceBundle(lng, ns))
    return true;
  if (!i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages)
    return true;
  if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
    return true;
  return false;
}
function hasLoadedNamespace(ns, i18n) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce("i18n.languages were undefined or empty", i18n.languages);
    return true;
  }
  const isNewerI18next = i18n.options.ignoreJSONStructure !== void 0;
  if (!isNewerI18next) {
    return oldI18nextHasLoadedNamespace(ns, i18n, options);
  }
  return i18n.hasLoadedNamespace(ns, {
    lng: options.lng,
    precheck: (i18nInstance2, loadNotPending) => {
      if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns))
        return false;
    }
  });
}
const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
const htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "",
  "&#169;": "",
  "&reg;": "",
  "&#174;": "",
  "&hellip;": "",
  "&#8230;": "",
  "&#x2F;": "/",
  "&#47;": "/"
};
const unescapeHtmlEntity = (m2) => htmlEntities[m2];
const unescape$1 = (text) => text.replace(matchHtmlEntity, unescapeHtmlEntity);
let defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape: unescape$1
};
function setDefaults() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  defaultOptions = {
    ...defaultOptions,
    ...options
  };
}
function getDefaults() {
  return defaultOptions;
}
let i18nInstance;
function setI18n(instance2) {
  i18nInstance = instance2;
}
function getI18n() {
  return i18nInstance;
}
const initReactI18next = {
  type: "3rdParty",
  init(instance2) {
    setDefaults(instance2.options.react);
    setI18n(instance2);
  }
};
const I18nContext = reactExports.createContext();
class ReportNamespaces {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(namespaces) {
    namespaces.forEach((ns) => {
      if (!this.usedNamespaces[ns])
        this.usedNamespaces[ns] = true;
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
}
const usePrevious = (value, ignore) => {
  const ref = reactExports.useRef();
  reactExports.useEffect(() => {
    ref.current = ignore ? ref.current : value;
  }, [value, ignore]);
  return ref.current;
};
function useTranslation(ns) {
  let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    i18n: i18nFromProps
  } = props;
  const {
    i18n: i18nFromContext,
    defaultNS: defaultNSFromContext
  } = reactExports.useContext(I18nContext) || {};
  const i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces)
    i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    const notReadyT = (k2, optsOrDefaultValue) => {
      if (typeof optsOrDefaultValue === "string")
        return optsOrDefaultValue;
      if (optsOrDefaultValue && typeof optsOrDefaultValue === "object" && typeof optsOrDefaultValue.defaultValue === "string")
        return optsOrDefaultValue.defaultValue;
      return Array.isArray(k2) ? k2[k2.length - 1] : k2;
    };
    const retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }
  if (i18n.options.react && i18n.options.react.wait !== void 0)
    warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const i18nOptions = {
    ...getDefaults(),
    ...i18n.options.react,
    ...props
  };
  const {
    useSuspense,
    keyPrefix
  } = i18nOptions;
  let namespaces = ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
  if (i18n.reportNamespaces.addUsedNamespaces)
    i18n.reportNamespaces.addUsedNamespaces(namespaces);
  const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n2) => hasLoadedNamespace(n2, i18n, i18nOptions));
  function getT() {
    return i18n.getFixedT(props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  }
  const [t2, setT] = reactExports.useState(getT);
  let joinedNS = namespaces.join();
  if (props.lng)
    joinedNS = `${props.lng}${joinedNS}`;
  const previousJoinedNS = usePrevious(joinedNS);
  const isMounted = reactExports.useRef(true);
  reactExports.useEffect(() => {
    const {
      bindI18n,
      bindI18nStore
    } = i18nOptions;
    isMounted.current = true;
    if (!ready && !useSuspense) {
      if (props.lng) {
        loadLanguages(i18n, props.lng, namespaces, () => {
          if (isMounted.current)
            setT(getT);
        });
      } else {
        loadNamespaces(i18n, namespaces, () => {
          if (isMounted.current)
            setT(getT);
        });
      }
    }
    if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
      setT(getT);
    }
    function boundReset() {
      if (isMounted.current)
        setT(getT);
    }
    if (bindI18n && i18n)
      i18n.on(bindI18n, boundReset);
    if (bindI18nStore && i18n)
      i18n.store.on(bindI18nStore, boundReset);
    return () => {
      isMounted.current = false;
      if (bindI18n && i18n)
        bindI18n.split(" ").forEach((e2) => i18n.off(e2, boundReset));
      if (bindI18nStore && i18n)
        bindI18nStore.split(" ").forEach((e2) => i18n.store.off(e2, boundReset));
    };
  }, [i18n, joinedNS]);
  const isInitial = reactExports.useRef(true);
  reactExports.useEffect(() => {
    if (isMounted.current && !isInitial.current) {
      setT(getT);
    }
    isInitial.current = false;
  }, [i18n, keyPrefix]);
  const ret = [t2, i18n, ready];
  ret.t = t2;
  ret.i18n = i18n;
  ret.ready = ready;
  if (ready)
    return ret;
  if (!ready && !useSuspense)
    return ret;
  throw new Promise((resolve) => {
    if (props.lng) {
      loadLanguages(i18n, props.lng, namespaces, () => resolve());
    } else {
      loadNamespaces(i18n, namespaces, () => resolve());
    }
  });
}
let listenerQueue = [];
let atom = (initialValue, level) => {
  let listeners = [];
  let store = {
    get() {
      if (!store.lc) {
        store.listen(() => {
        })();
      }
      return store.value;
    },
    l: level || 0,
    lc: 0,
    listen(listener, listenerLevel) {
      store.lc = listeners.push(listener, listenerLevel || store.l) / 2;
      return () => {
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 2);
          store.lc--;
          if (!store.lc)
            store.off();
        }
      };
    },
    notify(changedKey) {
      let runListenerQueue = !listenerQueue.length;
      for (let i2 = 0; i2 < listeners.length; i2 += 2) {
        listenerQueue.push(
          listeners[i2],
          store.value,
          changedKey,
          listeners[i2 + 1]
        );
      }
      if (runListenerQueue) {
        for (let i2 = 0; i2 < listenerQueue.length; i2 += 4) {
          let skip = false;
          for (let j2 = i2 + 7; j2 < listenerQueue.length; j2 += 4) {
            if (listenerQueue[j2] < listenerQueue[i2 + 3]) {
              skip = true;
              break;
            }
          }
          if (skip) {
            listenerQueue.push(
              listenerQueue[i2],
              listenerQueue[i2 + 1],
              listenerQueue[i2 + 2],
              listenerQueue[i2 + 3]
            );
          } else {
            listenerQueue[i2](listenerQueue[i2 + 1], listenerQueue[i2 + 2]);
          }
        }
        listenerQueue.length = 0;
      }
    },
    off() {
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    set(data) {
      if (store.value !== data) {
        store.value = data;
        store.notify();
      }
    },
    subscribe(cb2, listenerLevel) {
      let unbind = store.listen(cb2, listenerLevel);
      cb2(store.value);
      return unbind;
    },
    value: initialValue
  };
  return store;
};
function listenKeys(store, keys, listener) {
  let keysSet = /* @__PURE__ */ new Set([...keys, void 0]);
  return store.listen((value, changed) => {
    if (keysSet.has(changed)) {
      listener(value, changed);
    }
  });
}
function useStore(store, opts = {}) {
  let subscribe = reactExports.useCallback(
    (onChange) => opts.keys ? listenKeys(store, opts.keys, onChange) : store.listen(onChange),
    [opts.keys, store]
  );
  let get2 = store.get.bind(store);
  return reactExports.useSyncExternalStore(subscribe, get2, get2);
}
/*!
 * excalibur - 0.28.0 - 2023-8-10
 * https://github.com/excaliburjs/Excalibur
 * Copyright (c) 2023 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>
 * Licensed BSD-2-Clause
 * @preserve
 */
var __webpack_modules__ = {
  /***/
  4662: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      __webpack_require__2(3430);
      var entryUnbind = __webpack_require__2(8791);
      module.exports = entryUnbind("Array", "sort");
    }
  ),
  /***/
  8343: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      __webpack_require__2(4769);
      var path = __webpack_require__2(9276);
      module.exports = path.Object.keys;
    }
  ),
  /***/
  7111: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var isCallable = __webpack_require__2(6733);
      var tryToString = __webpack_require__2(9821);
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (isCallable(argument))
          return argument;
        throw $TypeError(tryToString(argument) + " is not a function");
      };
    }
  ),
  /***/
  1176: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var isObject = __webpack_require__2(5052);
      var $String = String;
      var $TypeError = TypeError;
      module.exports = function(argument) {
        if (isObject(argument))
          return argument;
        throw $TypeError($String(argument) + " is not an object");
      };
    }
  ),
  /***/
  9540: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var toIndexedObject = __webpack_require__2(905);
      var toAbsoluteIndex = __webpack_require__2(3231);
      var lengthOfArrayLike = __webpack_require__2(9646);
      var createMethod = function(IS_INCLUDES) {
        return function($this, el2, fromIndex) {
          var O2 = toIndexedObject($this);
          var length = lengthOfArrayLike(O2);
          var index = toAbsoluteIndex(fromIndex, length);
          var value;
          if (IS_INCLUDES && el2 != el2)
            while (length > index) {
              value = O2[index++];
              if (value != value)
                return true;
            }
          else
            for (; length > index; index++) {
              if ((IS_INCLUDES || index in O2) && O2[index] === el2)
                return IS_INCLUDES || index || 0;
            }
          return !IS_INCLUDES && -1;
        };
      };
      module.exports = {
        // `Array.prototype.includes` method
        // https://tc39.es/ecma262/#sec-array.prototype.includes
        includes: createMethod(true),
        // `Array.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-array.prototype.indexof
        indexOf: createMethod(false)
      };
    }
  ),
  /***/
  6038: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var fails = __webpack_require__2(4229);
      module.exports = function(METHOD_NAME, argument) {
        var method = [][METHOD_NAME];
        return !!method && fails(function() {
          method.call(null, argument || function() {
            return 1;
          }, 1);
        });
      };
    }
  ),
  /***/
  9794: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var toAbsoluteIndex = __webpack_require__2(3231);
      var lengthOfArrayLike = __webpack_require__2(9646);
      var createProperty = __webpack_require__2(2324);
      var $Array = Array;
      var max = Math.max;
      module.exports = function(O2, start, end) {
        var length = lengthOfArrayLike(O2);
        var k2 = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
        var result = $Array(max(fin - k2, 0));
        for (var n2 = 0; k2 < fin; k2++, n2++)
          createProperty(result, n2, O2[k2]);
        result.length = n2;
        return result;
      };
    }
  ),
  /***/
  3867: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var arraySlice = __webpack_require__2(9794);
      var floor = Math.floor;
      var mergeSort = function(array, comparefn) {
        var length = array.length;
        var middle = floor(length / 2);
        return length < 8 ? insertionSort(array, comparefn) : merge(
          array,
          mergeSort(arraySlice(array, 0, middle), comparefn),
          mergeSort(arraySlice(array, middle), comparefn),
          comparefn
        );
      };
      var insertionSort = function(array, comparefn) {
        var length = array.length;
        var i2 = 1;
        var element, j2;
        while (i2 < length) {
          j2 = i2;
          element = array[i2];
          while (j2 && comparefn(array[j2 - 1], element) > 0) {
            array[j2] = array[--j2];
          }
          if (j2 !== i2++)
            array[j2] = element;
        }
        return array;
      };
      var merge = function(array, left, right, comparefn) {
        var llength = left.length;
        var rlength = right.length;
        var lindex = 0;
        var rindex = 0;
        while (lindex < llength || rindex < rlength) {
          array[lindex + rindex] = lindex < llength && rindex < rlength ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++] : lindex < llength ? left[lindex++] : right[rindex++];
        }
        return array;
      };
      module.exports = mergeSort;
    }
  ),
  /***/
  7079: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var uncurryThis = __webpack_require__2(5968);
      var toString = uncurryThis({}.toString);
      var stringSlice = uncurryThis("".slice);
      module.exports = function(it) {
        return stringSlice(toString(it), 8, -1);
      };
    }
  ),
  /***/
  1589: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var TO_STRING_TAG_SUPPORT = __webpack_require__2(1601);
      var isCallable = __webpack_require__2(6733);
      var classofRaw = __webpack_require__2(7079);
      var wellKnownSymbol = __webpack_require__2(95);
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var $Object = Object;
      var CORRECT_ARGUMENTS = classofRaw(function() {
        return arguments;
      }()) == "Arguments";
      var tryGet = function(it, key) {
        try {
          return it[key];
        } catch (error) {
        }
      };
      module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
        var O2, tag, result;
        return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O2 = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O2) : (result = classofRaw(O2)) == "Object" && isCallable(O2.callee) ? "Arguments" : result;
      };
    }
  ),
  /***/
  7081: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var hasOwn = __webpack_require__2(8270);
      var ownKeys = __webpack_require__2(4826);
      var getOwnPropertyDescriptorModule = __webpack_require__2(7933);
      var definePropertyModule = __webpack_require__2(1787);
      module.exports = function(target, source, exceptions) {
        var keys = ownKeys(source);
        var defineProperty = definePropertyModule.f;
        var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        for (var i2 = 0; i2 < keys.length; i2++) {
          var key = keys[i2];
          if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
            defineProperty(target, key, getOwnPropertyDescriptor(source, key));
          }
        }
      };
    }
  ),
  /***/
  5762: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var DESCRIPTORS = __webpack_require__2(7400);
      var definePropertyModule = __webpack_require__2(1787);
      var createPropertyDescriptor = __webpack_require__2(5358);
      module.exports = DESCRIPTORS ? function(object, key, value) {
        return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
      } : function(object, key, value) {
        object[key] = value;
        return object;
      };
    }
  ),
  /***/
  5358: (
    /***/
    (module) => {
      module.exports = function(bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value
        };
      };
    }
  ),
  /***/
  2324: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var toPropertyKey = __webpack_require__2(9310);
      var definePropertyModule = __webpack_require__2(1787);
      var createPropertyDescriptor = __webpack_require__2(5358);
      module.exports = function(object, key, value) {
        var propertyKey = toPropertyKey(key);
        if (propertyKey in object)
          definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
        else
          object[propertyKey] = value;
      };
    }
  ),
  /***/
  4768: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var isCallable = __webpack_require__2(6733);
      var definePropertyModule = __webpack_require__2(1787);
      var makeBuiltIn = __webpack_require__2(6039);
      var defineGlobalProperty = __webpack_require__2(8400);
      module.exports = function(O2, key, value, options) {
        if (!options)
          options = {};
        var simple = options.enumerable;
        var name = options.name !== void 0 ? options.name : key;
        if (isCallable(value))
          makeBuiltIn(value, name, options);
        if (options.global) {
          if (simple)
            O2[key] = value;
          else
            defineGlobalProperty(key, value);
        } else {
          try {
            if (!options.unsafe)
              delete O2[key];
            else if (O2[key])
              simple = true;
          } catch (error) {
          }
          if (simple)
            O2[key] = value;
          else
            definePropertyModule.f(O2, key, {
              value,
              enumerable: false,
              configurable: !options.nonConfigurable,
              writable: !options.nonWritable
            });
        }
        return O2;
      };
    }
  ),
  /***/
  8400: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var global = __webpack_require__2(9859);
      var defineProperty = Object.defineProperty;
      module.exports = function(key, value) {
        try {
          defineProperty(global, key, { value, configurable: true, writable: true });
        } catch (error) {
          global[key] = value;
        }
        return value;
      };
    }
  ),
  /***/
  9563: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var tryToString = __webpack_require__2(9821);
      var $TypeError = TypeError;
      module.exports = function(O2, P2) {
        if (!delete O2[P2])
          throw $TypeError("Cannot delete property " + tryToString(P2) + " of " + tryToString(O2));
      };
    }
  ),
  /***/
  7400: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var fails = __webpack_require__2(4229);
      module.exports = !fails(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] != 7;
      });
    }
  ),
  /***/
  3777: (
    /***/
    (module) => {
      var documentAll = typeof document == "object" && document.all;
      var IS_HTMLDDA = typeof documentAll == "undefined" && documentAll !== void 0;
      module.exports = {
        all: documentAll,
        IS_HTMLDDA
      };
    }
  ),
  /***/
  2635: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var global = __webpack_require__2(9859);
      var isObject = __webpack_require__2(5052);
      var document2 = global.document;
      var EXISTS = isObject(document2) && isObject(document2.createElement);
      module.exports = function(it) {
        return EXISTS ? document2.createElement(it) : {};
      };
    }
  ),
  /***/
  2671: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var userAgent = __webpack_require__2(598);
      var firefox = userAgent.match(/firefox\/(\d+)/i);
      module.exports = !!firefox && +firefox[1];
    }
  ),
  /***/
  8506: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var UA = __webpack_require__2(598);
      module.exports = /MSIE|Trident/.test(UA);
    }
  ),
  /***/
  598: (
    /***/
    (module) => {
      module.exports = typeof navigator != "undefined" && String(navigator.userAgent) || "";
    }
  ),
  /***/
  5884: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var global = __webpack_require__2(9859);
      var userAgent = __webpack_require__2(598);
      var process = global.process;
      var Deno = global.Deno;
      var versions = process && process.versions || Deno && Deno.version;
      var v8 = versions && versions.v8;
      var match, version;
      if (v8) {
        match = v8.split(".");
        version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
      }
      if (!version && userAgent) {
        match = userAgent.match(/Edge\/(\d+)/);
        if (!match || match[1] >= 74) {
          match = userAgent.match(/Chrome\/(\d+)/);
          if (match)
            version = +match[1];
        }
      }
      module.exports = version;
    }
  ),
  /***/
  9811: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var userAgent = __webpack_require__2(598);
      var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);
      module.exports = !!webkit && +webkit[1];
    }
  ),
  /***/
  8791: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var global = __webpack_require__2(9859);
      var uncurryThis = __webpack_require__2(5968);
      module.exports = function(CONSTRUCTOR, METHOD) {
        return uncurryThis(global[CONSTRUCTOR].prototype[METHOD]);
      };
    }
  ),
  /***/
  3837: (
    /***/
    (module) => {
      module.exports = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
    }
  ),
  /***/
  3103: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var global = __webpack_require__2(9859);
      var getOwnPropertyDescriptor = __webpack_require__2(7933).f;
      var createNonEnumerableProperty = __webpack_require__2(5762);
      var defineBuiltIn = __webpack_require__2(4768);
      var defineGlobalProperty = __webpack_require__2(8400);
      var copyConstructorProperties = __webpack_require__2(7081);
      var isForced = __webpack_require__2(6541);
      module.exports = function(options, source) {
        var TARGET = options.target;
        var GLOBAL = options.global;
        var STATIC = options.stat;
        var FORCED, target, key, targetProperty, sourceProperty, descriptor;
        if (GLOBAL) {
          target = global;
        } else if (STATIC) {
          target = global[TARGET] || defineGlobalProperty(TARGET, {});
        } else {
          target = (global[TARGET] || {}).prototype;
        }
        if (target)
          for (key in source) {
            sourceProperty = source[key];
            if (options.dontCallGetSet) {
              descriptor = getOwnPropertyDescriptor(target, key);
              targetProperty = descriptor && descriptor.value;
            } else
              targetProperty = target[key];
            FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
            if (!FORCED && targetProperty !== void 0) {
              if (typeof sourceProperty == typeof targetProperty)
                continue;
              copyConstructorProperties(sourceProperty, targetProperty);
            }
            if (options.sham || targetProperty && targetProperty.sham) {
              createNonEnumerableProperty(sourceProperty, "sham", true);
            }
            defineBuiltIn(target, key, sourceProperty, options);
          }
      };
    }
  ),
  /***/
  4229: (
    /***/
    (module) => {
      module.exports = function(exec) {
        try {
          return !!exec();
        } catch (error) {
          return true;
        }
      };
    }
  ),
  /***/
  7188: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var fails = __webpack_require__2(4229);
      module.exports = !fails(function() {
        var test2 = function() {
        }.bind();
        return typeof test2 != "function" || test2.hasOwnProperty("prototype");
      });
    }
  ),
  /***/
  266: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var NATIVE_BIND = __webpack_require__2(7188);
      var call = Function.prototype.call;
      module.exports = NATIVE_BIND ? call.bind(call) : function() {
        return call.apply(call, arguments);
      };
    }
  ),
  /***/
  1805: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var DESCRIPTORS = __webpack_require__2(7400);
      var hasOwn = __webpack_require__2(8270);
      var FunctionPrototype = Function.prototype;
      var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
      var EXISTS = hasOwn(FunctionPrototype, "name");
      var PROPER = EXISTS && function something() {
      }.name === "something";
      var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
      module.exports = {
        EXISTS,
        PROPER,
        CONFIGURABLE
      };
    }
  ),
  /***/
  5968: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var NATIVE_BIND = __webpack_require__2(7188);
      var FunctionPrototype = Function.prototype;
      var call = FunctionPrototype.call;
      var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
      module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
        return function() {
          return call.apply(fn, arguments);
        };
      };
    }
  ),
  /***/
  1333: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var global = __webpack_require__2(9859);
      var isCallable = __webpack_require__2(6733);
      var aFunction = function(argument) {
        return isCallable(argument) ? argument : void 0;
      };
      module.exports = function(namespace, method) {
        return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
      };
    }
  ),
  /***/
  5300: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var aCallable = __webpack_require__2(7111);
      var isNullOrUndefined = __webpack_require__2(9650);
      module.exports = function(V2, P2) {
        var func = V2[P2];
        return isNullOrUndefined(func) ? void 0 : aCallable(func);
      };
    }
  ),
  /***/
  9859: (
    /***/
    function(module, __unused_webpack_exports, __webpack_require__2) {
      var check = function(it) {
        return it && it.Math == Math && it;
      };
      module.exports = // eslint-disable-next-line es/no-global-this -- safe
      check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
      check(typeof self == "object" && self) || check(typeof __webpack_require__2.g == "object" && __webpack_require__2.g) || // eslint-disable-next-line no-new-func -- fallback
      function() {
        return this;
      }() || this || Function("return this")();
    }
  ),
  /***/
  8270: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var uncurryThis = __webpack_require__2(5968);
      var toObject = __webpack_require__2(2991);
      var hasOwnProperty = uncurryThis({}.hasOwnProperty);
      module.exports = Object.hasOwn || function hasOwn(it, key) {
        return hasOwnProperty(toObject(it), key);
      };
    }
  ),
  /***/
  5977: (
    /***/
    (module) => {
      module.exports = {};
    }
  ),
  /***/
  4394: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var DESCRIPTORS = __webpack_require__2(7400);
      var fails = __webpack_require__2(4229);
      var createElement = __webpack_require__2(2635);
      module.exports = !DESCRIPTORS && !fails(function() {
        return Object.defineProperty(createElement("div"), "a", {
          get: function() {
            return 7;
          }
        }).a != 7;
      });
    }
  ),
  /***/
  9337: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var uncurryThis = __webpack_require__2(5968);
      var fails = __webpack_require__2(4229);
      var classof = __webpack_require__2(7079);
      var $Object = Object;
      var split = uncurryThis("".split);
      module.exports = fails(function() {
        return !$Object("z").propertyIsEnumerable(0);
      }) ? function(it) {
        return classof(it) == "String" ? split(it, "") : $Object(it);
      } : $Object;
    }
  ),
  /***/
  8511: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var uncurryThis = __webpack_require__2(5968);
      var isCallable = __webpack_require__2(6733);
      var store = __webpack_require__2(5353);
      var functionToString = uncurryThis(Function.toString);
      if (!isCallable(store.inspectSource)) {
        store.inspectSource = function(it) {
          return functionToString(it);
        };
      }
      module.exports = store.inspectSource;
    }
  ),
  /***/
  6407: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var NATIVE_WEAK_MAP = __webpack_require__2(1180);
      var global = __webpack_require__2(9859);
      var isObject = __webpack_require__2(5052);
      var createNonEnumerableProperty = __webpack_require__2(5762);
      var hasOwn = __webpack_require__2(8270);
      var shared = __webpack_require__2(5353);
      var sharedKey = __webpack_require__2(4399);
      var hiddenKeys = __webpack_require__2(5977);
      var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
      var TypeError2 = global.TypeError;
      var WeakMap2 = global.WeakMap;
      var set, get2, has;
      var enforce = function(it) {
        return has(it) ? get2(it) : set(it, {});
      };
      var getterFor = function(TYPE) {
        return function(it) {
          var state;
          if (!isObject(it) || (state = get2(it)).type !== TYPE) {
            throw TypeError2("Incompatible receiver, " + TYPE + " required");
          }
          return state;
        };
      };
      if (NATIVE_WEAK_MAP || shared.state) {
        var store = shared.state || (shared.state = new WeakMap2());
        store.get = store.get;
        store.has = store.has;
        store.set = store.set;
        set = function(it, metadata) {
          if (store.has(it))
            throw TypeError2(OBJECT_ALREADY_INITIALIZED);
          metadata.facade = it;
          store.set(it, metadata);
          return metadata;
        };
        get2 = function(it) {
          return store.get(it) || {};
        };
        has = function(it) {
          return store.has(it);
        };
      } else {
        var STATE = sharedKey("state");
        hiddenKeys[STATE] = true;
        set = function(it, metadata) {
          if (hasOwn(it, STATE))
            throw TypeError2(OBJECT_ALREADY_INITIALIZED);
          metadata.facade = it;
          createNonEnumerableProperty(it, STATE, metadata);
          return metadata;
        };
        get2 = function(it) {
          return hasOwn(it, STATE) ? it[STATE] : {};
        };
        has = function(it) {
          return hasOwn(it, STATE);
        };
      }
      module.exports = {
        set,
        get: get2,
        has,
        enforce,
        getterFor
      };
    }
  ),
  /***/
  6733: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var $documentAll = __webpack_require__2(3777);
      var documentAll = $documentAll.all;
      module.exports = $documentAll.IS_HTMLDDA ? function(argument) {
        return typeof argument == "function" || argument === documentAll;
      } : function(argument) {
        return typeof argument == "function";
      };
    }
  ),
  /***/
  6541: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var fails = __webpack_require__2(4229);
      var isCallable = __webpack_require__2(6733);
      var replacement = /#|\.prototype\./;
      var isForced = function(feature, detection) {
        var value = data[normalize(feature)];
        return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
      };
      var normalize = isForced.normalize = function(string) {
        return String(string).replace(replacement, ".").toLowerCase();
      };
      var data = isForced.data = {};
      var NATIVE = isForced.NATIVE = "N";
      var POLYFILL = isForced.POLYFILL = "P";
      module.exports = isForced;
    }
  ),
  /***/
  9650: (
    /***/
    (module) => {
      module.exports = function(it) {
        return it === null || it === void 0;
      };
    }
  ),
  /***/
  5052: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var isCallable = __webpack_require__2(6733);
      var $documentAll = __webpack_require__2(3777);
      var documentAll = $documentAll.all;
      module.exports = $documentAll.IS_HTMLDDA ? function(it) {
        return typeof it == "object" ? it !== null : isCallable(it) || it === documentAll;
      } : function(it) {
        return typeof it == "object" ? it !== null : isCallable(it);
      };
    }
  ),
  /***/
  4231: (
    /***/
    (module) => {
      module.exports = false;
    }
  ),
  /***/
  9395: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var getBuiltIn = __webpack_require__2(1333);
      var isCallable = __webpack_require__2(6733);
      var isPrototypeOf = __webpack_require__2(1321);
      var USE_SYMBOL_AS_UID = __webpack_require__2(6969);
      var $Object = Object;
      module.exports = USE_SYMBOL_AS_UID ? function(it) {
        return typeof it == "symbol";
      } : function(it) {
        var $Symbol = getBuiltIn("Symbol");
        return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
      };
    }
  ),
  /***/
  9646: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var toLength = __webpack_require__2(4237);
      module.exports = function(obj) {
        return toLength(obj.length);
      };
    }
  ),
  /***/
  6039: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var uncurryThis = __webpack_require__2(5968);
      var fails = __webpack_require__2(4229);
      var isCallable = __webpack_require__2(6733);
      var hasOwn = __webpack_require__2(8270);
      var DESCRIPTORS = __webpack_require__2(7400);
      var CONFIGURABLE_FUNCTION_NAME = __webpack_require__2(1805).CONFIGURABLE;
      var inspectSource = __webpack_require__2(8511);
      var InternalStateModule = __webpack_require__2(6407);
      var enforceInternalState = InternalStateModule.enforce;
      var getInternalState = InternalStateModule.get;
      var $String = String;
      var defineProperty = Object.defineProperty;
      var stringSlice = uncurryThis("".slice);
      var replace = uncurryThis("".replace);
      var join = uncurryThis([].join);
      var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
        return defineProperty(function() {
        }, "length", { value: 8 }).length !== 8;
      });
      var TEMPLATE = String(String).split("String");
      var makeBuiltIn = module.exports = function(value, name, options) {
        if (stringSlice($String(name), 0, 7) === "Symbol(") {
          name = "[" + replace($String(name), /^Symbol\(([^)]*)\)/, "$1") + "]";
        }
        if (options && options.getter)
          name = "get " + name;
        if (options && options.setter)
          name = "set " + name;
        if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
          if (DESCRIPTORS)
            defineProperty(value, "name", { value: name, configurable: true });
          else
            value.name = name;
        }
        if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
          defineProperty(value, "length", { value: options.arity });
        }
        try {
          if (options && hasOwn(options, "constructor") && options.constructor) {
            if (DESCRIPTORS)
              defineProperty(value, "prototype", { writable: false });
          } else if (value.prototype)
            value.prototype = void 0;
        } catch (error) {
        }
        var state = enforceInternalState(value);
        if (!hasOwn(state, "source")) {
          state.source = join(TEMPLATE, typeof name == "string" ? name : "");
        }
        return value;
      };
      Function.prototype.toString = makeBuiltIn(function toString() {
        return isCallable(this) && getInternalState(this).source || inspectSource(this);
      }, "toString");
    }
  ),
  /***/
  917: (
    /***/
    (module) => {
      var ceil = Math.ceil;
      var floor = Math.floor;
      module.exports = Math.trunc || function trunc(x2) {
        var n2 = +x2;
        return (n2 > 0 ? floor : ceil)(n2);
      };
    }
  ),
  /***/
  1787: (
    /***/
    (__unused_webpack_module, exports, __webpack_require__2) => {
      var DESCRIPTORS = __webpack_require__2(7400);
      var IE8_DOM_DEFINE = __webpack_require__2(4394);
      var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__2(7137);
      var anObject = __webpack_require__2(1176);
      var toPropertyKey = __webpack_require__2(9310);
      var $TypeError = TypeError;
      var $defineProperty = Object.defineProperty;
      var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var ENUMERABLE = "enumerable";
      var CONFIGURABLE = "configurable";
      var WRITABLE = "writable";
      exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O2, P2, Attributes) {
        anObject(O2);
        P2 = toPropertyKey(P2);
        anObject(Attributes);
        if (typeof O2 === "function" && P2 === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
          var current = $getOwnPropertyDescriptor(O2, P2);
          if (current && current[WRITABLE]) {
            O2[P2] = Attributes.value;
            Attributes = {
              configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
              enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
              writable: false
            };
          }
        }
        return $defineProperty(O2, P2, Attributes);
      } : $defineProperty : function defineProperty(O2, P2, Attributes) {
        anObject(O2);
        P2 = toPropertyKey(P2);
        anObject(Attributes);
        if (IE8_DOM_DEFINE)
          try {
            return $defineProperty(O2, P2, Attributes);
          } catch (error) {
          }
        if ("get" in Attributes || "set" in Attributes)
          throw $TypeError("Accessors not supported");
        if ("value" in Attributes)
          O2[P2] = Attributes.value;
        return O2;
      };
    }
  ),
  /***/
  7933: (
    /***/
    (__unused_webpack_module, exports, __webpack_require__2) => {
      var DESCRIPTORS = __webpack_require__2(7400);
      var call = __webpack_require__2(266);
      var propertyIsEnumerableModule = __webpack_require__2(9195);
      var createPropertyDescriptor = __webpack_require__2(5358);
      var toIndexedObject = __webpack_require__2(905);
      var toPropertyKey = __webpack_require__2(9310);
      var hasOwn = __webpack_require__2(8270);
      var IE8_DOM_DEFINE = __webpack_require__2(4394);
      var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O2, P2) {
        O2 = toIndexedObject(O2);
        P2 = toPropertyKey(P2);
        if (IE8_DOM_DEFINE)
          try {
            return $getOwnPropertyDescriptor(O2, P2);
          } catch (error) {
          }
        if (hasOwn(O2, P2))
          return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O2, P2), O2[P2]);
      };
    }
  ),
  /***/
  8151: (
    /***/
    (__unused_webpack_module, exports, __webpack_require__2) => {
      var internalObjectKeys = __webpack_require__2(140);
      var enumBugKeys = __webpack_require__2(3837);
      var hiddenKeys = enumBugKeys.concat("length", "prototype");
      exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {
        return internalObjectKeys(O2, hiddenKeys);
      };
    }
  ),
  /***/
  894: (
    /***/
    (__unused_webpack_module, exports) => {
      exports.f = Object.getOwnPropertySymbols;
    }
  ),
  /***/
  1321: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var uncurryThis = __webpack_require__2(5968);
      module.exports = uncurryThis({}.isPrototypeOf);
    }
  ),
  /***/
  140: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var uncurryThis = __webpack_require__2(5968);
      var hasOwn = __webpack_require__2(8270);
      var toIndexedObject = __webpack_require__2(905);
      var indexOf = __webpack_require__2(9540).indexOf;
      var hiddenKeys = __webpack_require__2(5977);
      var push = uncurryThis([].push);
      module.exports = function(object, names) {
        var O2 = toIndexedObject(object);
        var i2 = 0;
        var result = [];
        var key;
        for (key in O2)
          !hasOwn(hiddenKeys, key) && hasOwn(O2, key) && push(result, key);
        while (names.length > i2)
          if (hasOwn(O2, key = names[i2++])) {
            ~indexOf(result, key) || push(result, key);
          }
        return result;
      };
    }
  ),
  /***/
  5632: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var internalObjectKeys = __webpack_require__2(140);
      var enumBugKeys = __webpack_require__2(3837);
      module.exports = Object.keys || function keys(O2) {
        return internalObjectKeys(O2, enumBugKeys);
      };
    }
  ),
  /***/
  9195: (
    /***/
    (__unused_webpack_module, exports) => {
      var $propertyIsEnumerable = {}.propertyIsEnumerable;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
      exports.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
        var descriptor = getOwnPropertyDescriptor(this, V2);
        return !!descriptor && descriptor.enumerable;
      } : $propertyIsEnumerable;
    }
  ),
  /***/
  2914: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var call = __webpack_require__2(266);
      var isCallable = __webpack_require__2(6733);
      var isObject = __webpack_require__2(5052);
      var $TypeError = TypeError;
      module.exports = function(input, pref) {
        var fn, val;
        if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
          return val;
        if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
          return val;
        if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
          return val;
        throw $TypeError("Can't convert object to primitive value");
      };
    }
  ),
  /***/
  4826: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var getBuiltIn = __webpack_require__2(1333);
      var uncurryThis = __webpack_require__2(5968);
      var getOwnPropertyNamesModule = __webpack_require__2(8151);
      var getOwnPropertySymbolsModule = __webpack_require__2(894);
      var anObject = __webpack_require__2(1176);
      var concat = uncurryThis([].concat);
      module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
        var keys = getOwnPropertyNamesModule.f(anObject(it));
        var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
      };
    }
  ),
  /***/
  9276: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var global = __webpack_require__2(9859);
      module.exports = global;
    }
  ),
  /***/
  8885: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var isNullOrUndefined = __webpack_require__2(9650);
      var $TypeError = TypeError;
      module.exports = function(it) {
        if (isNullOrUndefined(it))
          throw $TypeError("Can't call method on " + it);
        return it;
      };
    }
  ),
  /***/
  4399: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var shared = __webpack_require__2(3036);
      var uid = __webpack_require__2(1441);
      var keys = shared("keys");
      module.exports = function(key) {
        return keys[key] || (keys[key] = uid(key));
      };
    }
  ),
  /***/
  5353: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var global = __webpack_require__2(9859);
      var defineGlobalProperty = __webpack_require__2(8400);
      var SHARED = "__core-js_shared__";
      var store = global[SHARED] || defineGlobalProperty(SHARED, {});
      module.exports = store;
    }
  ),
  /***/
  3036: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var IS_PURE = __webpack_require__2(4231);
      var store = __webpack_require__2(5353);
      (module.exports = function(key, value) {
        return store[key] || (store[key] = value !== void 0 ? value : {});
      })("versions", []).push({
        version: "3.32.0",
        mode: IS_PURE ? "pure" : "global",
        copyright: " 2014-2023 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.32.0/LICENSE",
        source: "https://github.com/zloirock/core-js"
      });
    }
  ),
  /***/
  4860: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var V8_VERSION = __webpack_require__2(5884);
      var fails = __webpack_require__2(4229);
      var global = __webpack_require__2(9859);
      var $String = global.String;
      module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
        var symbol = Symbol();
        return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
        !Symbol.sham && V8_VERSION && V8_VERSION < 41;
      });
    }
  ),
  /***/
  3231: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var toIntegerOrInfinity = __webpack_require__2(3329);
      var max = Math.max;
      var min = Math.min;
      module.exports = function(index, length) {
        var integer = toIntegerOrInfinity(index);
        return integer < 0 ? max(integer + length, 0) : min(integer, length);
      };
    }
  ),
  /***/
  905: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var IndexedObject = __webpack_require__2(9337);
      var requireObjectCoercible = __webpack_require__2(8885);
      module.exports = function(it) {
        return IndexedObject(requireObjectCoercible(it));
      };
    }
  ),
  /***/
  3329: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var trunc = __webpack_require__2(917);
      module.exports = function(argument) {
        var number2 = +argument;
        return number2 !== number2 || number2 === 0 ? 0 : trunc(number2);
      };
    }
  ),
  /***/
  4237: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var toIntegerOrInfinity = __webpack_require__2(3329);
      var min = Math.min;
      module.exports = function(argument) {
        return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
      };
    }
  ),
  /***/
  2991: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var requireObjectCoercible = __webpack_require__2(8885);
      var $Object = Object;
      module.exports = function(argument) {
        return $Object(requireObjectCoercible(argument));
      };
    }
  ),
  /***/
  2066: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var call = __webpack_require__2(266);
      var isObject = __webpack_require__2(5052);
      var isSymbol = __webpack_require__2(9395);
      var getMethod = __webpack_require__2(5300);
      var ordinaryToPrimitive = __webpack_require__2(2914);
      var wellKnownSymbol = __webpack_require__2(95);
      var $TypeError = TypeError;
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      module.exports = function(input, pref) {
        if (!isObject(input) || isSymbol(input))
          return input;
        var exoticToPrim = getMethod(input, TO_PRIMITIVE);
        var result;
        if (exoticToPrim) {
          if (pref === void 0)
            pref = "default";
          result = call(exoticToPrim, input, pref);
          if (!isObject(result) || isSymbol(result))
            return result;
          throw $TypeError("Can't convert object to primitive value");
        }
        if (pref === void 0)
          pref = "number";
        return ordinaryToPrimitive(input, pref);
      };
    }
  ),
  /***/
  9310: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var toPrimitive = __webpack_require__2(2066);
      var isSymbol = __webpack_require__2(9395);
      module.exports = function(argument) {
        var key = toPrimitive(argument, "string");
        return isSymbol(key) ? key : key + "";
      };
    }
  ),
  /***/
  1601: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var wellKnownSymbol = __webpack_require__2(95);
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var test2 = {};
      test2[TO_STRING_TAG] = "z";
      module.exports = String(test2) === "[object z]";
    }
  ),
  /***/
  3326: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var classof = __webpack_require__2(1589);
      var $String = String;
      module.exports = function(argument) {
        if (classof(argument) === "Symbol")
          throw TypeError("Cannot convert a Symbol value to a string");
        return $String(argument);
      };
    }
  ),
  /***/
  9821: (
    /***/
    (module) => {
      var $String = String;
      module.exports = function(argument) {
        try {
          return $String(argument);
        } catch (error) {
          return "Object";
        }
      };
    }
  ),
  /***/
  1441: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var uncurryThis = __webpack_require__2(5968);
      var id2 = 0;
      var postfix = Math.random();
      var toString = uncurryThis(1 .toString);
      module.exports = function(key) {
        return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id2 + postfix, 36);
      };
    }
  ),
  /***/
  6969: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var NATIVE_SYMBOL = __webpack_require__2(4860);
      module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
    }
  ),
  /***/
  7137: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var DESCRIPTORS = __webpack_require__2(7400);
      var fails = __webpack_require__2(4229);
      module.exports = DESCRIPTORS && fails(function() {
        return Object.defineProperty(function() {
        }, "prototype", {
          value: 42,
          writable: false
        }).prototype != 42;
      });
    }
  ),
  /***/
  1180: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var global = __webpack_require__2(9859);
      var isCallable = __webpack_require__2(6733);
      var WeakMap2 = global.WeakMap;
      module.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
    }
  ),
  /***/
  95: (
    /***/
    (module, __unused_webpack_exports, __webpack_require__2) => {
      var global = __webpack_require__2(9859);
      var shared = __webpack_require__2(3036);
      var hasOwn = __webpack_require__2(8270);
      var uid = __webpack_require__2(1441);
      var NATIVE_SYMBOL = __webpack_require__2(4860);
      var USE_SYMBOL_AS_UID = __webpack_require__2(6969);
      var Symbol2 = global.Symbol;
      var WellKnownSymbolsStore = shared("wks");
      var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
      module.exports = function(name) {
        if (!hasOwn(WellKnownSymbolsStore, name)) {
          WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
        }
        return WellKnownSymbolsStore[name];
      };
    }
  ),
  /***/
  3430: (
    /***/
    (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
      var $2 = __webpack_require__2(3103);
      var uncurryThis = __webpack_require__2(5968);
      var aCallable = __webpack_require__2(7111);
      var toObject = __webpack_require__2(2991);
      var lengthOfArrayLike = __webpack_require__2(9646);
      var deletePropertyOrThrow = __webpack_require__2(9563);
      var toString = __webpack_require__2(3326);
      var fails = __webpack_require__2(4229);
      var internalSort = __webpack_require__2(3867);
      var arrayMethodIsStrict = __webpack_require__2(6038);
      var FF = __webpack_require__2(2671);
      var IE_OR_EDGE = __webpack_require__2(8506);
      var V8 = __webpack_require__2(5884);
      var WEBKIT = __webpack_require__2(9811);
      var test2 = [];
      var nativeSort = uncurryThis(test2.sort);
      var push = uncurryThis(test2.push);
      var FAILS_ON_UNDEFINED = fails(function() {
        test2.sort(void 0);
      });
      var FAILS_ON_NULL = fails(function() {
        test2.sort(null);
      });
      var STRICT_METHOD = arrayMethodIsStrict("sort");
      var STABLE_SORT = !fails(function() {
        if (V8)
          return V8 < 70;
        if (FF && FF > 3)
          return;
        if (IE_OR_EDGE)
          return true;
        if (WEBKIT)
          return WEBKIT < 603;
        var result = "";
        var code, chr, value, index;
        for (code = 65; code < 76; code++) {
          chr = String.fromCharCode(code);
          switch (code) {
            case 66:
            case 69:
            case 70:
            case 72:
              value = 3;
              break;
            case 68:
            case 71:
              value = 4;
              break;
            default:
              value = 2;
          }
          for (index = 0; index < 47; index++) {
            test2.push({ k: chr + index, v: value });
          }
        }
        test2.sort(function(a2, b2) {
          return b2.v - a2.v;
        });
        for (index = 0; index < test2.length; index++) {
          chr = test2[index].k.charAt(0);
          if (result.charAt(result.length - 1) !== chr)
            result += chr;
        }
        return result !== "DGBEFHACIJK";
      });
      var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;
      var getSortCompare = function(comparefn) {
        return function(x2, y2) {
          if (y2 === void 0)
            return -1;
          if (x2 === void 0)
            return 1;
          if (comparefn !== void 0)
            return +comparefn(x2, y2) || 0;
          return toString(x2) > toString(y2) ? 1 : -1;
        };
      };
      $2({ target: "Array", proto: true, forced: FORCED }, {
        sort: function sort(comparefn) {
          if (comparefn !== void 0)
            aCallable(comparefn);
          var array = toObject(this);
          if (STABLE_SORT)
            return comparefn === void 0 ? nativeSort(array) : nativeSort(array, comparefn);
          var items = [];
          var arrayLength = lengthOfArrayLike(array);
          var itemsLength, index;
          for (index = 0; index < arrayLength; index++) {
            if (index in array)
              push(items, array[index]);
          }
          internalSort(items, getSortCompare(comparefn));
          itemsLength = lengthOfArrayLike(items);
          index = 0;
          while (index < itemsLength)
            array[index] = items[index++];
          while (index < arrayLength)
            deletePropertyOrThrow(array, index++);
          return array;
        }
      });
    }
  ),
  /***/
  4769: (
    /***/
    (__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
      var $2 = __webpack_require__2(3103);
      var toObject = __webpack_require__2(2991);
      var nativeKeys = __webpack_require__2(5632);
      var fails = __webpack_require__2(4229);
      var FAILS_ON_PRIMITIVES = fails(function() {
        nativeKeys(1);
      });
      $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
        keys: function keys(it) {
          return nativeKeys(toObject(it));
        }
      });
    }
  ),
  /***/
  1388: (
    /***/
    (module, __webpack_exports__2, __webpack_require__2) => {
      __webpack_require__2.d(__webpack_exports__2, {
        /* harmony export */
        Z: () => __WEBPACK_DEFAULT_EXPORT__
        /* harmony export */
      });
      var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(272);
      var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
      var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(2609);
      var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
      var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
      ___CSS_LOADER_EXPORT___.push([module.id, `/* Buttons styles start */

button#excalibur-play {
  display: inline-block;
  position: relative;
  z-index: 999;
  border-radius: 6px;
  border: none;
  /*border: 3px solid;
    border-color: white;
    box-shadow: 0 0 10px #ccc;*/
  padding: 1rem 1.5rem 1rem 4rem;
  margin: 0;
  text-decoration: none;
  background: #00b233;
  color: #ffffff;
  font-family: sans-serif;
  font-size: 2rem;
  white-space: nowrap;
  line-height: 1;
  cursor: pointer;
  text-align: center;
  transition: background 250ms ease-in-out, transform 150ms ease;
  -webkit-appearance: none;
  -moz-appearance: none;

  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */
  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */
  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */
  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */
  animation: excalibur-button-fadein 200ms;
}

/*
button#excalibur-play {
  display: none;
}*/

button#excalibur-play:after {
  position: absolute;
  content: '';
  border: 8px solid;
  border-color: transparent transparent transparent white;
  left: 35px;
  top: 24px;
  width: 0;
  height: 0;
}

button#excalibur-play:before {
  position: absolute;
  content: '';
  border: 3px solid;
  left: 19px;
  top: 14px;
  border-radius: 20px;
  width: 30px;
  height: 30px;
}

button#excalibur-play:hover,
button#excalibur-play:focus {
  background: #00982c;
}

button#excalibur-play:focus {
  outline: 1px solid #fff;
  outline-offset: -4px;
}

button#excalibur-play:active {
  transform: scale(0.99);
}

@keyframes excalibur-button-fadein {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

/* Firefox < 16 */
@-moz-keyframes excalibur-button-fadein {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

/* Safari, Chrome and Opera > 12.1 */
@-webkit-keyframes excalibur-button-fadein {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

/* Internet Explorer */
@-ms-keyframes excalibur-button-fadein {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

/* Opera < 12.1 */
@-o-keyframes excalibur-button-fadein {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
`, "", { "version": 3, "sources": ["webpack://./Loader.css"], "names": [], "mappings": "AAAA,yBAAyB;;AAEzB;EACE,qBAAqB;EACrB,kBAAkB;EAClB,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ;;+BAE6B;EAC7B,8BAA8B;EAC9B,SAAS;EACT,qBAAqB;EACrB,mBAAmB;EACnB,cAAc;EACd,uBAAuB;EACvB,eAAe;EACf,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,kBAAkB;EAClB,8DAA8D;EAC9D,wBAAwB;EACxB,qBAAqB;;EAErB,gDAAgD,EAAE,oCAAoC;EACtF,6CAA6C,EAAE,iBAAiB;EAChE,4CAA4C,EAAE,sBAAsB;EACpE,2CAA2C,EAAE,iBAAiB;EAC9D,wCAAwC;AAC1C;;AAEA;;;EAGE;;AAEF;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,uDAAuD;EACvD,UAAU;EACV,SAAS;EACT,QAAQ;EACR,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,UAAU;EACV,SAAS;EACT,mBAAmB;EACnB,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;EACE,uBAAuB;EACvB,oBAAoB;AACtB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,oCAAoC;AACpC;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,sBAAsB;AACtB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF", "sourcesContent": ["/* Buttons styles start */\r\n\r\nbutton#excalibur-play {\r\n  display: inline-block;\r\n  position: relative;\r\n  z-index: 999;\r\n  border-radius: 6px;\r\n  border: none;\r\n  /*border: 3px solid;\r\n    border-color: white;\r\n    box-shadow: 0 0 10px #ccc;*/\r\n  padding: 1rem 1.5rem 1rem 4rem;\r\n  margin: 0;\r\n  text-decoration: none;\r\n  background: #00b233;\r\n  color: #ffffff;\r\n  font-family: sans-serif;\r\n  font-size: 2rem;\r\n  white-space: nowrap;\r\n  line-height: 1;\r\n  cursor: pointer;\r\n  text-align: center;\r\n  transition: background 250ms ease-in-out, transform 150ms ease;\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n\r\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\r\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\r\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\r\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\r\n  animation: excalibur-button-fadein 200ms;\r\n}\r\n\r\n/*\r\nbutton#excalibur-play {\r\n  display: none;\r\n}*/\r\n\r\nbutton#excalibur-play:after {\r\n  position: absolute;\r\n  content: '';\r\n  border: 8px solid;\r\n  border-color: transparent transparent transparent white;\r\n  left: 35px;\r\n  top: 24px;\r\n  width: 0;\r\n  height: 0;\r\n}\r\n\r\nbutton#excalibur-play:before {\r\n  position: absolute;\r\n  content: '';\r\n  border: 3px solid;\r\n  left: 19px;\r\n  top: 14px;\r\n  border-radius: 20px;\r\n  width: 30px;\r\n  height: 30px;\r\n}\r\n\r\nbutton#excalibur-play:hover,\r\nbutton#excalibur-play:focus {\r\n  background: #00982c;\r\n}\r\n\r\nbutton#excalibur-play:focus {\r\n  outline: 1px solid #fff;\r\n  outline-offset: -4px;\r\n}\r\n\r\nbutton#excalibur-play:active {\r\n  transform: scale(0.99);\r\n}\r\n\r\n@keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Firefox < 16 */\r\n@-moz-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Safari, Chrome and Opera > 12.1 */\r\n@-webkit-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Internet Explorer */\r\n@-ms-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Opera < 12.1 */\r\n@-o-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n"], "sourceRoot": "" }]);
      const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
    }
  ),
  /***/
  7379: (
    /***/
    (module, __webpack_exports__2, __webpack_require__2) => {
      __webpack_require__2.d(__webpack_exports__2, {
        /* harmony export */
        Z: () => __WEBPACK_DEFAULT_EXPORT__
        /* harmony export */
      });
      var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(272);
      var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
      var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(2609);
      var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__2.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
      var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
      ___CSS_LOADER_EXPORT___.push([module.id, `
#ex-toast-container {
  position: absolute;
  height: 0;
  min-width: 50%;
  left: 50%;
  top: 0;
}

.ex-toast-message {
  left: -50%;
  position: relative;
  display: flex;
  justify-content: space-between;


  padding: 10px;
  margin-top: 5px;
  font-size: 18px;
  font-family: sans-serif;
  border-radius: 6px;
  border: 3px solid #b7b779;
  background-color: rgb(253, 253, 192);
}


.ex-toast-message button {
  align-self: flex-start;
}`, "", { "version": 3, "sources": ["webpack://./Util/Toaster.css"], "names": [], "mappings": ";AACA;EACE,kBAAkB;EAClB,SAAS;EACT,cAAc;EACd,SAAS;EACT,MAAM;AACR;;AAEA;EACE,UAAU;EACV,kBAAkB;EAClB,aAAa;EACb,8BAA8B;;;EAG9B,aAAa;EACb,eAAe;EACf,eAAe;EACf,uBAAuB;EACvB,kBAAkB;EAClB,yBAAyB;EACzB,oCAAoC;AACtC;;;AAGA;EACE,sBAAsB;AACxB", "sourcesContent": ["\r\n#ex-toast-container {\r\n  position: absolute;\r\n  height: 0;\r\n  min-width: 50%;\r\n  left: 50%;\r\n  top: 0;\r\n}\r\n\r\n.ex-toast-message {\r\n  left: -50%;\r\n  position: relative;\r\n  display: flex;\r\n  justify-content: space-between;\r\n\r\n\r\n  padding: 10px;\r\n  margin-top: 5px;\r\n  font-size: 18px;\r\n  font-family: sans-serif;\r\n  border-radius: 6px;\r\n  border: 3px solid #b7b779;\r\n  background-color: rgb(253, 253, 192);\r\n}\r\n\r\n\r\n.ex-toast-message button {\r\n  align-self: flex-start;\r\n}"], "sourceRoot": "" }]);
      const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
    }
  ),
  /***/
  2609: (
    /***/
    (module) => {
      module.exports = function(cssWithMappingToString) {
        var list = [];
        list.toString = function toString() {
          return this.map(function(item) {
            var content = "";
            var needLayer = typeof item[5] !== "undefined";
            if (item[4]) {
              content += "@supports (".concat(item[4], ") {");
            }
            if (item[2]) {
              content += "@media ".concat(item[2], " {");
            }
            if (needLayer) {
              content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
            }
            content += cssWithMappingToString(item);
            if (needLayer) {
              content += "}";
            }
            if (item[2]) {
              content += "}";
            }
            if (item[4]) {
              content += "}";
            }
            return content;
          }).join("");
        };
        list.i = function i2(modules, media, dedupe, supports2, layer) {
          if (typeof modules === "string") {
            modules = [[null, modules, void 0]];
          }
          var alreadyImportedModules = {};
          if (dedupe) {
            for (var k2 = 0; k2 < this.length; k2++) {
              var id2 = this[k2][0];
              if (id2 != null) {
                alreadyImportedModules[id2] = true;
              }
            }
          }
          for (var _k = 0; _k < modules.length; _k++) {
            var item = [].concat(modules[_k]);
            if (dedupe && alreadyImportedModules[item[0]]) {
              continue;
            }
            if (typeof layer !== "undefined") {
              if (typeof item[5] === "undefined") {
                item[5] = layer;
              } else {
                item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
                item[5] = layer;
              }
            }
            if (media) {
              if (!item[2]) {
                item[2] = media;
              } else {
                item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
                item[2] = media;
              }
            }
            if (supports2) {
              if (!item[4]) {
                item[4] = "".concat(supports2);
              } else {
                item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
                item[4] = supports2;
              }
            }
            list.push(item);
          }
        };
        return list;
      };
    }
  ),
  /***/
  272: (
    /***/
    (module) => {
      module.exports = function(item) {
        var content = item[1];
        var cssMapping = item[3];
        if (!cssMapping) {
          return content;
        }
        if (typeof btoa === "function") {
          var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
          var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
          var sourceMapping = "/*# ".concat(data, " */");
          return [content].concat([sourceMapping]).join("\n");
        }
        return [content].join("\n");
      };
    }
  )
  /******/
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
  var cachedModule = __webpack_module_cache__[moduleId];
  if (cachedModule !== void 0) {
    return cachedModule.exports;
  }
  var module = __webpack_module_cache__[moduleId] = {
    /******/
    id: moduleId,
    /******/
    // no module.loaded needed
    /******/
    exports: {}
    /******/
  };
  __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  return module.exports;
}
(() => {
  __webpack_require__.n = (module) => {
    var getter = module && module.__esModule ? (
      /******/
      () => module["default"]
    ) : (
      /******/
      () => module
    );
    __webpack_require__.d(getter, { a: getter });
    return getter;
  };
})();
(() => {
  __webpack_require__.d = (exports, definition) => {
    for (var key in definition) {
      if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
        Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
      }
    }
  };
})();
(() => {
  __webpack_require__.g = function() {
    if (typeof globalThis === "object")
      return globalThis;
    try {
      return this || new Function("return this")();
    } catch (e2) {
      if (typeof window === "object")
        return window;
    }
  }();
})();
(() => {
  __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
})();
(() => {
  __webpack_require__.r = (exports) => {
    if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
    }
    Object.defineProperty(exports, "__esModule", { value: true });
  };
})();
var __webpack_exports__ = {};
(() => {
  __webpack_require__.d(__webpack_exports__, {
    fWn: () => (
      /* reexport */
      ActionContext
    ),
    Ia8: () => (
      /* reexport */
      ActionQueue
    ),
    rqv: () => (
      /* reexport */
      ActionSequence
    ),
    hLI: () => (
      /* reexport */
      ActionsComponent
    ),
    yyv: () => (
      /* reexport */
      ActionsSystem
    ),
    tX5: () => (
      /* reexport */
      ActivateEvent
    ),
    vtX: () => (
      /* reexport */
      Actor
    ),
    r7K: () => (
      /* reexport */
      AddedComponent
    ),
    lCh: () => (
      /* reexport */
      AddedEntity
    ),
    cE4: () => (
      /* reexport */
      AffineMatrix
    ),
    fwF: () => (
      /* reexport */
      Animation
    ),
    sce: () => (
      /* reexport */
      AnimationDirection
    ),
    AQ6: () => (
      /* reexport */
      AnimationEvents
    ),
    _c7: () => (
      /* reexport */
      AnimationStrategy
    ),
    KUs: () => (
      /* reexport */
      ArcadeSolver
    ),
    Ajp: () => (
      /* reexport */
      AudioContextFactory
    ),
    dkO: () => (
      /* reexport */
      Axes
    ),
    RDh: () => (
      /* reexport */
      Axis
    ),
    _H9: () => (
      /* reexport */
      BaseAlign
    ),
    mxs: () => (
      /* reexport */
      Blink
    ),
    OmD: () => (
      /* reexport */
      BodyComponent
    ),
    kBf: () => (
      /* reexport */
      BoundingBox
    ),
    C4F: () => (
      /* reexport */
      BroadphaseStrategy
    ),
    NQt: () => (
      /* reexport */
      BrowserComponent
    ),
    JjN: () => (
      /* reexport */
      BrowserEvents
    ),
    EK_: () => (
      /* reexport */
      Buttons
    ),
    V1s: () => (
      /* reexport */
      Camera
    ),
    xHm: () => (
      /* reexport */
      CameraEvents
    ),
    Xz7: () => (
      /* reexport */
      Canvas
    ),
    Cdc: () => (
      /* reexport */
      Circle
    ),
    FKn: () => (
      /* reexport */
      CircleCollider
    ),
    SUY: () => (
      /* reexport */
      Clock
    ),
    ab2: () => (
      /* reexport */
      ClosestLine
    ),
    GfZ: () => (
      /* reexport */
      ClosestLineJumpTable
    ),
    YMS: () => (
      /* reexport */
      Collider
    ),
    oyv: () => (
      /* reexport */
      ColliderComponent
    ),
    aUb: () => (
      /* reexport */
      CollisionContact
    ),
    SdD: () => (
      /* reexport */
      CollisionEndEvent
    ),
    JUv: () => (
      /* reexport */
      CollisionGroup
    ),
    jEj: () => (
      /* reexport */
      CollisionGroupManager
    ),
    TFq: () => (
      /* reexport */
      CollisionJumpTable
    ),
    HDU: () => (
      /* reexport */
      CollisionPostSolveEvent
    ),
    R_y: () => (
      /* reexport */
      CollisionPreSolveEvent
    ),
    ydN: () => (
      /* reexport */
      CollisionResolutionStrategy
    ),
    t50: () => (
      /* reexport */
      CollisionStartEvent
    ),
    s$$: () => (
      /* reexport */
      CollisionSystem
    ),
    v2G: () => (
      /* reexport */
      CollisionType
    ),
    Ilk: () => (
      /* reexport */
      Color
    ),
    s9i: () => (
      /* reexport */
      ColorBlindFlags
    ),
    dxL: () => (
      /* reexport */
      ColorBlindnessMode
    ),
    LLX: () => (
      /* reexport */
      ColorBlindnessPostProcessor
    ),
    wA2: () => (
      /* reexport */
      Component
    ),
    R_p: () => (
      /* reexport */
      CompositeCollider
    ),
    IQ$: () => (
      /* reexport */
      Configurable
    ),
    I5F: () => (
      /* reexport */
      ConsoleAppender
    ),
    X8$: () => (
      /* reexport */
      ContactConstraintPoint
    ),
    FR6: () => (
      /* reexport */
      ContactEndEvent
    ),
    U8o: () => (
      /* reexport */
      ContactStartEvent
    ),
    kbG: () => (
      /* reexport */
      CoordPlane
    ),
    iS_: () => (
      /* reexport */
      DeactivateEvent
    ),
    cGG: () => (
      /* reexport */
      Debug
    ),
    RPN: () => (
      /* reexport */
      DebugGraphicsComponent
    ),
    skb: () => (
      /* reexport */
      DebugSystem
    ),
    SLU: () => (
      /* reexport */
      DebugText
    ),
    RdJ: () => (
      /* reexport */
      DegreeOfFreedom
    ),
    cNu: () => (
      /* reexport */
      Delay
    ),
    gU7: () => (
      /* reexport */
      Detector
    ),
    LSk: () => (
      /* reexport */
      Die
    ),
    Nmp: () => (
      /* reexport */
      Direction
    ),
    d1Y: () => (
      /* reexport */
      DisplayMode
    ),
    xrL: () => (
      /* reexport */
      DynamicTree
    ),
    sRW: () => (
      /* reexport */
      DynamicTreeCollisionProcessor
    ),
    cmV: () => (
      /* binding */
      EX_VERSION
    ),
    qWz: () => (
      /* reexport */
      EaseBy
    ),
    N0Q: () => (
      /* reexport */
      EaseTo
    ),
    q8b: () => (
      /* reexport */
      EasingFunctions
    ),
    ynB: () => (
      /* reexport */
      EdgeCollider
    ),
    jT9: () => (
      /* reexport */
      ElasticToActorStrategy
    ),
    wAz: () => (
      /* reexport */
      EmitterType
    ),
    D4V: () => (
      /* reexport */
      Engine
    ),
    NLr: () => (
      /* reexport */
      EngineEvents
    ),
    N6H: () => (
      /* reexport */
      EnterTriggerEvent
    ),
    W1A: () => (
      /* reexport */
      EnterViewPortEvent
    ),
    JHW: () => (
      /* reexport */
      Entity
    ),
    ZZ$: () => (
      /* reexport */
      EntityEvents
    ),
    v2K: () => (
      /* reexport */
      EntityManager
    ),
    pBf: () => (
      /* reexport */
      EventDispatcher
    ),
    vpe: () => (
      /* reexport */
      EventEmitter2
    ),
    GMl: () => (
      /* reexport */
      EventTypes
    ),
    zW2: () => (
      /* reexport */
      Events_namespaceObject
    ),
    B0K: () => (
      /* reexport */
      ExResponse
    ),
    Nv7: () => (
      /* reexport */
      ExcaliburGraphicsContext2DCanvas
    ),
    C_p: () => (
      /* reexport */
      ExcaliburGraphicsContextWebGL
    ),
    MUA: () => (
      /* reexport */
      ExitTriggerEvent
    ),
    xqU: () => (
      /* reexport */
      ExitViewPortEvent
    ),
    pTp: () => (
      /* reexport */
      Fade
    ),
    vUK: () => (
      /* reexport */
      Flags
    ),
    j9l: () => (
      /* reexport */
      Follow
    ),
    Zxw: () => (
      /* reexport */
      Font
    ),
    v51: () => (
      /* reexport */
      FontCache
    ),
    Hdx: () => (
      /* reexport */
      FontStyle
    ),
    Z$d: () => (
      /* reexport */
      FontUnit
    ),
    iqV: () => (
      /* reexport */
      FpsSampler
    ),
    o$7: () => (
      /* reexport */
      FrameStats
    ),
    olM: () => (
      /* reexport */
      Future
    ),
    Zm$: () => (
      /* reexport */
      GameEvent
    ),
    $QH: () => (
      /* reexport */
      GameStartEvent
    ),
    i78: () => (
      /* reexport */
      GameStopEvent
    ),
    nJg: () => (
      /* reexport */
      Gamepad
    ),
    h6u: () => (
      /* reexport */
      GamepadAxisEvent
    ),
    hts: () => (
      /* reexport */
      GamepadButtonEvent
    ),
    j88: () => (
      /* reexport */
      GamepadConnectEvent
    ),
    VME: () => (
      /* reexport */
      GamepadDisconnectEvent
    ),
    fy2: () => (
      /* reexport */
      Gamepads
    ),
    nt: () => (
      /* reexport */
      Gif
    ),
    Ukr: () => (
      /* reexport */
      GlobalCoordinates
    ),
    zsu: () => (
      /* reexport */
      Graphic
    ),
    oA6: () => (
      /* reexport */
      GraphicsComponent
    ),
    TVh: () => (
      /* reexport */
      GraphicsGroup
    ),
    TwZ: () => (
      /* reexport */
      GraphicsLayer
    ),
    GTT: () => (
      /* reexport */
      GraphicsLayers
    ),
    xxj: () => (
      /* reexport */
      GraphicsSystem
    ),
    XdK: () => (
      /* reexport */
      HiddenEvent
    ),
    Jmb: () => (
      /* reexport */
      ImageFiltering
    ),
    cXo: () => (
      /* reexport */
      ImageSource
    ),
    Dm5: () => (
      /* reexport */
      InitializeEvent
    ),
    IIB: () => (
      /* reexport */
      Input_Index_namespaceObject
    ),
    ebW: () => (
      /* reexport */
      InputMapper
    ),
    zI0: () => (
      /* reexport */
      Integrator
    ),
    LYD: () => (
      /* reexport */
      IsometricEntityComponent
    ),
    cEG: () => (
      /* reexport */
      IsometricEntitySystem
    ),
    SEl: () => (
      /* reexport */
      IsometricMap
    ),
    t9V: () => (
      /* reexport */
      IsometricTile
    ),
    ez5: () => (
      /* reexport */
      KeyEvent
    ),
    N1d: () => (
      /* reexport */
      Keyboard
    ),
    R8U: () => (
      /* reexport */
      Keys
    ),
    SKZ: () => (
      /* reexport */
      KillEvent
    ),
    __J: () => (
      /* reexport */
      Label
    ),
    RI$: () => (
      /* reexport */
      LimitCameraBoundsStrategy
    ),
    x12: () => (
      /* reexport */
      Line
    ),
    ccz: () => (
      /* reexport */
      LineSegment
    ),
    aNw: () => (
      /* reexport */
      Loader
    ),
    XrL: () => (
      /* reexport */
      LoaderEvents
    ),
    xwn: () => (
      /* reexport */
      LockCameraToActorAxisStrategy
    ),
    dNK: () => (
      /* reexport */
      LockCameraToActorStrategy
    ),
    ini: () => (
      /* reexport */
      LogLevel
    ),
    YdH: () => (
      /* reexport */
      Logger2
    ),
    F5T: () => (
      /* reexport */
      Material
    ),
    y3G: () => (
      /* reexport */
      Matrix
    ),
    l57: () => (
      /* reexport */
      MatrixLocations
    ),
    xn0: () => (
      /* reexport */
      MediaEvent
    ),
    t2V: () => (
      /* reexport */
      Meet
    ),
    uxB: () => (
      /* reexport */
      MotionComponent
    ),
    cpd: () => (
      /* reexport */
      MotionSystem
    ),
    fiy: () => (
      /* reexport */
      MoveBy
    ),
    $XZ: () => (
      /* reexport */
      MoveTo
    ),
    UG6: () => (
      /* reexport */
      NativePointerButton
    ),
    uqK: () => (
      /* reexport */
      NativeSoundEvent
    ),
    STE: () => (
      /* reexport */
      NativeSoundProcessedEvent
    ),
    y$z: () => (
      /* reexport */
      Observable
    ),
    mAD: () => (
      /* reexport */
      OffscreenSystem
    ),
    sOq: () => (
      /* reexport */
      Pair
    ),
    hUw: () => (
      /* reexport */
      ParallaxComponent
    ),
    _0G: () => (
      /* reexport */
      ParallelActions
    ),
    Sqs: () => (
      /* reexport */
      ParseGif
    ),
    hpZ: () => (
      /* reexport */
      Particle
    ),
    Vol: () => (
      /* reexport */
      ParticleEmitter
    ),
    vYX: () => (
      /* reexport */
      ParticleTransform
    ),
    wIZ: () => (
      /* reexport */
      Physics
    ),
    cBi: () => (
      /* reexport */
      PhysicsStats
    ),
    c30: () => (
      /* reexport */
      PhysicsWorld
    ),
    MPV: () => (
      /* reexport */
      PointerButton
    ),
    RFv: () => (
      /* reexport */
      PointerComponent
    ),
    Ux6: () => (
      /* reexport */
      PointerEvent2
    ),
    rxy: () => (
      /* reexport */
      PointerEventReceiver
    ),
    I$c: () => (
      /* reexport */
      PointerScope
    ),
    kfC: () => (
      /* reexport */
      PointerSystem
    ),
    VjY: () => (
      /* reexport */
      PointerType
    ),
    mgq: () => (
      /* reexport */
      Polygon
    ),
    YVA: () => (
      /* reexport */
      PolygonCollider
    ),
    Kgp: () => (
      /* reexport */
      Pool
    ),
    HH$: () => (
      /* reexport */
      PostCollisionEvent
    ),
    M_d: () => (
      /* reexport */
      PostDebugDrawEvent
    ),
    rgh: () => (
      /* reexport */
      PostDrawEvent
    ),
    Ra6: () => (
      /* reexport */
      PostFrameEvent
    ),
    KhR: () => (
      /* reexport */
      PostKillEvent
    ),
    BS5: () => (
      /* reexport */
      PostUpdateEvent
    ),
    xhz: () => (
      /* reexport */
      PreCollisionEvent
    ),
    xOq: () => (
      /* reexport */
      PreDebugDrawEvent
    ),
    a9j: () => (
      /* reexport */
      PreDrawEvent
    ),
    bHk: () => (
      /* reexport */
      PreFrameEvent
    ),
    CgK: () => (
      /* reexport */
      PreKillEvent
    ),
    cuY: () => (
      /* reexport */
      PreUpdateEvent
    ),
    kvE: () => (
      /* reexport */
      Projection
    ),
    SBu: () => (
      /* reexport */
      QuadIndexBuffer
    ),
    AE_: () => (
      /* reexport */
      Query
    ),
    ctO: () => (
      /* reexport */
      QueryManager
    ),
    OLH: () => (
      /* reexport */
      RadiusAroundActorStrategy
    ),
    kky: () => (
      /* reexport */
      Random
    ),
    nSF: () => (
      /* reexport */
      Raster
    ),
    zHn: () => (
      /* reexport */
      Ray
    ),
    zwx: () => (
      /* reexport */
      RealisticSolver
    ),
    AeJ: () => (
      /* reexport */
      Rectangle
    ),
    hLz: () => (
      /* reexport */
      RemovedComponent
    ),
    D9g: () => (
      /* reexport */
      RemovedEntity
    ),
    wA: () => (
      /* reexport */
      Repeat
    ),
    jhr: () => (
      /* reexport */
      RepeatForever
    ),
    GVs: () => (
      /* reexport */
      Resolution
    ),
    _zO: () => (
      /* reexport */
      Resource
    ),
    LXZ: () => (
      /* reexport */
      ResourceEvents
    ),
    w6$: () => (
      /* reexport */
      RotateBy
    ),
    mhV: () => (
      /* reexport */
      RotateTo
    ),
    MOD: () => (
      /* reexport */
      RotationType
    ),
    kwd: () => (
      /* reexport */
      ScaleBy
    ),
    Lmr: () => (
      /* reexport */
      ScaleTo
    ),
    xsS: () => (
      /* reexport */
      Scene
    ),
    K5l: () => (
      /* reexport */
      SceneEvents
    ),
    lLr: () => (
      /* reexport */
      Screen
    ),
    Z$r: () => (
      /* reexport */
      ScreenAppender
    ),
    IXb: () => (
      /* reexport */
      ScreenElement
    ),
    SGH: () => (
      /* reexport */
      ScreenShader
    ),
    SMj: () => (
      /* reexport */
      ScrollPreventionMode
    ),
    L34: () => (
      /* reexport */
      Semaphore
    ),
    exe: () => (
      /* reexport */
      Shader
    ),
    bnF: () => (
      /* reexport */
      Shape
    ),
    MFA: () => (
      /* reexport */
      Side
    ),
    $uU: () => (
      /* reexport */
      Sound
    ),
    Sap: () => (
      /* reexport */
      SoundEvents
    ),
    jyi: () => (
      /* reexport */
      Sprite
    ),
    E03: () => (
      /* reexport */
      SpriteFont
    ),
    V6q: () => (
      /* reexport */
      SpriteSheet
    ),
    rg2: () => (
      /* reexport */
      StandardClock
    ),
    DVW: () => (
      /* reexport */
      StateMachine
    ),
    nVo: () => (
      /* reexport */
      StrategyContainer
    ),
    F6N: () => (
      /* reexport */
      Stream
    ),
    xP7: () => (
      /* reexport */
      System
    ),
    Odq: () => (
      /* reexport */
      SystemManager
    ),
    Zif: () => (
      /* reexport */
      SystemType
    ),
    ZGJ: () => (
      /* reexport */
      TagComponent
    ),
    MJk: () => (
      /* reexport */
      TestClock
    ),
    xvT: () => (
      /* reexport */
      Text
    ),
    PHM: () => (
      /* reexport */
      TextAlign
    ),
    dpR: () => (
      /* reexport */
      TextureLoader
    ),
    n9L: () => (
      /* reexport */
      Tile
    ),
    KwO: () => (
      /* reexport */
      TileMap
    ),
    SxM: () => (
      /* reexport */
      TileMapEvents
    ),
    B7y: () => (
      /* reexport */
      Timer
    ),
    x7r: () => (
      /* reexport */
      Toaster
    ),
    wx7: () => (
      /* reexport */
      Transform
    ),
    Uvn: () => (
      /* reexport */
      TransformComponent
    ),
    OFT: () => (
      /* reexport */
      TreeNode
    ),
    xzN: () => (
      /* reexport */
      Trigger
    ),
    CcZ: () => (
      /* reexport */
      TriggerEvents
    ),
    M5Z: () => (
      /* reexport */
      TwoPI
    ),
    ZrN: () => (
      /* reexport */
      Util_Index_namespaceObject
    ),
    OWs: () => (
      /* reexport */
      Vector
    ),
    dF9: () => (
      /* reexport */
      VectorView
    ),
    oZy: () => (
      /* reexport */
      VertexBuffer
    ),
    rD2: () => (
      /* reexport */
      VertexLayout
    ),
    VHo: () => (
      /* reexport */
      VisibleEvent
    ),
    ohE: () => (
      /* reexport */
      WebAudio
    ),
    R$E: () => (
      /* reexport */
      WebAudioInstance
    ),
    xQN: () => (
      /* reexport */
      WheelDeltaMode
    ),
    AdJ: () => (
      /* reexport */
      WheelEvent
    ),
    q3I: () => (
      /* reexport */
      World
    ),
    Pab: () => (
      /* reexport */
      canonicalizeAngle
    ),
    uZ5: () => (
      /* reexport */
      clamp2
    ),
    McK: () => (
      /* reexport */
      createId
    ),
    F9c: () => (
      /* reexport */
      frac
    ),
    k0b: () => (
      /* reexport */
      hasGraphicsTick
    ),
    hnT: () => (
      /* reexport */
      hasOnInitialize
    ),
    RSJ: () => (
      /* reexport */
      hasOnPostUpdate
    ),
    Mku: () => (
      /* reexport */
      hasOnPreUpdate
    ),
    h90: () => (
      /* reexport */
      hasPostDraw
    ),
    rms: () => (
      /* reexport */
      hasPreDraw
    ),
    ErP: () => (
      /* reexport */
      has_initialize
    ),
    aVg: () => (
      /* reexport */
      has_postupdate
    ),
    lPc: () => (
      /* reexport */
      has_preupdate
    ),
    Z8E: () => (
      /* reexport */
      isAddedComponent
    ),
    _N2: () => (
      /* reexport */
      isAddedSystemEntity
    ),
    yFn: () => (
      /* reexport */
      isRemoveSystemEntity
    ),
    lNv: () => (
      /* reexport */
      isRemovedComponent
    ),
    cu9: () => (
      /* reexport */
      isScreenElement
    ),
    MZQ: () => (
      /* reexport */
      maxMessages
    ),
    FUM: () => (
      /* reexport */
      obsolete
    ),
    BxR: () => (
      /* reexport */
      pixelSnapEpsilon
    ),
    vdf: () => (
      /* reexport */
      randomInRange
    ),
    iaL: () => (
      /* reexport */
      randomIntInRange
    ),
    w6H: () => (
      /* reexport */
      range
    ),
    Q4c: () => (
      /* reexport */
      resetObsoleteCounter
    ),
    Xxe: () => (
      /* reexport */
      sign
    ),
    Uxb: () => (
      /* reexport */
      toDegrees
    ),
    Yr5: () => (
      /* reexport */
      toRadians
    ),
    Bhw: () => (
      /* reexport */
      vec
    ),
    yOA: () => (
      /* reexport */
      webgl_util_namespaceObject
    )
  });
  var Events_namespaceObject = {};
  __webpack_require__.r(Events_namespaceObject);
  __webpack_require__.d(Events_namespaceObject, {
    ActivateEvent: () => ActivateEvent,
    CollisionEndEvent: () => CollisionEndEvent,
    CollisionPostSolveEvent: () => CollisionPostSolveEvent,
    CollisionPreSolveEvent: () => CollisionPreSolveEvent,
    CollisionStartEvent: () => CollisionStartEvent,
    ContactEndEvent: () => ContactEndEvent,
    ContactStartEvent: () => ContactStartEvent,
    DeactivateEvent: () => DeactivateEvent,
    EnterTriggerEvent: () => EnterTriggerEvent,
    EnterViewPortEvent: () => EnterViewPortEvent,
    EventTypes: () => EventTypes,
    ExitTriggerEvent: () => ExitTriggerEvent,
    ExitViewPortEvent: () => ExitViewPortEvent,
    GameEvent: () => GameEvent,
    GameStartEvent: () => GameStartEvent,
    GameStopEvent: () => GameStopEvent,
    GamepadAxisEvent: () => GamepadAxisEvent,
    GamepadButtonEvent: () => GamepadButtonEvent,
    GamepadConnectEvent: () => GamepadConnectEvent,
    GamepadDisconnectEvent: () => GamepadDisconnectEvent,
    HiddenEvent: () => HiddenEvent,
    InitializeEvent: () => InitializeEvent,
    KillEvent: () => KillEvent,
    PostCollisionEvent: () => PostCollisionEvent,
    PostDebugDrawEvent: () => PostDebugDrawEvent,
    PostDrawEvent: () => PostDrawEvent,
    PostFrameEvent: () => PostFrameEvent,
    PostKillEvent: () => PostKillEvent,
    PostUpdateEvent: () => PostUpdateEvent,
    PreCollisionEvent: () => PreCollisionEvent,
    PreDebugDrawEvent: () => PreDebugDrawEvent,
    PreDrawEvent: () => PreDrawEvent,
    PreFrameEvent: () => PreFrameEvent,
    PreKillEvent: () => PreKillEvent,
    PreUpdateEvent: () => PreUpdateEvent,
    VisibleEvent: () => VisibleEvent
  });
  var webgl_util_namespaceObject = {};
  __webpack_require__.r(webgl_util_namespaceObject);
  __webpack_require__.d(webgl_util_namespaceObject, {
    getAttributeComponentSize: () => getAttributeComponentSize,
    getAttributePointerType: () => getAttributePointerType,
    getGlTypeSizeBytes: () => getGlTypeSizeBytes
  });
  var DrawUtil_namespaceObject = {};
  __webpack_require__.r(DrawUtil_namespaceObject);
  __webpack_require__.d(DrawUtil_namespaceObject, {
    circle: () => circle,
    line: () => line,
    point: () => point,
    roundRect: () => roundRect,
    vector: () => vector
  });
  var Input_Index_namespaceObject = {};
  __webpack_require__.r(Input_Index_namespaceObject);
  __webpack_require__.d(Input_Index_namespaceObject, {
    Axes: () => Axes,
    Buttons: () => Buttons,
    Gamepad: () => Gamepad,
    Gamepads: () => Gamepads,
    KeyEvent: () => KeyEvent,
    Keyboard: () => Keyboard,
    Keys: () => Keys,
    NativePointerButton: () => NativePointerButton,
    PointerButton: () => PointerButton,
    PointerComponent: () => PointerComponent,
    PointerEvent: () => PointerEvent2,
    PointerEventReceiver: () => PointerEventReceiver,
    PointerScope: () => PointerScope,
    PointerSystem: () => PointerSystem,
    PointerType: () => PointerType,
    WheelDeltaMode: () => WheelDeltaMode,
    WheelEvent: () => WheelEvent
  });
  var Util_Index_namespaceObject = {};
  __webpack_require__.r(Util_Index_namespaceObject);
  __webpack_require__.d(Util_Index_namespaceObject, {
    ConsoleAppender: () => ConsoleAppender,
    DrawUtil: () => DrawUtil_namespaceObject,
    EasingFunctions: () => EasingFunctions,
    LogLevel: () => LogLevel,
    Logger: () => Logger2,
    Observable: () => Observable,
    ScreenAppender: () => ScreenAppender,
    addItemToArray: () => addItemToArray,
    contains: () => contains,
    delay: () => delay2,
    fail: () => fail,
    getPosition: () => getPosition,
    removeItemFromArray: () => removeItemFromArray
  });
  __webpack_require__(4662);
  __webpack_require__(8343);
  function polyfill2() {
    if (typeof window === "undefined") {
      window = {
        audioContext: function() {
          return;
        }
      };
    }
    if (typeof window !== "undefined" && !window.requestAnimationFrame) {
      window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
        window.setInterval(callback, 1e3 / 60);
      };
    }
    if (typeof window !== "undefined" && !window.cancelAnimationFrame) {
      window.cancelAnimationFrame = window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function() {
        return;
      };
    }
    if (typeof window !== "undefined" && !window.AudioContext) {
      if (window.webkitAudioContext) {
        const ctx = window.webkitAudioContext;
        const replaceMe = ctx.prototype.decodeAudioData;
        window.webkitAudioContext.prototype.decodeAudioData = function(arrayBuffer) {
          return new Promise((resolve, reject) => {
            replaceMe.call(this, arrayBuffer, resolve, reject);
          });
        };
      }
      window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext || window.oAudioContext;
    }
    if (typeof window !== "undefined" && !window.devicePixelRatio) {
      window.devicePixelRatio = window.devicePixelRatio || 1;
    }
  }
  class Flags {
    /**
     * Force excalibur to load the Canvas 2D graphics context fallback
     *
     * @warning not all features of excalibur are supported in the Canvas 2D fallback
     */
    static useCanvasGraphicsContext() {
      Flags.enable("use-canvas-context");
    }
    /**
     * Freeze all flag modifications making them readonly
     */
    static freeze() {
      Flags._FROZEN = true;
    }
    /**
     * Resets internal flag state, not meant to be called by users. Only used for testing.
     *
     * Calling this in your game is UNSUPPORTED
     * @internal
     */
    static _reset() {
      Flags._FROZEN = false;
      Flags._FLAGS = {};
    }
    /**
     * Enable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**
     * @param flagName
     */
    static enable(flagName) {
      if (this._FROZEN) {
        throw Error("Feature flags can only be enabled before Engine constructor time");
      }
      Flags._FLAGS[flagName] = true;
    }
    /**
     * Disable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**
     * @param flagName
     */
    static disable(flagName) {
      if (this._FROZEN) {
        throw Error("Feature flags can only be disabled before Engine constructor time");
      }
      Flags._FLAGS[flagName] = false;
    }
    /**
     * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned
     * @param flagName
     */
    static isEnabled(flagName) {
      return !!Flags._FLAGS[flagName];
    }
    /**
     * Show a list of currently known flags
     */
    static show() {
      return Object.keys(Flags._FLAGS);
    }
  }
  Flags._FROZEN = false;
  Flags._FLAGS = {};
  function createId(type, value) {
    return { type, value };
  }
  class EventEmitter2 {
    constructor() {
      this._paused = false;
      this._listeners = {};
      this._listenersOnce = {};
      this._pipes = [];
    }
    clear() {
      this._listeners = {};
      this._listenersOnce = {};
      this._pipes.length = 0;
    }
    on(eventName, handler) {
      var _a;
      this._listeners[eventName] = (_a = this._listeners[eventName]) !== null && _a !== void 0 ? _a : [];
      this._listeners[eventName].push(handler);
      return {
        close: () => this.off(eventName, handler)
      };
    }
    once(eventName, handler) {
      var _a;
      this._listenersOnce[eventName] = (_a = this._listenersOnce[eventName]) !== null && _a !== void 0 ? _a : [];
      this._listenersOnce[eventName].push(handler);
      return {
        close: () => this.off(eventName, handler)
      };
    }
    off(eventName, handler) {
      var _a, _b, _c, _d;
      if (handler) {
        const listenerIndex = (_a = this._listeners[eventName]) === null || _a === void 0 ? void 0 : _a.indexOf(handler);
        if (listenerIndex > -1) {
          (_b = this._listeners[eventName]) === null || _b === void 0 ? void 0 : _b.splice(listenerIndex, 1);
        }
        const onceIndex = (_c = this._listenersOnce[eventName]) === null || _c === void 0 ? void 0 : _c.indexOf(handler);
        if (onceIndex > -1) {
          (_d = this._listenersOnce[eventName]) === null || _d === void 0 ? void 0 : _d.splice(onceIndex, 1);
        }
      } else {
        delete this._listeners[eventName];
      }
    }
    emit(eventName, event) {
      var _a;
      if (this._paused) {
        return;
      }
      (_a = this._listeners[eventName]) === null || _a === void 0 ? void 0 : _a.forEach((fn) => fn(event));
      const onces = this._listenersOnce[eventName];
      this._listenersOnce[eventName] = [];
      if (onces) {
        onces.forEach((fn) => fn(event));
      }
      this._pipes.forEach((pipe2) => {
        pipe2.emit(eventName, event);
      });
    }
    pipe(emitter) {
      if (this === emitter) {
        throw Error("Cannot pipe to self");
      }
      this._pipes.push(emitter);
      return {
        close: () => {
          const i2 = this._pipes.indexOf(emitter);
          if (i2 > -1) {
            this._pipes.splice(i2, 1);
          }
        }
      };
    }
    unpipe(emitter) {
      const i2 = this._pipes.indexOf(emitter);
      if (i2 > -1) {
        this._pipes.splice(i2, 1);
      }
    }
    pause() {
      this._paused = true;
    }
    unpause() {
      this._paused = false;
    }
  }
  var EventTypes;
  (function(EventTypes2) {
    EventTypes2["Kill"] = "kill";
    EventTypes2["PreKill"] = "prekill";
    EventTypes2["PostKill"] = "postkill";
    EventTypes2["PreDraw"] = "predraw";
    EventTypes2["PostDraw"] = "postdraw";
    EventTypes2["PreDebugDraw"] = "predebugdraw";
    EventTypes2["PostDebugDraw"] = "postdebugdraw";
    EventTypes2["PreUpdate"] = "preupdate";
    EventTypes2["PostUpdate"] = "postupdate";
    EventTypes2["PreFrame"] = "preframe";
    EventTypes2["PostFrame"] = "postframe";
    EventTypes2["PreCollision"] = "precollision";
    EventTypes2["CollisionStart"] = "collisionstart";
    EventTypes2["CollisionEnd"] = "collisionend";
    EventTypes2["PostCollision"] = "postcollision";
    EventTypes2["Initialize"] = "initialize";
    EventTypes2["Activate"] = "activate";
    EventTypes2["Deactivate"] = "deactivate";
    EventTypes2["ExitViewport"] = "exitviewport";
    EventTypes2["EnterViewport"] = "enterviewport";
    EventTypes2["ExitTrigger"] = "exit";
    EventTypes2["EnterTrigger"] = "enter";
    EventTypes2["Connect"] = "connect";
    EventTypes2["Disconnect"] = "disconnect";
    EventTypes2["Button"] = "button";
    EventTypes2["Axis"] = "axis";
    EventTypes2["Visible"] = "visible";
    EventTypes2["Hidden"] = "hidden";
    EventTypes2["Start"] = "start";
    EventTypes2["Stop"] = "stop";
    EventTypes2["PointerUp"] = "pointerup";
    EventTypes2["PointerDown"] = "pointerdown";
    EventTypes2["PointerMove"] = "pointermove";
    EventTypes2["PointerEnter"] = "pointerenter";
    EventTypes2["PointerLeave"] = "pointerleave";
    EventTypes2["PointerCancel"] = "pointercancel";
    EventTypes2["PointerWheel"] = "pointerwheel";
    EventTypes2["Up"] = "up";
    EventTypes2["Down"] = "down";
    EventTypes2["Move"] = "move";
    EventTypes2["Enter"] = "enter";
    EventTypes2["Leave"] = "leave";
    EventTypes2["Cancel"] = "cancel";
    EventTypes2["Wheel"] = "wheel";
    EventTypes2["Press"] = "press";
    EventTypes2["Release"] = "release";
    EventTypes2["Hold"] = "hold";
    EventTypes2["PointerDragStart"] = "pointerdragstart";
    EventTypes2["PointerDragEnd"] = "pointerdragend";
    EventTypes2["PointerDragEnter"] = "pointerdragenter";
    EventTypes2["PointerDragLeave"] = "pointerdragleave";
    EventTypes2["PointerDragMove"] = "pointerdragmove";
  })(EventTypes || (EventTypes = {}));
  class GameEvent {
    constructor() {
      this._bubbles = true;
    }
    /**
     * If set to false, prevents event from propagating to other actors. If true it will be propagated
     * to all actors that apply.
     */
    get bubbles() {
      return this._bubbles;
    }
    set bubbles(value) {
      this._bubbles = value;
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
      this.bubbles = false;
    }
  }
  class KillEvent extends GameEvent {
    constructor(target) {
      super();
      this.target = target;
    }
  }
  class PreKillEvent extends GameEvent {
    constructor(target) {
      super();
      this.target = target;
    }
  }
  class PostKillEvent extends GameEvent {
    constructor(target) {
      super();
      this.target = target;
    }
  }
  class GameStartEvent extends GameEvent {
    constructor(target) {
      super();
      this.target = target;
    }
  }
  class GameStopEvent extends GameEvent {
    constructor(target) {
      super();
      this.target = target;
    }
  }
  class PreDrawEvent extends GameEvent {
    constructor(ctx, delta, target) {
      super();
      this.ctx = ctx;
      this.delta = delta;
      this.target = target;
    }
  }
  class PostDrawEvent extends GameEvent {
    constructor(ctx, delta, target) {
      super();
      this.ctx = ctx;
      this.delta = delta;
      this.target = target;
    }
  }
  class PreDebugDrawEvent extends GameEvent {
    constructor(ctx, target) {
      super();
      this.ctx = ctx;
      this.target = target;
    }
  }
  class PostDebugDrawEvent extends GameEvent {
    constructor(ctx, target) {
      super();
      this.ctx = ctx;
      this.target = target;
    }
  }
  class PreUpdateEvent extends GameEvent {
    constructor(engine, delta, target) {
      super();
      this.engine = engine;
      this.delta = delta;
      this.target = target;
    }
  }
  class PostUpdateEvent extends GameEvent {
    constructor(engine, delta, target) {
      super();
      this.engine = engine;
      this.delta = delta;
      this.target = target;
    }
  }
  class PreFrameEvent extends GameEvent {
    constructor(engine, prevStats) {
      super();
      this.engine = engine;
      this.prevStats = prevStats;
      this.target = engine;
    }
  }
  class PostFrameEvent extends GameEvent {
    constructor(engine, stats) {
      super();
      this.engine = engine;
      this.stats = stats;
      this.target = engine;
    }
  }
  class GamepadConnectEvent extends GameEvent {
    constructor(index, gamepad) {
      super();
      this.index = index;
      this.gamepad = gamepad;
      this.target = gamepad;
    }
  }
  class GamepadDisconnectEvent extends GameEvent {
    constructor(index, gamepad) {
      super();
      this.index = index;
      this.gamepad = gamepad;
      this.target = gamepad;
    }
  }
  class GamepadButtonEvent extends GameEvent {
    /**
     * @param button  The Gamepad button
     * @param value   A numeric value between 0 and 1
     */
    constructor(button, value, target) {
      super();
      this.button = button;
      this.value = value;
      this.target = target;
    }
  }
  class GamepadAxisEvent extends GameEvent {
    /**
     * @param axis  The Gamepad axis
     * @param value A numeric value between -1 and 1
     */
    constructor(axis, value, target) {
      super();
      this.axis = axis;
      this.value = value;
      this.target = target;
    }
  }
  class VisibleEvent extends GameEvent {
    constructor(target) {
      super();
      this.target = target;
    }
  }
  class HiddenEvent extends GameEvent {
    constructor(target) {
      super();
      this.target = target;
    }
  }
  class PreCollisionEvent extends GameEvent {
    /**
     * @param actor         The actor the event was thrown on
     * @param other         The actor that will collided with the current actor
     * @param side          The side that will be collided with the current actor
     * @param intersection  Intersection vector
     */
    constructor(actor, other, side, intersection) {
      super();
      this.other = other;
      this.side = side;
      this.intersection = intersection;
      this.target = actor;
    }
  }
  class PostCollisionEvent extends GameEvent {
    /**
     * @param actor         The actor the event was thrown on
     * @param other         The actor that did collide with the current actor
     * @param side          The side that did collide with the current actor
     * @param intersection  Intersection vector
     */
    constructor(actor, other, side, intersection) {
      super();
      this.other = other;
      this.side = side;
      this.intersection = intersection;
      this.target = actor;
    }
    get actor() {
      return this.target;
    }
    set actor(actor) {
      this.target = actor;
    }
  }
  class ContactStartEvent {
    constructor(target, other, contact) {
      this.target = target;
      this.other = other;
      this.contact = contact;
    }
  }
  class ContactEndEvent {
    constructor(target, other) {
      this.target = target;
      this.other = other;
    }
  }
  class CollisionPreSolveEvent {
    constructor(target, other, side, intersection, contact) {
      this.target = target;
      this.other = other;
      this.side = side;
      this.intersection = intersection;
      this.contact = contact;
    }
  }
  class CollisionPostSolveEvent {
    constructor(target, other, side, intersection, contact) {
      this.target = target;
      this.other = other;
      this.side = side;
      this.intersection = intersection;
      this.contact = contact;
    }
  }
  class CollisionStartEvent extends GameEvent {
    /**
     *
     * @param actor
     * @param other
     * @param contact
     */
    constructor(actor, other, contact) {
      super();
      this.other = other;
      this.contact = contact;
      this.target = actor;
    }
    get actor() {
      return this.target;
    }
    set actor(actor) {
      this.target = actor;
    }
  }
  class CollisionEndEvent extends GameEvent {
    /**
     *
     */
    constructor(actor, other) {
      super();
      this.other = other;
      this.target = actor;
    }
    get actor() {
      return this.target;
    }
    set actor(actor) {
      this.target = actor;
    }
  }
  class InitializeEvent extends GameEvent {
    /**
     * @param engine  The reference to the current engine
     */
    constructor(engine, target) {
      super();
      this.engine = engine;
      this.target = target;
    }
  }
  class ActivateEvent extends GameEvent {
    /**
     * @param context  The context for the scene activation
     */
    constructor(context, target) {
      super();
      this.context = context;
      this.target = target;
    }
  }
  class DeactivateEvent extends GameEvent {
    /**
     * @param context  The context for the scene deactivation
     */
    constructor(context, target) {
      super();
      this.context = context;
      this.target = target;
    }
  }
  class ExitViewPortEvent extends GameEvent {
    constructor(target) {
      super();
      this.target = target;
    }
  }
  class EnterViewPortEvent extends GameEvent {
    constructor(target) {
      super();
      this.target = target;
    }
  }
  class EnterTriggerEvent extends GameEvent {
    constructor(target, actor) {
      super();
      this.target = target;
      this.actor = actor;
    }
  }
  class ExitTriggerEvent extends GameEvent {
    constructor(target, actor) {
      super();
      this.target = target;
      this.actor = actor;
    }
  }
  class Gamepads {
    constructor() {
      this.events = new EventEmitter2();
      this.enabled = false;
      this.supported = !!navigator.getGamepads;
      this._gamePadTimeStamps = [0, 0, 0, 0];
      this._oldPads = [];
      this._pads = [];
      this._initSuccess = false;
      this._navigator = navigator;
      this._minimumConfiguration = null;
    }
    init() {
      if (!this.supported) {
        return;
      }
      if (this._initSuccess) {
        return;
      }
      this._oldPads = this._clonePads(this._navigator.getGamepads());
      if (this._oldPads.length && this._oldPads[0]) {
        this._initSuccess = true;
      }
    }
    /**
     * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means
     * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive
     * all other controllers with more axis or buttons are valid as well. If no minimum
     * configuration is set all pads are valid.
     */
    setMinimumGamepadConfiguration(config) {
      this._enableAndUpdate();
      this._minimumConfiguration = config;
    }
    /**
     * When implicitly enabled, set the enabled flag and run an update so information is updated
     */
    _enableAndUpdate() {
      if (!this.enabled) {
        this.enabled = true;
        this.update();
      }
    }
    /**
     * Checks a navigator gamepad against the minimum configuration if present.
     */
    _isGamepadValid(pad) {
      if (!this._minimumConfiguration) {
        return true;
      }
      if (!pad) {
        return false;
      }
      const axesLength = pad.axes.filter((value) => {
        return typeof value !== void 0;
      }).length;
      const buttonLength = pad.buttons.filter((value) => {
        return typeof value !== void 0;
      }).length;
      return axesLength >= this._minimumConfiguration.axis && buttonLength >= this._minimumConfiguration.buttons && pad.connected;
    }
    emit(eventName, event) {
      this.events.emit(eventName, event);
    }
    on(eventName, handler) {
      this._enableAndUpdate();
      return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
      return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
      this._enableAndUpdate();
      this.events.off(eventName, handler);
    }
    /**
     * Updates Gamepad state and publishes Gamepad events
     */
    update() {
      if (!this.enabled || !this.supported) {
        return;
      }
      this.init();
      const gamepads = this._navigator.getGamepads();
      for (let i2 = 0; i2 < gamepads.length; i2++) {
        if (!gamepads[i2]) {
          const gamepad = this.at(i2);
          if (gamepad.connected) {
            this.events.emit("disconnect", new GamepadDisconnectEvent(i2, gamepad));
          }
          gamepad.connected = false;
          continue;
        } else {
          if (!this.at(i2).connected && this._isGamepadValid(gamepads[i2])) {
            this.events.emit("connect", new GamepadConnectEvent(i2, this.at(i2)));
          }
          this.at(i2).connected = true;
        }
        this.at(i2).update();
        if (gamepads[i2].timestamp && gamepads[i2].timestamp === this._gamePadTimeStamps[i2]) {
          continue;
        }
        this._gamePadTimeStamps[i2] = gamepads[i2].timestamp;
        this.at(i2).navigatorGamepad = gamepads[i2];
        let b2, bi2, a2, ai2, value;
        for (b2 in Buttons) {
          bi2 = Buttons[b2];
          if (typeof bi2 === "number") {
            if (gamepads[i2].buttons[bi2]) {
              value = gamepads[i2].buttons[bi2].value;
              if (value !== this._oldPads[i2].getButton(bi2)) {
                if (gamepads[i2].buttons[bi2].pressed) {
                  this.at(i2).updateButton(bi2, value);
                  this.at(i2).events.emit("button", new GamepadButtonEvent(bi2, value, this.at(i2)));
                } else {
                  this.at(i2).updateButton(bi2, 0);
                }
              }
            }
          }
        }
        for (a2 in Axes) {
          ai2 = Axes[a2];
          if (typeof ai2 === "number") {
            value = gamepads[i2].axes[ai2];
            if (value !== this._oldPads[i2].getAxes(ai2)) {
              this.at(i2).updateAxes(ai2, value);
              this.at(i2).events.emit("axis", new GamepadAxisEvent(ai2, value, this.at(i2)));
            }
          }
        }
        this._oldPads[i2] = this._clonePad(gamepads[i2]);
      }
    }
    /**
     * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
     */
    at(index) {
      this._enableAndUpdate();
      if (index >= this._pads.length) {
        for (let i2 = this._pads.length - 1, max = index; i2 < max; i2++) {
          this._pads.push(new Gamepad());
          this._oldPads.push(new Gamepad());
        }
      }
      return this._pads[index];
    }
    /**
     * Returns a list of all valid gamepads that meet the minimum configuration requirement.
     */
    getValidGamepads() {
      this._enableAndUpdate();
      const result = [];
      for (let i2 = 0; i2 < this._pads.length; i2++) {
        if (this._isGamepadValid(this.at(i2).navigatorGamepad) && this.at(i2).connected) {
          result.push(this.at(i2));
        }
      }
      return result;
    }
    /**
     * Gets the number of connected gamepads
     */
    count() {
      return this._pads.filter((p2) => p2.connected).length;
    }
    _clonePads(pads) {
      const arr = [];
      for (let i2 = 0, len = pads.length; i2 < len; i2++) {
        arr.push(this._clonePad(pads[i2]));
      }
      return arr;
    }
    /**
     * Fastest way to clone a known object is to do it yourself
     */
    _clonePad(pad) {
      let i2, len;
      const clonedPad = new Gamepad();
      if (!pad) {
        return clonedPad;
      }
      for (i2 = 0, len = pad.buttons.length; i2 < len; i2++) {
        if (pad.buttons[i2]) {
          clonedPad.updateButton(i2, pad.buttons[i2].value);
        }
      }
      for (i2 = 0, len = pad.axes.length; i2 < len; i2++) {
        clonedPad.updateAxes(i2, pad.axes[i2]);
      }
      return clonedPad;
    }
  }
  Gamepads.MinAxisMoveThreshold = 0.05;
  class Gamepad {
    constructor() {
      this.events = new EventEmitter2();
      this.connected = false;
      this._axes = new Array(4);
      this._buttons = new Array(16);
      this._buttonsUp = new Array(16);
      this._buttonsDown = new Array(16);
      for (let i2 = 0; i2 < this._buttons.length; i2++) {
        this._buttons[i2] = 0;
      }
      for (let i2 = 0; i2 < this._axes.length; i2++) {
        this._axes[i2] = 0;
      }
    }
    update() {
      this._buttonsDown = new Array(16);
      this._buttonsUp = new Array(16);
    }
    /**
     * Whether or not the given button is pressed
     *
     * @deprecated will be removed in v0.28.0. Use isButtonHeld instead
     * @param button     The button to query
     * @param threshold  The threshold over which the button is considered to be pressed
     */
    isButtonPressed(button, threshold = 1) {
      return this._buttons[button] >= threshold;
    }
    /**
     * Tests if a certain button is held down. This is persisted between frames.
     *
     * @param button     The button to query
     * @param threshold  The threshold over which the button is considered to be pressed
     */
    isButtonHeld(button, threshold = 1) {
      return this._buttons[button] >= threshold;
    }
    /**
     * Tests if a certain button was just pressed this frame. This is cleared at the end of the update frame.
     *
     * @param button Test whether a button was just pressed
     * @param threshold  The threshold over which the button is considered to be pressed
     */
    wasButtonPressed(button, threshold = 1) {
      return this._buttonsDown[button] >= threshold;
    }
    /**
     * Tests if a certain button was just released this frame. This is cleared at the end of the update frame.
     *
     * @param button  Test whether a button was just released
     */
    wasButtonReleased(button) {
      return Boolean(this._buttonsUp[button]);
    }
    /**
     * Gets the given button value between 0 and 1
     */
    getButton(button) {
      return this._buttons[button];
    }
    /**
     * Gets the given axis value between -1 and 1. Values below
     * [[MinAxisMoveThreshold]] are considered 0.
     */
    getAxes(axes) {
      const value = this._axes[axes];
      if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
        return 0;
      } else {
        return value;
      }
    }
    updateButton(buttonIndex, value) {
      if (value === 0 && this._buttons[buttonIndex]) {
        this._buttonsUp[buttonIndex] = 1;
      } else {
        this._buttonsDown[buttonIndex] = value;
      }
      this._buttons[buttonIndex] = value;
    }
    updateAxes(axesIndex, value) {
      this._axes[axesIndex] = value;
    }
    emit(eventName, event) {
      this.events.emit(eventName, event);
    }
    on(eventName, handler) {
      return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
      return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
      this.events.off(eventName, handler);
    }
  }
  var Buttons;
  (function(Buttons2) {
    Buttons2[Buttons2["Face1"] = 0] = "Face1";
    Buttons2[Buttons2["Face2"] = 1] = "Face2";
    Buttons2[Buttons2["Face3"] = 2] = "Face3";
    Buttons2[Buttons2["Face4"] = 3] = "Face4";
    Buttons2[Buttons2["LeftBumper"] = 4] = "LeftBumper";
    Buttons2[Buttons2["RightBumper"] = 5] = "RightBumper";
    Buttons2[Buttons2["LeftTrigger"] = 6] = "LeftTrigger";
    Buttons2[Buttons2["RightTrigger"] = 7] = "RightTrigger";
    Buttons2[Buttons2["Select"] = 8] = "Select";
    Buttons2[Buttons2["Start"] = 9] = "Start";
    Buttons2[Buttons2["LeftStick"] = 10] = "LeftStick";
    Buttons2[Buttons2["RightStick"] = 11] = "RightStick";
    Buttons2[Buttons2["DpadUp"] = 12] = "DpadUp";
    Buttons2[Buttons2["DpadDown"] = 13] = "DpadDown";
    Buttons2[Buttons2["DpadLeft"] = 14] = "DpadLeft";
    Buttons2[Buttons2["DpadRight"] = 15] = "DpadRight";
  })(Buttons || (Buttons = {}));
  var Axes;
  (function(Axes2) {
    Axes2[Axes2["LeftStickX"] = 0] = "LeftStickX";
    Axes2[Axes2["LeftStickY"] = 1] = "LeftStickY";
    Axes2[Axes2["RightStickX"] = 2] = "RightStickX";
    Axes2[Axes2["RightStickY"] = 3] = "RightStickY";
  })(Axes || (Axes = {}));
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2[LogLevel2["Debug"] = 0] = "Debug";
    LogLevel2[LogLevel2["Info"] = 1] = "Info";
    LogLevel2[LogLevel2["Warn"] = 2] = "Warn";
    LogLevel2[LogLevel2["Error"] = 3] = "Error";
    LogLevel2[LogLevel2["Fatal"] = 4] = "Fatal";
  })(LogLevel || (LogLevel = {}));
  class Logger2 {
    constructor() {
      this._appenders = [];
      this.defaultLevel = LogLevel.Info;
      if (Logger2._INSTANCE) {
        throw new Error("Logger is a singleton");
      }
      Logger2._INSTANCE = this;
      Logger2._INSTANCE.addAppender(new ConsoleAppender());
      return Logger2._INSTANCE;
    }
    /**
     * Gets the current static instance of Logger
     */
    static getInstance() {
      if (Logger2._INSTANCE == null) {
        Logger2._INSTANCE = new Logger2();
      }
      return Logger2._INSTANCE;
    }
    /**
     * Adds a new [[Appender]] to the list of appenders to write to
     */
    addAppender(appender) {
      this._appenders.push(appender);
    }
    /**
     * Clears all appenders from the logger
     */
    clearAppenders() {
      this._appenders.length = 0;
    }
    /**
     * Logs a message at a given LogLevel
     * @param level  The LogLevel`to log the message at
     * @param args   An array of arguments to write to an appender
     */
    _log(level, args) {
      if (level == null) {
        level = this.defaultLevel;
      }
      const len = this._appenders.length;
      for (let i2 = 0; i2 < len; i2++) {
        if (level >= this.defaultLevel) {
          this._appenders[i2].log(level, args);
        }
      }
    }
    /**
     * Writes a log message at the [[LogLevel.Debug]] level
     * @param args  Accepts any number of arguments
     */
    debug(...args) {
      this._log(LogLevel.Debug, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Info]] level
     * @param args  Accepts any number of arguments
     */
    info(...args) {
      this._log(LogLevel.Info, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Warn]] level
     * @param args  Accepts any number of arguments
     */
    warn(...args) {
      this._log(LogLevel.Warn, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Error]] level
     * @param args  Accepts any number of arguments
     */
    error(...args) {
      this._log(LogLevel.Error, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Fatal]] level
     * @param args  Accepts any number of arguments
     */
    fatal(...args) {
      this._log(LogLevel.Fatal, args);
    }
  }
  Logger2._INSTANCE = null;
  class ConsoleAppender {
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
      if (!console && !console.log && console.warn && console.error) {
        return;
      }
      const consoleArgs = [];
      consoleArgs.unshift.apply(consoleArgs, args);
      consoleArgs.unshift("[" + LogLevel[level] + "] : ");
      if (level < LogLevel.Warn) {
        if (console.log.apply) {
          console.log.apply(console, consoleArgs);
        } else {
          console.log(consoleArgs.join(" "));
        }
      } else if (level < LogLevel.Error) {
        if (console.warn.apply) {
          console.warn.apply(console, consoleArgs);
        } else {
          console.warn(consoleArgs.join(" "));
        }
      } else {
        if (console.error.apply) {
          console.error.apply(console, consoleArgs);
        } else {
          console.error(consoleArgs.join(" "));
        }
      }
    }
  }
  class ScreenAppender {
    /**
     * @param width   Width of the screen appender in pixels
     * @param height  Height of the screen appender in pixels
     */
    constructor(width, height) {
      this._messages = [];
      this._canvas = document.createElement("canvas");
      this._canvas.width = width || window.innerWidth;
      this._canvas.height = height || window.innerHeight;
      this._canvas.style.position = "absolute";
      this._ctx = this._canvas.getContext("2d");
      document.body.appendChild(this._canvas);
    }
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
      const message = args.join(",");
      this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
      this._messages.unshift("[" + LogLevel[level] + "] : " + message);
      let pos = 10;
      let opacity = 1;
      for (let i2 = 0; i2 < this._messages.length; i2++) {
        this._ctx.fillStyle = "rgba(255,255,255," + opacity.toFixed(2) + ")";
        this._ctx.fillText(this._messages[i2], 200, pos);
        pos += 10;
        opacity = opacity > 0 ? opacity - 0.05 : 0;
      }
    }
  }
  function isCrossOriginIframe() {
    try {
      const noop2 = () => {
        return;
      };
      window.top.addEventListener("blur", noop2);
      window.top.removeEventListener("blur", noop2);
    } catch (_a) {
      return true;
    }
    return false;
  }
  var Keys;
  (function(Keys2) {
    Keys2["Num0"] = "Numpad0";
    Keys2["Num1"] = "Numpad1";
    Keys2["Num2"] = "Numpad2";
    Keys2["Num3"] = "Numpad3";
    Keys2["Num4"] = "Numpad4";
    Keys2["Num5"] = "Numpad5";
    Keys2["Num6"] = "Numpad6";
    Keys2["Num7"] = "Numpad7";
    Keys2["Num8"] = "Numpad8";
    Keys2["Num9"] = "Numpad9";
    Keys2["NumAdd"] = "NumpadAdd";
    Keys2["NumSubtract"] = "NumpadSubtract";
    Keys2["NumMultiply"] = "NumpadMultiply";
    Keys2["NumDivide"] = "NumpadDivide";
    Keys2["NumDecimal"] = "NumpadDecimal";
    Keys2["Numpad0"] = "Numpad0";
    Keys2["Numpad1"] = "Numpad1";
    Keys2["Numpad2"] = "Numpad2";
    Keys2["Numpad3"] = "Numpad3";
    Keys2["Numpad4"] = "Numpad4";
    Keys2["Numpad5"] = "Numpad5";
    Keys2["Numpad6"] = "Numpad6";
    Keys2["Numpad7"] = "Numpad7";
    Keys2["Numpad8"] = "Numpad8";
    Keys2["Numpad9"] = "Numpad9";
    Keys2["NumpadAdd"] = "NumpadAdd";
    Keys2["NumpadSubtract"] = "NumpadSubtract";
    Keys2["NumpadMultiply"] = "NumpadMultiply";
    Keys2["NumpadDivide"] = "NumpadDivide";
    Keys2["NumpadDecimal"] = "NumpadDecimal";
    Keys2["NumLock"] = "NumLock";
    Keys2["ShiftLeft"] = "ShiftLeft";
    Keys2["ShiftRight"] = "ShiftRight";
    Keys2["AltLeft"] = "AltLeft";
    Keys2["AltRight"] = "AltRight";
    Keys2["ControlLeft"] = "ControlLeft";
    Keys2["ControlRight"] = "ControlRight";
    Keys2["MetaLeft"] = "MetaLeft";
    Keys2["MetaRight"] = "MetaRight";
    Keys2["Key0"] = "Digit0";
    Keys2["Key1"] = "Digit1";
    Keys2["Key2"] = "Digit2";
    Keys2["Key3"] = "Digit3";
    Keys2["Key4"] = "Digit4";
    Keys2["Key5"] = "Digit5";
    Keys2["Key6"] = "Digit6";
    Keys2["Key7"] = "Digit7";
    Keys2["Key8"] = "Digit8";
    Keys2["Key9"] = "Digit9";
    Keys2["Digit0"] = "Digit0";
    Keys2["Digit1"] = "Digit1";
    Keys2["Digit2"] = "Digit2";
    Keys2["Digit3"] = "Digit3";
    Keys2["Digit4"] = "Digit4";
    Keys2["Digit5"] = "Digit5";
    Keys2["Digit6"] = "Digit6";
    Keys2["Digit7"] = "Digit7";
    Keys2["Digit8"] = "Digit8";
    Keys2["Digit9"] = "Digit9";
    Keys2["F1"] = "F1";
    Keys2["F2"] = "F2";
    Keys2["F3"] = "F3";
    Keys2["F4"] = "F4";
    Keys2["F5"] = "F5";
    Keys2["F6"] = "F6";
    Keys2["F7"] = "F7";
    Keys2["F8"] = "F8";
    Keys2["F9"] = "F9";
    Keys2["F10"] = "F10";
    Keys2["F11"] = "F11";
    Keys2["F12"] = "F12";
    Keys2["A"] = "KeyA";
    Keys2["B"] = "KeyB";
    Keys2["C"] = "KeyC";
    Keys2["D"] = "KeyD";
    Keys2["E"] = "KeyE";
    Keys2["F"] = "KeyF";
    Keys2["G"] = "KeyG";
    Keys2["H"] = "KeyH";
    Keys2["I"] = "KeyI";
    Keys2["J"] = "KeyJ";
    Keys2["K"] = "KeyK";
    Keys2["L"] = "KeyL";
    Keys2["M"] = "KeyM";
    Keys2["N"] = "KeyN";
    Keys2["O"] = "KeyO";
    Keys2["P"] = "KeyP";
    Keys2["Q"] = "KeyQ";
    Keys2["R"] = "KeyR";
    Keys2["S"] = "KeyS";
    Keys2["T"] = "KeyT";
    Keys2["U"] = "KeyU";
    Keys2["V"] = "KeyV";
    Keys2["W"] = "KeyW";
    Keys2["X"] = "KeyX";
    Keys2["Y"] = "KeyY";
    Keys2["Z"] = "KeyZ";
    Keys2["KeyA"] = "KeyA";
    Keys2["KeyB"] = "KeyB";
    Keys2["KeyC"] = "KeyC";
    Keys2["KeyD"] = "KeyD";
    Keys2["KeyE"] = "KeyE";
    Keys2["KeyF"] = "KeyF";
    Keys2["KeyG"] = "KeyG";
    Keys2["KeyH"] = "KeyH";
    Keys2["KeyI"] = "KeyI";
    Keys2["KeyJ"] = "KeyJ";
    Keys2["KeyK"] = "KeyK";
    Keys2["KeyL"] = "KeyL";
    Keys2["KeyM"] = "KeyM";
    Keys2["KeyN"] = "KeyN";
    Keys2["KeyO"] = "KeyO";
    Keys2["KeyP"] = "KeyP";
    Keys2["KeyQ"] = "KeyQ";
    Keys2["KeyR"] = "KeyR";
    Keys2["KeyS"] = "KeyS";
    Keys2["KeyT"] = "KeyT";
    Keys2["KeyU"] = "KeyU";
    Keys2["KeyV"] = "KeyV";
    Keys2["KeyW"] = "KeyW";
    Keys2["KeyX"] = "KeyX";
    Keys2["KeyY"] = "KeyY";
    Keys2["KeyZ"] = "KeyZ";
    Keys2["Semicolon"] = "Semicolon";
    Keys2["Quote"] = "Quote";
    Keys2["Comma"] = "Comma";
    Keys2["Minus"] = "Minus";
    Keys2["Period"] = "Period";
    Keys2["Slash"] = "Slash";
    Keys2["Equal"] = "Equal";
    Keys2["BracketLeft"] = "BracketLeft";
    Keys2["Backslash"] = "Backslash";
    Keys2["BracketRight"] = "BracketRight";
    Keys2["Backquote"] = "Backquote";
    Keys2["Up"] = "ArrowUp";
    Keys2["Down"] = "ArrowDown";
    Keys2["Left"] = "ArrowLeft";
    Keys2["Right"] = "ArrowRight";
    Keys2["ArrowUp"] = "ArrowUp";
    Keys2["ArrowDown"] = "ArrowDown";
    Keys2["ArrowLeft"] = "ArrowLeft";
    Keys2["ArrowRight"] = "ArrowRight";
    Keys2["Space"] = "Space";
    Keys2["Backspace"] = "Backspace";
    Keys2["Delete"] = "Delete";
    Keys2["Esc"] = "Escape";
    Keys2["Escape"] = "Escape";
    Keys2["Enter"] = "Enter";
    Keys2["NumpadEnter"] = "NumpadEnter";
    Keys2["ContextMenu"] = "ContextMenu";
  })(Keys || (Keys = {}));
  class KeyEvent extends GameEvent {
    /**
     * @param key  The key responsible for throwing the event
     * @param value The key's typed value the browser detected
     * @param originalEvent The original keyboard event that Excalibur handled
     */
    constructor(key, value, originalEvent) {
      super();
      this.key = key;
      this.value = value;
      this.originalEvent = originalEvent;
    }
  }
  class Keyboard {
    constructor() {
      this.events = new EventEmitter2();
      this._keys = [];
      this._keysUp = [];
      this._keysDown = [];
      this._releaseAllKeys = (ev) => {
        for (const code of this._keys) {
          const keyEvent = new KeyEvent(code, ev.key, ev);
          this.events.emit("up", keyEvent);
          this.events.emit("release", keyEvent);
        }
        this._keysUp = Array.from(new Set(this._keys.concat(this._keysUp)));
        this._keys.length = 0;
      };
      this._handleKeyDown = (ev) => {
        if (!ev.metaKey && (this._keys.includes(Keys.MetaLeft) || this._keys.includes(Keys.MetaRight))) {
          this._releaseAllKeys(ev);
        }
        const code = ev.code;
        if (this._keys.indexOf(code) === -1) {
          this._keys.push(code);
          this._keysDown.push(code);
          const keyEvent = new KeyEvent(code, ev.key, ev);
          this.events.emit("down", keyEvent);
          this.events.emit("press", keyEvent);
        }
      };
      this._handleKeyUp = (ev) => {
        const code = ev.code;
        const key = this._keys.indexOf(code);
        this._keys.splice(key, 1);
        this._keysUp.push(code);
        const keyEvent = new KeyEvent(code, ev.key, ev);
        this.events.emit("up", keyEvent);
        this.events.emit("release", keyEvent);
        if (ev.key === "Meta") {
          this._releaseAllKeys(ev);
        }
      };
    }
    emit(eventName, event) {
      this.events.emit(eventName, event);
    }
    on(eventName, handler) {
      return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
      return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
      this.events.off(eventName, handler);
    }
    /**
     * Initialize Keyboard event listeners
     */
    init(keyboardOptions) {
      let { global } = keyboardOptions;
      const { grabWindowFocus } = keyboardOptions;
      if (!global) {
        if (isCrossOriginIframe()) {
          global = window;
          if (grabWindowFocus) {
            window.focus();
          }
          Logger2.getInstance().warn("Excalibur might be in a cross-origin iframe, in order to receive keyboard events it must be in focus");
        } else {
          global = window.top;
        }
      }
      global.addEventListener("blur", () => {
        this._keys.length = 0;
      });
      global.addEventListener("keyup", this._handleKeyUp);
      global.addEventListener("keydown", this._handleKeyDown);
    }
    update() {
      this._keysDown.length = 0;
      this._keysUp.length = 0;
      for (let i2 = 0; i2 < this._keys.length; i2++) {
        this.events.emit("hold", new KeyEvent(this._keys[i2]));
      }
    }
    /**
     * Gets list of keys being pressed down
     */
    getKeys() {
      return this._keys;
    }
    /**
     * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.
     * @param key Test whether a key was just pressed
     */
    wasPressed(key) {
      return this._keysDown.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key is held down. This is persisted between frames.
     * @param key  Test whether a key is held down
     */
    isHeld(key) {
      return this._keys.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.
     * @param key  Test whether a key was just released
     */
    wasReleased(key) {
      return this._keysUp.indexOf(key) > -1;
    }
    /**
     * Trigger a manual key event
     * @param type
     * @param key
     * @param character
     */
    triggerEvent(type, key, character) {
      if (type === "down") {
        this._handleKeyDown(new KeyboardEvent("keydown", {
          code: key,
          key: character !== null && character !== void 0 ? character : null
        }));
      }
      if (type === "up") {
        this._handleKeyUp(new KeyboardEvent("keyup", {
          code: key,
          key: character !== null && character !== void 0 ? character : null
        }));
      }
    }
  }
  var PointerScope;
  (function(PointerScope2) {
    PointerScope2["Canvas"] = "Canvas";
    PointerScope2["Document"] = "Document";
  })(PointerScope || (PointerScope = {}));
  const BITMASK32 = 4294967295;
  class Random {
    /**
     * If no seed is specified, the Date.now() is used
     */
    constructor(seed) {
      this.seed = seed;
      this._lowerMask = 2147483647;
      this._upperMask = 2147483648;
      this._w = 32;
      this._n = 624;
      this._m = 397;
      this._a = 2567483615;
      this._u = 11;
      this._s = 7;
      this._b = 2636928640;
      this._t = 15;
      this._c = 4022730752;
      this._l = 18;
      this._f = 1812433253;
      this._mt = new Array(this._n);
      this._mt[0] = (seed || Date.now()) >>> 0;
      for (let i2 = 1; i2 < this._n; i2++) {
        const s2 = this._mt[i2 - 1] ^ this._mt[i2 - 1] >>> this._w - 2;
        this._mt[i2] = (this._f * ((s2 & 4294901760) >>> 16) << 16) + this._f * (s2 & 65535) + i2 >>> 0;
      }
      this._index = this._n;
    }
    /**
     * Apply the twist
     */
    _twist() {
      const mag01 = [0, this._a];
      let y2 = 0, i2 = 0;
      for (; i2 < this._n - this._m; i2++) {
        y2 = this._mt[i2] & this._upperMask | this._mt[i2 + 1] & this._lowerMask;
        this._mt[i2] = this._mt[i2 + this._m] ^ y2 >>> 1 ^ mag01[y2 & 1] & BITMASK32;
      }
      for (; i2 < this._n - 1; i2++) {
        y2 = this._mt[i2] & this._upperMask | this._mt[i2 + 1] & this._lowerMask;
        this._mt[i2] = this._mt[i2 + (this._m - this._n)] ^ y2 >>> 1 ^ mag01[y2 & 1] & BITMASK32;
      }
      y2 = this._mt[this._n - 1] & this._upperMask | this._mt[0] & this._lowerMask;
      this._mt[this._n - 1] = this._mt[this._m - 1] ^ y2 >>> 1 ^ mag01[y2 & 1] & BITMASK32;
      this._index = 0;
    }
    /**
     * Return next 32 bit integer number in sequence
     */
    nextInt() {
      if (this._index >= this._n) {
        this._twist();
      }
      let y2 = this._mt[this._index++];
      y2 ^= y2 >>> this._u;
      y2 ^= y2 << this._s & this._b;
      y2 ^= y2 << this._t & this._c;
      y2 ^= y2 >>> this._l;
      return y2 >>> 0;
    }
    /**
     * Return a random floating point number between [0, 1)
     */
    next() {
      return this.nextInt() * (1 / 4294967296);
    }
    /**
     * Return a random floating point in range [min, max) min is included, max is not included
     */
    floating(min, max) {
      return (max - min) * this.next() + min;
    }
    /**
     * Return a random integer in range [min, max] min is included, max is included.
     * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a
     */
    integer(min, max) {
      return Math.floor((max - min + 1) * this.next() + min);
    }
    /**
     * Returns true or false randomly with 50/50 odds by default.
     * By default the likelihood of returning a true is .5 (50%).
     * @param likelihood takes values between [0, 1]
     */
    bool(likelihood = 0.5) {
      return this.next() <= likelihood;
    }
    /**
     * Returns one element from an array at random
     */
    pickOne(array) {
      return array[this.integer(0, array.length - 1)];
    }
    /**
     * Returns a new array random picking elements from the original
     * @param array Original array to pick from
     * @param numPicks can be any positive number
     * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates
     * just that it is possible)
     */
    pickSet(array, numPicks, allowDuplicates = false) {
      if (allowDuplicates) {
        return this._pickSetWithDuplicates(array, numPicks);
      } else {
        return this._pickSetWithoutDuplicates(array, numPicks);
      }
    }
    /**
     * Returns a new array randomly picking elements in the original (not reused)
     * @param array Array to pick elements out of
     * @param numPicks must be less than or equal to the number of elements in the array.
     */
    _pickSetWithoutDuplicates(array, numPicks) {
      if (numPicks > array.length || numPicks < 0) {
        throw new Error("Invalid number of elements to pick, must pick a value 0 < n <= length");
      }
      if (numPicks === array.length) {
        return array;
      }
      const result = new Array(numPicks);
      let currentPick = 0;
      const tempArray = array.slice(0);
      while (currentPick < numPicks) {
        const index = this.integer(0, tempArray.length - 1);
        result[currentPick++] = tempArray[index];
        tempArray.splice(index, 1);
      }
      return result;
    }
    /**
     * Returns a new array random picking elements from the original allowing duplicates
     * @param array Array to pick elements out of
     * @param numPicks can be any positive number
     */
    _pickSetWithDuplicates(array, numPicks) {
      if (numPicks < 0) {
        throw new Error("Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT");
      }
      const result = new Array(numPicks);
      for (let i2 = 0; i2 < numPicks; i2++) {
        result[i2] = this.pickOne(array);
      }
      return result;
    }
    /**
     * Returns a new array that has its elements shuffled. Using the Fisher/Yates method
     * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
     */
    shuffle(array) {
      const tempArray = array.slice(0);
      let swap = null;
      for (let i2 = 0; i2 < tempArray.length - 2; i2++) {
        const randomIndex = this.integer(i2, tempArray.length - 1);
        swap = tempArray[i2];
        tempArray[i2] = tempArray[randomIndex];
        tempArray[randomIndex] = swap;
      }
      return tempArray;
    }
    /**
     * Generate a list of random integer numbers
     * @param length the length of the final array
     * @param min the minimum integer number to generate inclusive
     * @param max the maximum integer number to generate inclusive
     */
    range(length, min, max) {
      const result = new Array(length);
      for (let i2 = 0; i2 < length; i2++) {
        result[i2] = this.integer(min, max);
      }
      return result;
    }
    /**
     * Returns the result of a d4 dice roll
     */
    d4() {
      return this.integer(1, 4);
    }
    /**
     * Returns the result of a d6 dice roll
     */
    d6() {
      return this.integer(1, 6);
    }
    /**
     * Returns the result of a d8 dice roll
     */
    d8() {
      return this.integer(1, 8);
    }
    /**
     * Returns the result of a d10 dice roll
     */
    d10() {
      return this.integer(1, 10);
    }
    /**
     * Returns the result of a d12 dice roll
     */
    d12() {
      return this.integer(1, 12);
    }
    /**
     * Returns the result of a d20 dice roll
     */
    d20() {
      return this.integer(1, 20);
    }
  }
  const TwoPI = Math.PI * 2;
  function frac(x2) {
    if (x2 >= 0) {
      return x2 - Math.floor(x2);
    } else {
      return x2 - Math.ceil(x2);
    }
  }
  function sign(val) {
    if (val === 0) {
      return 0;
    }
    return val < 0 ? -1 : 1;
  }
  function clamp2(val, min, max) {
    return Math.min(Math.max(min, val), max);
  }
  function canonicalizeAngle(angle) {
    let tmpAngle = angle;
    if (angle > TwoPI) {
      while (tmpAngle > TwoPI) {
        tmpAngle -= TwoPI;
      }
    }
    if (angle < 0) {
      while (tmpAngle < 0) {
        tmpAngle += TwoPI;
      }
    }
    return tmpAngle;
  }
  function toDegrees(radians) {
    return 180 / Math.PI * radians;
  }
  function toRadians(degrees2) {
    return degrees2 / 180 * Math.PI;
  }
  const range = (from, to) => Array.from(new Array(to - from + 1), (_x, i2) => i2 + from);
  function randomInRange(min, max, random = new Random()) {
    return random ? random.floating(min, max) : min + Math.random() * (max - min);
  }
  function randomIntInRange(min, max, random = new Random()) {
    return random ? random.integer(min, max) : Math.round(randomInRange(min, max));
  }
  class Vector {
    /**
     * A (0, 0) vector
     */
    static get Zero() {
      return new Vector(0, 0);
    }
    /**
     * A (1, 1) vector
     */
    static get One() {
      return new Vector(1, 1);
    }
    /**
     * A (0.5, 0.5) vector
     */
    static get Half() {
      return new Vector(0.5, 0.5);
    }
    /**
     * A unit vector pointing up (0, -1)
     */
    static get Up() {
      return new Vector(0, -1);
    }
    /**
     * A unit vector pointing down (0, 1)
     */
    static get Down() {
      return new Vector(0, 1);
    }
    /**
     * A unit vector pointing left (-1, 0)
     */
    static get Left() {
      return new Vector(-1, 0);
    }
    /**
     * A unit vector pointing right (1, 0)
     */
    static get Right() {
      return new Vector(1, 0);
    }
    /**
     * Returns a vector of unit length in the direction of the specified angle in Radians.
     * @param angle The angle to generate the vector
     */
    static fromAngle(angle) {
      return new Vector(Math.cos(angle), Math.sin(angle));
    }
    /**
     * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.
     */
    static isValid(vec2) {
      if (vec2 === null || vec2 === void 0) {
        return false;
      }
      if (isNaN(vec2.x) || isNaN(vec2.y)) {
        return false;
      }
      if (vec2.x === Infinity || vec2.y === Infinity || vec2.x === -Infinity || vec2.y === -Infinity) {
        return false;
      }
      return true;
    }
    /**
     * Calculates distance between two Vectors
     * @param vec1
     * @param vec2
     */
    static distance(vec1, vec2) {
      return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));
    }
    static min(vec1, vec2) {
      return new Vector(Math.min(vec1.x, vec2.x), Math.min(vec1.y, vec2.y));
    }
    static max(vec1, vec2) {
      return new Vector(Math.max(vec1.x, vec2.x), Math.max(vec1.y, vec2.y));
    }
    /**
     * @param x  X component of the Vector
     * @param y  Y component of the Vector
     */
    constructor(x2, y2) {
      this._x = 0;
      this._y = 0;
      this._x = x2;
      this._y = y2;
    }
    /**
     * Get the x component of the vector
     */
    get x() {
      return this._x;
    }
    /**
     * Set the x component, THIS MUTATES the current vector. It is usually better to create a new vector.
     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
     */
    set x(val) {
      this._x = val;
    }
    /**
     * Get the y component of the vector
     */
    get y() {
      return this._y;
    }
    /**
     * Set the y component, THIS MUTATES the current vector. It is usually better to create a new vector.
     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
     */
    set y(val) {
      this._y = val;
    }
    /**
     * Sets the x and y components at once, THIS MUTATES the current vector. It is usually better to create a new vector.
     *
     * @warning **Be very careful using this, mutating vectors can cause hard to find bugs**
     */
    setTo(x2, y2) {
      this.x = x2;
      this.y = y2;
    }
    /**
     * Compares this point against another and tests for equality
     * @param vector The other point to compare to
     * @param tolerance Amount of euclidean distance off we are willing to tolerate
     */
    equals(vector2, tolerance = 1e-3) {
      return Math.abs(this.x - vector2.x) <= tolerance && Math.abs(this.y - vector2.y) <= tolerance;
    }
    /**
     * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].
     * @param v  The other vector. Leave blank to use origin vector.
     */
    distance(v2) {
      if (!v2) {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      const deltaX = this.x - v2.x;
      const deltaY = this.y - v2.y;
      return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    }
    squareDistance(v2) {
      if (!v2) {
        v2 = Vector.Zero;
      }
      const deltaX = this.x - v2.x;
      const deltaY = this.y - v2.y;
      return deltaX * deltaX + deltaY * deltaY;
    }
    /**
     * Clamps the current vector's magnitude mutating it
     * @param magnitude
     */
    clampMagnitude(magnitude) {
      const size = this.size;
      const newSize = clamp2(size, 0, magnitude);
      this.size = newSize;
      return this;
    }
    /**
     * The size (magnitude) of the Vector
     */
    get size() {
      return this.distance();
    }
    /**
     * Setting the size mutates the current vector
     *
     * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**
     */
    set size(newLength) {
      const v2 = this.normalize().scale(newLength);
      this.setTo(v2.x, v2.y);
    }
    /**
     * Normalizes a vector to have a magnitude of 1.
     */
    normalize() {
      const d2 = this.distance();
      if (d2 > 0) {
        return new Vector(this.x / d2, this.y / d2);
      } else {
        return new Vector(0, 1);
      }
    }
    /**
     * Returns the average (midpoint) between the current point and the specified
     */
    average(vec2) {
      return this.add(vec2).scale(0.5);
    }
    scale(sizeOrScale, dest) {
      const result = dest || new Vector(0, 0);
      if (sizeOrScale instanceof Vector) {
        result.x = this.x * sizeOrScale.x;
        result.y = this.y * sizeOrScale.y;
      } else {
        result.x = this.x * sizeOrScale;
        result.y = this.y * sizeOrScale;
      }
      return result;
    }
    /**
     * Adds one vector to another
     * @param v The vector to add
     * @param dest Optionally copy the result into a provided vector
     */
    add(v2, dest) {
      if (dest) {
        dest.x = this.x + v2.x;
        dest.y = this.y + v2.y;
        return dest;
      }
      return new Vector(this.x + v2.x, this.y + v2.y);
    }
    /**
     * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B
     * @param v The vector to subtract
     */
    sub(v2) {
      return new Vector(this.x - v2.x, this.y - v2.y);
    }
    /**
     * Adds one vector to this one modifying the original
     * @param v The vector to add
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    addEqual(v2) {
      this.setTo(this.x + v2.x, this.y + v2.y);
      return this;
    }
    /**
     * Subtracts a vector from this one modifying the original
     * @param v The vector to subtract
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    subEqual(v2) {
      this.setTo(this.x - v2.x, this.y - v2.y);
      return this;
    }
    /**
     * Scales this vector by a factor of size and modifies the original
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    scaleEqual(size) {
      this.setTo(this.x * size, this.y * size);
      return this;
    }
    /**
     * Performs a dot product with another vector
     * @param v  The vector to dot
     */
    dot(v2) {
      return this.x * v2.x + this.y * v2.y;
    }
    cross(v2) {
      if (v2 instanceof Vector) {
        return this.x * v2.y - this.y * v2.x;
      } else if (typeof v2 === "number") {
        return new Vector(v2 * this.y, -v2 * this.x);
      }
    }
    static cross(num, vec2) {
      return new Vector(-num * vec2.y, num * vec2.x);
    }
    /**
     * Returns the perpendicular vector to this one
     */
    perpendicular() {
      return new Vector(this.y, -this.x);
    }
    /**
     * Returns the normal vector to this one, same as the perpendicular of length 1
     */
    normal() {
      return this.perpendicular().normalize();
    }
    /**
     * Negate the current vector
     */
    negate() {
      return this.scale(-1);
    }
    /**
     * Returns the angle of this vector.
     */
    toAngle() {
      return Math.atan2(this.y, this.x);
    }
    /**
     * Rotates the current vector around a point by a certain number of
     * degrees in radians
     */
    rotate(angle, anchor) {
      if (!anchor) {
        anchor = new Vector(0, 0);
      }
      const sinAngle = Math.sin(angle);
      const cosAngle = Math.cos(angle);
      const x2 = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
      const y2 = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
      return new Vector(x2, y2);
    }
    /**
     * Creates new vector that has the same values as the previous.
     */
    clone(dest) {
      const v2 = dest !== null && dest !== void 0 ? dest : new Vector(0, 0);
      v2.x = this.x;
      v2.y = this.y;
      return v2;
    }
    /**
     * Returns a string representation of the vector.
     */
    toString(fixed) {
      if (fixed) {
        return `(${this.x.toFixed(fixed)}, ${this.y.toFixed(fixed)})`;
      }
      return `(${this.x}, ${this.y})`;
    }
  }
  function vec(x2, y2) {
    return new Vector(x2, y2);
  }
  class Color {
    /**
     * Creates a new instance of Color from an r, g, b, a
     *
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    constructor(r2, g2, b2, a2) {
      this.r = r2;
      this.g = g2;
      this.b = b2;
      this.a = a2 != null ? a2 : 1;
    }
    /**
     * Creates a new instance of Color from an r, g, b, a
     *
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    static fromRGB(r2, g2, b2, a2) {
      return new Color(r2, g2, b2, a2);
    }
    /**
     * Creates a new instance of Color from a rgb string
     *
     * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)
     */
    static fromRGBString(string) {
      const rgbaRegEx = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)/i;
      let match = null;
      if (match = string.match(rgbaRegEx)) {
        const r2 = parseInt(match[1], 10);
        const g2 = parseInt(match[2], 10);
        const b2 = parseInt(match[3], 10);
        let a2 = 1;
        if (match[4]) {
          a2 = parseFloat(match[4]);
        }
        return new Color(r2, g2, b2, a2);
      } else {
        throw new Error("Invalid rgb/a string: " + string);
      }
    }
    /**
     * Creates a new instance of Color from a hex string
     *
     * @param hex  CSS color string of the form #ffffff, the alpha component is optional
     */
    static fromHex(hex2) {
      const hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
      let match = null;
      if (match = hex2.match(hexRegEx)) {
        const r2 = parseInt(match[1], 16);
        const g2 = parseInt(match[2], 16);
        const b2 = parseInt(match[3], 16);
        let a2 = 1;
        if (match[4]) {
          a2 = parseInt(match[4], 16) / 255;
        }
        return new Color(r2, g2, b2, a2);
      } else {
        throw new Error("Invalid hex string: " + hex2);
      }
    }
    /**
     * Creates a new instance of Color from hsla values
     *
     * @param h  Hue is represented [0-1]
     * @param s  Saturation is represented [0-1]
     * @param l  Luminance is represented [0-1]
     * @param a  Alpha is represented [0-1]
     */
    static fromHSL(h2, s2, l2, a2 = 1) {
      const temp = new HSLColor(h2, s2, l2, a2);
      return temp.toRGBA();
    }
    /**
     * Lightens the current color by a specified amount
     *
     * @param factor  The amount to lighten by [0-1]
     */
    lighten(factor = 0.1) {
      const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
      temp.l += (1 - temp.l) * factor;
      return temp.toRGBA();
    }
    /**
     * Darkens the current color by a specified amount
     *
     * @param factor  The amount to darken by [0-1]
     */
    darken(factor = 0.1) {
      const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
      temp.l -= temp.l * factor;
      return temp.toRGBA();
    }
    /**
     * Saturates the current color by a specified amount
     *
     * @param factor  The amount to saturate by [0-1]
     */
    saturate(factor = 0.1) {
      const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
      temp.s += temp.s * factor;
      return temp.toRGBA();
    }
    /**
     * Desaturates the current color by a specified amount
     *
     * @param factor  The amount to desaturate by [0-1]
     */
    desaturate(factor = 0.1) {
      const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
      temp.s -= temp.s * factor;
      return temp.toRGBA();
    }
    /**
     * Multiplies a color by another, results in a darker color
     *
     * @param color  The other color
     */
    multiply(color2) {
      const newR = color2.r / 255 * this.r / 255 * 255;
      const newG = color2.g / 255 * this.g / 255 * 255;
      const newB = color2.b / 255 * this.b / 255 * 255;
      const newA = color2.a * this.a;
      return new Color(newR, newG, newB, newA);
    }
    /**
     * Screens a color by another, results in a lighter color
     *
     * @param color  The other color
     */
    screen(color2) {
      const color1 = color2.invert();
      const color22 = color2.invert();
      return color1.multiply(color22).invert();
    }
    /**
     * Inverts the current color
     */
    invert() {
      return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1 - this.a);
    }
    /**
     * Averages the current color with another
     *
     * @param color  The other color
     */
    average(color2) {
      const newR = (color2.r + this.r) / 2;
      const newG = (color2.g + this.g) / 2;
      const newB = (color2.b + this.b) / 2;
      const newA = (color2.a + this.a) / 2;
      return new Color(newR, newG, newB, newA);
    }
    equal(color2) {
      return this.toString() === color2.toString();
    }
    /**
     * Returns a CSS string representation of a color.
     *
     * @param format Color representation, accepts: rgb, hsl, or hex
     */
    toString(format = "rgb") {
      switch (format) {
        case "rgb":
          return this.toRGBA();
        case "hsl":
          return this.toHSLA();
        case "hex":
          return this.toHex();
        default:
          throw new Error("Invalid Color format");
      }
    }
    /**
     * Returns Hex Value of a color component
     * @param c color component
     * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     */
    _componentToHex(c2) {
      const hex2 = c2.toString(16);
      return hex2.length === 1 ? "0" + hex2 : hex2;
    }
    /**
     * Return Hex representation of a color.
     */
    toHex() {
      return "#" + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);
    }
    /**
     * Return RGBA representation of a color.
     */
    toRGBA() {
      const result = String(this.r.toFixed(0)) + ", " + String(this.g.toFixed(0)) + ", " + String(this.b.toFixed(0));
      if (this.a !== void 0 || this.a !== null) {
        return "rgba(" + result + ", " + String(this.a) + ")";
      }
      return "rgb(" + result + ")";
    }
    /**
     * Return HSLA representation of a color.
     */
    toHSLA() {
      return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();
    }
    /**
     * Returns a CSS string representation of a color.
     */
    fillStyle() {
      return this.toString();
    }
    /**
     * Returns a clone of the current color.
     */
    clone() {
      return new Color(this.r, this.g, this.b, this.a);
    }
    /**
     * Black (#000000)
     */
    static get Black() {
      return Color.fromHex("#000000");
    }
    /**
     * White (#FFFFFF)
     */
    static get White() {
      return Color.fromHex("#FFFFFF");
    }
    /**
     * Gray (#808080)
     */
    static get Gray() {
      return Color.fromHex("#808080");
    }
    /**
     * Light gray (#D3D3D3)
     */
    static get LightGray() {
      return Color.fromHex("#D3D3D3");
    }
    /**
     * Dark gray (#A9A9A9)
     */
    static get DarkGray() {
      return Color.fromHex("#A9A9A9");
    }
    /**
     * Yellow (#FFFF00)
     */
    static get Yellow() {
      return Color.fromHex("#FFFF00");
    }
    /**
     * Orange (#FFA500)
     */
    static get Orange() {
      return Color.fromHex("#FFA500");
    }
    /**
     * Red (#FF0000)
     */
    static get Red() {
      return Color.fromHex("#FF0000");
    }
    /**
     * Vermilion (#FF5B31)
     */
    static get Vermilion() {
      return Color.fromHex("#FF5B31");
    }
    /**
     * Rose (#FF007F)
     */
    static get Rose() {
      return Color.fromHex("#FF007F");
    }
    /**
     * Magenta (#FF00FF)
     */
    static get Magenta() {
      return Color.fromHex("#FF00FF");
    }
    /**
     * Violet (#7F00FF)
     */
    static get Violet() {
      return Color.fromHex("#7F00FF");
    }
    /**
     * Blue (#0000FF)
     */
    static get Blue() {
      return Color.fromHex("#0000FF");
    }
    /**
     * Azure (#007FFF)
     */
    static get Azure() {
      return Color.fromHex("#007FFF");
    }
    /**
     * Cyan (#00FFFF)
     */
    static get Cyan() {
      return Color.fromHex("#00FFFF");
    }
    /**
     * Viridian (#59978F)
     */
    static get Viridian() {
      return Color.fromHex("#59978F");
    }
    /**
     * Green (#00FF00)
     */
    static get Green() {
      return Color.fromHex("#00FF00");
    }
    /**
     * Chartreuse (#7FFF00)
     */
    static get Chartreuse() {
      return Color.fromHex("#7FFF00");
    }
    /**
     * Transparent (#FFFFFF00)
     */
    static get Transparent() {
      return Color.fromHex("#FFFFFF00");
    }
    /**
     * ExcaliburBlue (#176BAA)
     */
    static get ExcaliburBlue() {
      return Color.fromHex("#176BAA");
    }
  }
  class HSLColor {
    constructor(h2, s2, l2, a2) {
      this.h = h2;
      this.s = s2;
      this.l = l2;
      this.a = a2;
    }
    static hue2rgb(p2, q2, t2) {
      if (t2 < 0) {
        t2 += 1;
      }
      if (t2 > 1) {
        t2 -= 1;
      }
      if (t2 < 1 / 6) {
        return p2 + (q2 - p2) * 6 * t2;
      }
      if (t2 < 1 / 2) {
        return q2;
      }
      if (t2 < 2 / 3) {
        return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
      }
      return p2;
    }
    static fromRGBA(r2, g2, b2, a2) {
      r2 /= 255;
      g2 /= 255;
      b2 /= 255;
      const max = Math.max(r2, g2, b2), min = Math.min(r2, g2, b2);
      let h2, s2;
      const l2 = (max + min) / 2;
      if (max === min) {
        h2 = s2 = 0;
      } else {
        const d2 = max - min;
        s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
        switch (max) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return new HSLColor(h2, s2, l2, a2);
    }
    toRGBA() {
      let r2, g2, b2;
      if (this.s === 0) {
        r2 = g2 = b2 = this.l;
      } else {
        const q2 = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;
        const p2 = 2 * this.l - q2;
        r2 = HSLColor.hue2rgb(p2, q2, this.h + 1 / 3);
        g2 = HSLColor.hue2rgb(p2, q2, this.h);
        b2 = HSLColor.hue2rgb(p2, q2, this.h - 1 / 3);
      }
      return new Color(r2 * 255, g2 * 255, b2 * 255, this.a);
    }
    toString() {
      const h2 = this.h.toFixed(0), s2 = this.s.toFixed(0), l2 = this.l.toFixed(0), a2 = this.a.toFixed(0);
      return `hsla(${h2}, ${s2}, ${l2}, ${a2})`;
    }
  }
  var Side;
  (function(Side2) {
    Side2["None"] = "None";
    Side2["Top"] = "Top";
    Side2["Bottom"] = "Bottom";
    Side2["Left"] = "Left";
    Side2["Right"] = "Right";
  })(Side || (Side = {}));
  (function(Side2) {
    function getOpposite(side) {
      if (side === Side2.Top) {
        return Side2.Bottom;
      }
      if (side === Side2.Bottom) {
        return Side2.Top;
      }
      if (side === Side2.Left) {
        return Side2.Right;
      }
      if (side === Side2.Right) {
        return Side2.Left;
      }
      return Side2.None;
    }
    Side2.getOpposite = getOpposite;
    function fromDirection(direction) {
      const directions = [Vector.Left, Vector.Right, Vector.Up, Vector.Down];
      const directionEnum = [Side2.Left, Side2.Right, Side2.Top, Side2.Bottom];
      let max = -Number.MAX_VALUE;
      let maxIndex = -1;
      for (let i2 = 0; i2 < directions.length; i2++) {
        if (directions[i2].dot(direction) > max) {
          max = directions[i2].dot(direction);
          maxIndex = i2;
        }
      }
      return directionEnum[maxIndex];
    }
    Side2.fromDirection = fromDirection;
  })(Side || (Side = {}));
  class BoundingBox {
    /**
     * Constructor allows passing of either an object with all coordinate components,
     * or the coordinate components passed separately.
     * @param leftOrOptions    Either x coordinate of the left edge or an options object
     * containing the four coordinate components.
     * @param top     y coordinate of the top edge
     * @param right   x coordinate of the right edge
     * @param bottom  y coordinate of the bottom edge
     */
    constructor(leftOrOptions = 0, top = 0, right = 0, bottom = 0) {
      if (typeof leftOrOptions === "object") {
        this.left = leftOrOptions.left;
        this.top = leftOrOptions.top;
        this.right = leftOrOptions.right;
        this.bottom = leftOrOptions.bottom;
      } else if (typeof leftOrOptions === "number") {
        this.left = leftOrOptions;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
      }
    }
    /**
     * Returns a new instance of [[BoundingBox]] that is a copy of the current instance
     */
    clone() {
      return new BoundingBox(this.left, this.top, this.right, this.bottom);
    }
    /**
     * Given bounding box A & B, returns the side relative to A when intersection is performed.
     * @param intersection Intersection vector between 2 bounding boxes
     */
    static getSideFromIntersection(intersection) {
      if (!intersection) {
        return Side.None;
      }
      if (intersection) {
        if (Math.abs(intersection.x) > Math.abs(intersection.y)) {
          if (intersection.x < 0) {
            return Side.Right;
          }
          return Side.Left;
        } else {
          if (intersection.y < 0) {
            return Side.Bottom;
          }
          return Side.Top;
        }
      }
      return Side.None;
    }
    static fromPoints(points) {
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      for (let i2 = 0; i2 < points.length; i2++) {
        if (points[i2].x < minX) {
          minX = points[i2].x;
        }
        if (points[i2].x > maxX) {
          maxX = points[i2].x;
        }
        if (points[i2].y < minY) {
          minY = points[i2].y;
        }
        if (points[i2].y > maxY) {
          maxY = points[i2].y;
        }
      }
      return new BoundingBox(minX, minY, maxX, maxY);
    }
    static fromDimension(width, height, anchor = Vector.Half, pos = Vector.Zero) {
      return new BoundingBox(-width * anchor.x + pos.x, -height * anchor.y + pos.y, width - width * anchor.x + pos.x, height - height * anchor.y + pos.y);
    }
    /**
     * Returns the calculated width of the bounding box
     */
    get width() {
      return this.right - this.left;
    }
    /**
     * Returns the calculated height of the bounding box
     */
    get height() {
      return this.bottom - this.top;
    }
    /**
     * Return whether the bounding box has zero dimensions in height,width or both
     */
    hasZeroDimensions() {
      return this.width === 0 || this.height === 0;
    }
    /**
     * Returns the center of the bounding box
     */
    get center() {
      return new Vector((this.left + this.right) / 2, (this.top + this.bottom) / 2);
    }
    translate(pos) {
      return new BoundingBox(this.left + pos.x, this.top + pos.y, this.right + pos.x, this.bottom + pos.y);
    }
    /**
     * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding
     * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.
     */
    rotate(angle, point2 = Vector.Zero) {
      const points = this.getPoints().map((p2) => p2.rotate(angle, point2));
      return BoundingBox.fromPoints(points);
    }
    /**
     * Scale a bounding box by a scale factor, optionally provide a point
     * @param scale
     * @param point
     */
    scale(scale2, point2 = Vector.Zero) {
      const shifted = this.translate(point2);
      return new BoundingBox(shifted.left * scale2.x, shifted.top * scale2.y, shifted.right * scale2.x, shifted.bottom * scale2.y);
    }
    /**
     * Transform the axis aligned bounding box by a [[Matrix]], producing a new axis aligned bounding box
     * @param matrix
     */
    transform(matrix) {
      const xa1 = matrix.data[0] * this.left;
      const xa2 = matrix.data[1] * this.left;
      const xb1 = matrix.data[0] * this.right;
      const xb2 = matrix.data[1] * this.right;
      const ya1 = matrix.data[2] * this.top;
      const ya2 = matrix.data[3] * this.top;
      const yb1 = matrix.data[2] * this.bottom;
      const yb2 = matrix.data[3] * this.bottom;
      const matrixPos = matrix.getPosition();
      const left = Math.min(xa1, xb1) + Math.min(ya1, yb1) + matrixPos.x;
      const top = Math.min(xa2, xb2) + Math.min(ya2, yb2) + matrixPos.y;
      const right = Math.max(xa1, xb1) + Math.max(ya1, yb1) + matrixPos.x;
      const bottom = Math.max(xa2, xb2) + Math.max(ya2, yb2) + matrixPos.y;
      return new BoundingBox({
        left,
        top,
        right,
        bottom
        //: bottomRight.y
      });
    }
    /**
     * Returns the perimeter of the bounding box
     */
    getPerimeter() {
      const wx = this.width;
      const wy = this.height;
      return 2 * (wx + wy);
    }
    getPoints() {
      const results2 = [];
      results2.push(new Vector(this.left, this.top));
      results2.push(new Vector(this.right, this.top));
      results2.push(new Vector(this.right, this.bottom));
      results2.push(new Vector(this.left, this.bottom));
      return results2;
    }
    /**
     * Determines whether a ray intersects with a bounding box
     */
    rayCast(ray, farClipDistance = Infinity) {
      let tmin = -Infinity;
      let tmax = Infinity;
      const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
      const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
      const tx1 = (this.left - ray.pos.x) * xinv;
      const tx2 = (this.right - ray.pos.x) * xinv;
      tmin = Math.min(tx1, tx2);
      tmax = Math.max(tx1, tx2);
      const ty1 = (this.top - ray.pos.y) * yinv;
      const ty2 = (this.bottom - ray.pos.y) * yinv;
      tmin = Math.max(tmin, Math.min(ty1, ty2));
      tmax = Math.min(tmax, Math.max(ty1, ty2));
      return tmax >= Math.max(0, tmin) && tmin < farClipDistance;
    }
    rayCastTime(ray, farClipDistance = Infinity) {
      let tmin = -Infinity;
      let tmax = Infinity;
      const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
      const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
      const tx1 = (this.left - ray.pos.x) * xinv;
      const tx2 = (this.right - ray.pos.x) * xinv;
      tmin = Math.min(tx1, tx2);
      tmax = Math.max(tx1, tx2);
      const ty1 = (this.top - ray.pos.y) * yinv;
      const ty2 = (this.bottom - ray.pos.y) * yinv;
      tmin = Math.max(tmin, Math.min(ty1, ty2));
      tmax = Math.min(tmax, Math.max(ty1, ty2));
      if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {
        return tmin;
      }
      return -1;
    }
    contains(val) {
      if (val instanceof Vector) {
        return this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x;
      } else if (val instanceof BoundingBox) {
        if (this.left <= val.left && this.top <= val.top && val.bottom <= this.bottom && val.right <= this.right) {
          return true;
        }
        return false;
      }
      return false;
    }
    /**
     * Combines this bounding box and another together returning a new bounding box
     * @param other  The bounding box to combine
     */
    combine(other) {
      const compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
      return compositeBB;
    }
    get dimensions() {
      return new Vector(this.width, this.height);
    }
    /**
     * Returns true if the bounding boxes overlap.
     * @param other
     * @param epsilon Optionally specify a small epsilon (default 0) as amount of overlap to ignore as overlap.
     * This epsilon is useful in stable collision simulations.
     */
    overlaps(other, epsilon) {
      const e2 = epsilon || 0;
      if (other.hasZeroDimensions()) {
        return this.contains(other);
      }
      if (this.hasZeroDimensions()) {
        return other.contains(this);
      }
      const totalBoundingBox = this.combine(other);
      return totalBoundingBox.width + e2 < other.width + this.width && totalBoundingBox.height + e2 < other.height + this.height;
    }
    /**
     * Test wether this bounding box intersects with another returning
     * the intersection vector that can be used to resolve the collision. If there
     * is no intersection null is returned.
     *
     * @param other  Other [[BoundingBox]] to test intersection with
     * @returns A Vector in the direction of the current BoundingBox, this <- other
     */
    intersect(other) {
      const totalBoundingBox = this.combine(other);
      if (totalBoundingBox.width < other.width + this.width && totalBoundingBox.height < other.height + this.height && !totalBoundingBox.dimensions.equals(other.dimensions) && !totalBoundingBox.dimensions.equals(this.dimensions)) {
        let overlapX = 0;
        if (this.right >= other.left && this.right <= other.right) {
          overlapX = other.left - this.right;
        } else {
          overlapX = other.right - this.left;
        }
        let overlapY = 0;
        if (this.top <= other.bottom && this.top >= other.top) {
          overlapY = other.bottom - this.top;
        } else {
          overlapY = other.top - this.bottom;
        }
        if (Math.abs(overlapX) < Math.abs(overlapY)) {
          return new Vector(overlapX, 0);
        } else {
          return new Vector(0, overlapY);
        }
      } else if (totalBoundingBox.dimensions.equals(other.dimensions) || totalBoundingBox.dimensions.equals(this.dimensions)) {
        let overlapX = 0;
        if (this.width - other.width >= 0) {
          if (this.right - other.right <= other.left - this.left) {
            overlapX = other.left - this.right;
          } else {
            overlapX = other.right - this.left;
          }
        } else {
          if (other.right - this.right <= this.left - other.left) {
            overlapX = this.left - other.right;
          } else {
            overlapX = this.right - other.left;
          }
        }
        let overlapY = 0;
        if (this.height - other.height >= 0) {
          if (this.bottom - other.bottom <= other.top - this.top) {
            overlapY = other.top - this.bottom;
          } else {
            overlapY = other.bottom - this.top;
          }
        } else {
          if (other.bottom - this.bottom <= this.top - other.top) {
            overlapY = this.top - other.bottom;
          } else {
            overlapY = this.bottom - other.top;
          }
        }
        if (Math.abs(overlapX) < Math.abs(overlapY)) {
          return new Vector(overlapX, 0);
        } else {
          return new Vector(0, overlapY);
        }
      } else {
        return null;
      }
    }
    /**
     * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.
     * @param bb The other actor to test
     */
    intersectWithSide(bb2) {
      const intersect = this.intersect(bb2);
      return BoundingBox.getSideFromIntersection(intersect);
    }
    /**
     * Draw a debug bounding box
     * @param ex
     * @param color
     */
    draw(ex, color2 = Color.Yellow) {
      ex.debug.drawRect(this.left, this.top, this.width, this.height, { color: color2 });
    }
  }
  class Future {
    constructor() {
      this._isCompleted = false;
      this.promise = new Promise((resolve, reject) => {
        this._resolver = resolve;
        this._rejecter = reject;
      });
    }
    get isCompleted() {
      return this._isCompleted;
    }
    resolve(value) {
      if (this._isCompleted) {
        return;
      }
      this._isCompleted = true;
      this._resolver(value);
    }
    reject(error) {
      if (this._isCompleted) {
        return;
      }
      this._isCompleted = true;
      this._rejecter(error);
    }
  }
  function getPosition(el2) {
    let oLeft = 0, oTop = 0;
    const calcOffsetLeft = (parent) => {
      oLeft += parent.offsetLeft;
      if (parent.offsetParent) {
        calcOffsetLeft(parent.offsetParent);
      }
    };
    const calcOffsetTop = (parent) => {
      oTop += parent.offsetTop;
      if (parent.offsetParent) {
        calcOffsetTop(parent.offsetParent);
      }
    };
    calcOffsetLeft(el2);
    calcOffsetTop(el2);
    return new Vector(oLeft, oTop);
  }
  function addItemToArray(item, array) {
    if (array.indexOf(item) === -1) {
      array.push(item);
      return true;
    }
    return false;
  }
  function removeItemFromArray(item, array) {
    let index = -1;
    if ((index = array.indexOf(item)) > -1) {
      array.splice(index, 1);
      return true;
    }
    return false;
  }
  function contains(array, obj) {
    for (let i2 = 0; i2 < array.length; i2++) {
      if (array[i2] === obj) {
        return true;
      }
    }
    return false;
  }
  function fail(message) {
    throw new Error(message);
  }
  function delay2(milliseconds, clock) {
    var _a;
    const future = new Future();
    const schedule = (_a = clock === null || clock === void 0 ? void 0 : clock.schedule.bind(clock)) !== null && _a !== void 0 ? _a : setTimeout;
    schedule(() => {
      future.resolve();
    }, milliseconds);
    return future.promise;
  }
  var MatrixLocations;
  (function(MatrixLocations2) {
    MatrixLocations2[MatrixLocations2["X"] = 12] = "X";
    MatrixLocations2[MatrixLocations2["Y"] = 13] = "Y";
  })(MatrixLocations || (MatrixLocations = {}));
  class Matrix {
    constructor() {
      this.data = new Float32Array(16);
      this._scaleX = 1;
      this._scaleSignX = 1;
      this._scaleY = 1;
      this._scaleSignY = 1;
    }
    /**
     * Creates an orthographic (flat non-perspective) projection
     * https://en.wikipedia.org/wiki/Orthographic_projection
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    static ortho(left, right, bottom, top, near, far) {
      const mat = new Matrix();
      mat.data[0] = 2 / (right - left);
      mat.data[1] = 0;
      mat.data[2] = 0;
      mat.data[3] = 0;
      mat.data[4] = 0;
      mat.data[5] = 2 / (top - bottom);
      mat.data[6] = 0;
      mat.data[7] = 0;
      mat.data[8] = 0;
      mat.data[9] = 0;
      mat.data[10] = -2 / (far - near);
      mat.data[11] = 0;
      mat.data[12] = -(right + left) / (right - left);
      mat.data[13] = -(top + bottom) / (top - bottom);
      mat.data[14] = -(far + near) / (far - near);
      mat.data[15] = 1;
      return mat;
    }
    /**
     * Creates a new Matrix with the same data as the current 4x4
     */
    clone(dest) {
      const mat = dest || new Matrix();
      mat.data[0] = this.data[0];
      mat.data[1] = this.data[1];
      mat.data[2] = this.data[2];
      mat.data[3] = this.data[3];
      mat.data[4] = this.data[4];
      mat.data[5] = this.data[5];
      mat.data[6] = this.data[6];
      mat.data[7] = this.data[7];
      mat.data[8] = this.data[8];
      mat.data[9] = this.data[9];
      mat.data[10] = this.data[10];
      mat.data[11] = this.data[11];
      mat.data[12] = this.data[12];
      mat.data[13] = this.data[13];
      mat.data[14] = this.data[14];
      mat.data[15] = this.data[15];
      return mat;
    }
    /**
     * Converts the current matrix into a DOMMatrix
     *
     * This is useful when working with the browser Canvas context
     * @returns {DOMMatrix} DOMMatrix
     */
    toDOMMatrix() {
      return new DOMMatrix([...this.data]);
    }
    static fromFloat32Array(data) {
      const matrix = new Matrix();
      matrix.data = data;
      return matrix;
    }
    /**
     * Creates a new identity matrix (a matrix that when applied does nothing)
     */
    static identity() {
      const mat = new Matrix();
      mat.data[0] = 1;
      mat.data[1] = 0;
      mat.data[2] = 0;
      mat.data[3] = 0;
      mat.data[4] = 0;
      mat.data[5] = 1;
      mat.data[6] = 0;
      mat.data[7] = 0;
      mat.data[8] = 0;
      mat.data[9] = 0;
      mat.data[10] = 1;
      mat.data[11] = 0;
      mat.data[12] = 0;
      mat.data[13] = 0;
      mat.data[14] = 0;
      mat.data[15] = 1;
      return mat;
    }
    /**
     * Resets the current matrix to the identity matrix, mutating it
     * @returns {Matrix} Current matrix as identity
     */
    reset() {
      const mat = this;
      mat.data[0] = 1;
      mat.data[1] = 0;
      mat.data[2] = 0;
      mat.data[3] = 0;
      mat.data[4] = 0;
      mat.data[5] = 1;
      mat.data[6] = 0;
      mat.data[7] = 0;
      mat.data[8] = 0;
      mat.data[9] = 0;
      mat.data[10] = 1;
      mat.data[11] = 0;
      mat.data[12] = 0;
      mat.data[13] = 0;
      mat.data[14] = 0;
      mat.data[15] = 1;
      return mat;
    }
    /**
     * Creates a brand new translation matrix at the specified 3d point
     * @param x
     * @param y
     */
    static translation(x2, y2) {
      const mat = Matrix.identity();
      mat.data[12] = x2;
      mat.data[13] = y2;
      return mat;
    }
    /**
     * Creates a brand new scaling matrix with the specified scaling factor
     * @param sx
     * @param sy
     */
    static scale(sx, sy) {
      const mat = Matrix.identity();
      mat.data[0] = sx;
      mat.data[5] = sy;
      mat.data[10] = 1;
      mat.data[15] = 1;
      return mat;
    }
    /**
     * Creates a brand new rotation matrix with the specified angle
     * @param angleRadians
     */
    static rotation(angleRadians) {
      const mat = Matrix.identity();
      mat.data[0] = Math.cos(angleRadians);
      mat.data[4] = -Math.sin(angleRadians);
      mat.data[1] = Math.sin(angleRadians);
      mat.data[5] = Math.cos(angleRadians);
      return mat;
    }
    multiply(vectorOrMatrix, dest) {
      if (vectorOrMatrix instanceof Vector) {
        const result = dest || new Vector(0, 0);
        const vector2 = vectorOrMatrix;
        const resultX = vector2.x * this.data[0] + vector2.y * this.data[4] + this.data[12];
        const resultY = vector2.x * this.data[1] + vector2.y * this.data[5] + this.data[13];
        result.x = resultX;
        result.y = resultY;
        return result;
      } else {
        const result = dest || new Matrix();
        const other = vectorOrMatrix;
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const a13 = this.data[8];
        const a23 = this.data[9];
        const a33 = this.data[10];
        const a43 = this.data[11];
        const a14 = this.data[12];
        const a24 = this.data[13];
        const a34 = this.data[14];
        const a44 = this.data[15];
        const b11 = other.data[0];
        const b21 = other.data[1];
        const b31 = other.data[2];
        const b41 = other.data[3];
        const b12 = other.data[4];
        const b22 = other.data[5];
        const b32 = other.data[6];
        const b42 = other.data[7];
        const b13 = other.data[8];
        const b23 = other.data[9];
        const b33 = other.data[10];
        const b43 = other.data[11];
        const b14 = other.data[12];
        const b24 = other.data[13];
        const b34 = other.data[14];
        const b44 = other.data[15];
        result.data[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        result.data[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        result.data[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        result.data[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        result.data[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        result.data[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        result.data[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        result.data[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        result.data[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        result.data[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        result.data[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        result.data[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        result.data[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        result.data[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        result.data[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        result.data[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        const s2 = this.getScale();
        result._scaleSignX = sign(s2.x) * sign(result._scaleSignX);
        result._scaleSignY = sign(s2.y) * sign(result._scaleSignY);
        return result;
      }
    }
    /**
     * Applies translation to the current matrix mutating it
     * @param x
     * @param y
     */
    translate(x2, y2) {
      const a11 = this.data[0];
      const a21 = this.data[1];
      const a31 = this.data[2];
      const a41 = this.data[3];
      const a12 = this.data[4];
      const a22 = this.data[5];
      const a32 = this.data[6];
      const a42 = this.data[7];
      const a13 = this.data[8];
      const a23 = this.data[9];
      const a33 = this.data[10];
      const a43 = this.data[11];
      const a14 = this.data[12];
      const a24 = this.data[13];
      const a34 = this.data[14];
      const a44 = this.data[15];
      const z2 = 0;
      const w2 = 1;
      this.data[12] = a11 * x2 + a12 * y2 + a13 * z2 + a14 * w2;
      this.data[13] = a21 * x2 + a22 * y2 + a23 * z2 + a24 * w2;
      this.data[14] = a31 * x2 + a32 * y2 + a33 * z2 + a34 * w2;
      this.data[15] = a41 * x2 + a42 * y2 + a43 * z2 + a44 * w2;
      return this;
    }
    setPosition(x2, y2) {
      this.data[12] = x2;
      this.data[13] = y2;
    }
    getPosition() {
      return vec(this.data[12], this.data[13]);
    }
    /**
     * Applies rotation to the current matrix mutating it
     * @param angle in Radians
     */
    rotate(angle) {
      const a11 = this.data[0];
      const a21 = this.data[1];
      const a31 = this.data[2];
      const a41 = this.data[3];
      const a12 = this.data[4];
      const a22 = this.data[5];
      const a32 = this.data[6];
      const a42 = this.data[7];
      const sine = Math.sin(angle);
      const cosine = Math.cos(angle);
      this.data[0] = cosine * a11 + sine * a12;
      this.data[1] = cosine * a21 + sine * a22;
      this.data[2] = cosine * a31 + sine * a32;
      this.data[3] = cosine * a41 + sine * a42;
      this.data[4] = cosine * a12 - sine * a11;
      this.data[5] = cosine * a22 - sine * a21;
      this.data[6] = cosine * a32 - sine * a31;
      this.data[7] = cosine * a42 - sine * a41;
      return this;
    }
    /**
     * Applies scaling to the current matrix mutating it
     * @param x
     * @param y
     */
    scale(x2, y2) {
      const a11 = this.data[0];
      const a21 = this.data[1];
      const a31 = this.data[2];
      const a41 = this.data[3];
      const a12 = this.data[4];
      const a22 = this.data[5];
      const a32 = this.data[6];
      const a42 = this.data[7];
      this.data[0] = a11 * x2;
      this.data[1] = a21 * x2;
      this.data[2] = a31 * x2;
      this.data[3] = a41 * x2;
      this.data[4] = a12 * y2;
      this.data[5] = a22 * y2;
      this.data[6] = a32 * y2;
      this.data[7] = a42 * y2;
      return this;
    }
    setRotation(angle) {
      const currentScale = this.getScale();
      const sine = Math.sin(angle);
      const cosine = Math.cos(angle);
      this.data[0] = cosine * currentScale.x;
      this.data[1] = sine * currentScale.y;
      this.data[4] = -sine * currentScale.x;
      this.data[5] = cosine * currentScale.y;
    }
    getRotation() {
      const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());
      return canonicalizeAngle(angle);
    }
    getScaleX() {
      const xscale = vec(this.data[0], this.data[4]).size;
      return this._scaleSignX * xscale;
    }
    getScaleY() {
      const yscale = vec(this.data[1], this.data[5]).size;
      return this._scaleSignY * yscale;
    }
    /**
     * Get the scale of the matrix
     */
    getScale() {
      return vec(this.getScaleX(), this.getScaleY());
    }
    setScaleX(val) {
      if (this._scaleX === val) {
        return;
      }
      this._scaleSignX = sign(val);
      const xscale = vec(this.data[0] * this._scaleSignX, this.data[4] * this._scaleSignX).normalize();
      this.data[0] = xscale.x * val;
      this.data[4] = xscale.y * val;
      this._scaleX = val;
    }
    setScaleY(val) {
      if (this._scaleY === val) {
        return;
      }
      this._scaleSignY = sign(val);
      const yscale = vec(this.data[1] * this._scaleSignY, this.data[5] * this._scaleSignY).normalize();
      this.data[1] = yscale.x * val;
      this.data[5] = yscale.y * val;
      this._scaleY = val;
    }
    setScale(scale2) {
      this.setScaleX(scale2.x);
      this.setScaleY(scale2.y);
    }
    /**
     * Determinant of the upper left 2x2 matrix
     */
    getBasisDeterminant() {
      return this.data[0] * this.data[5] - this.data[1] * this.data[4];
    }
    /**
     * Return the affine inverse, optionally store it in a target matrix.
     *
     * It's recommended you call .reset() the target unless you know what you're doing
     * @param target
     */
    getAffineInverse(target) {
      const det = this.getBasisDeterminant();
      const inverseDet = 1 / det;
      const a2 = this.data[0];
      const b2 = this.data[4];
      const c2 = this.data[1];
      const d2 = this.data[5];
      const m2 = target || Matrix.identity();
      m2.data[0] = d2 * inverseDet;
      m2.data[1] = -c2 * inverseDet;
      m2.data[4] = -b2 * inverseDet;
      m2.data[5] = a2 * inverseDet;
      const tx = this.data[12];
      const ty = this.data[13];
      m2.data[12] = -(tx * m2.data[0] + ty * m2.data[4]);
      m2.data[13] = -(tx * m2.data[1] + ty * m2.data[5]);
      return m2;
    }
    isIdentity() {
      return this.data[0] === 1 && this.data[1] === 0 && this.data[2] === 0 && this.data[3] === 0 && this.data[4] === 0 && this.data[5] === 1 && this.data[6] === 0 && this.data[7] === 0 && this.data[8] === 0 && this.data[9] === 0 && this.data[10] === 1 && this.data[11] === 0 && this.data[12] === 0 && this.data[13] === 0 && this.data[14] === 0 && this.data[15] === 1;
    }
    toString() {
      return `
[${this.data[0]} ${this.data[4]} ${this.data[8]} ${this.data[12]}]
[${this.data[1]} ${this.data[5]} ${this.data[9]} ${this.data[13]}]
[${this.data[2]} ${this.data[6]} ${this.data[10]} ${this.data[14]}]
[${this.data[3]} ${this.data[7]} ${this.data[11]} ${this.data[15]}]
`;
    }
  }
  class AffineMatrix {
    constructor() {
      this.data = new Float64Array(6);
      this._scale = new Float64Array([1, 1]);
      this._scaleSignX = 1;
      this._scaleSignY = 1;
    }
    /**
     * Converts the current matrix into a DOMMatrix
     *
     * This is useful when working with the browser Canvas context
     * @returns {DOMMatrix} DOMMatrix
     */
    toDOMMatrix() {
      return new DOMMatrix([...this.data]);
    }
    static identity() {
      const mat = new AffineMatrix();
      mat.data[0] = 1;
      mat.data[1] = 0;
      mat.data[2] = 0;
      mat.data[3] = 1;
      mat.data[4] = 0;
      mat.data[5] = 0;
      return mat;
    }
    /**
     * Creates a brand new translation matrix at the specified 3d point
     * @param x
     * @param y
     */
    static translation(x2, y2) {
      const mat = AffineMatrix.identity();
      mat.data[4] = x2;
      mat.data[5] = y2;
      return mat;
    }
    /**
     * Creates a brand new scaling matrix with the specified scaling factor
     * @param sx
     * @param sy
     */
    static scale(sx, sy) {
      const mat = AffineMatrix.identity();
      mat.data[0] = sx;
      mat.data[3] = sy;
      mat._scale[0] = sx;
      mat._scale[1] = sy;
      return mat;
    }
    /**
     * Creates a brand new rotation matrix with the specified angle
     * @param angleRadians
     */
    static rotation(angleRadians) {
      const mat = AffineMatrix.identity();
      mat.data[0] = Math.cos(angleRadians);
      mat.data[1] = Math.sin(angleRadians);
      mat.data[2] = -Math.sin(angleRadians);
      mat.data[3] = Math.cos(angleRadians);
      return mat;
    }
    setPosition(x2, y2) {
      this.data[4] = x2;
      this.data[5] = y2;
    }
    getPosition() {
      return vec(this.data[4], this.data[5]);
    }
    /**
     * Applies rotation to the current matrix mutating it
     * @param angle in Radians
     */
    rotate(angle) {
      const a11 = this.data[0];
      const a21 = this.data[1];
      const a12 = this.data[2];
      const a22 = this.data[3];
      const sine = Math.sin(angle);
      const cosine = Math.cos(angle);
      this.data[0] = cosine * a11 + sine * a12;
      this.data[1] = cosine * a21 + sine * a22;
      this.data[2] = cosine * a12 - sine * a11;
      this.data[3] = cosine * a22 - sine * a21;
      return this;
    }
    /**
     * Applies translation to the current matrix mutating it
     * @param x
     * @param y
     */
    translate(x2, y2) {
      const a11 = this.data[0];
      const a21 = this.data[1];
      const a12 = this.data[2];
      const a22 = this.data[3];
      const a13 = this.data[4];
      const a23 = this.data[5];
      this.data[4] = a11 * x2 + a12 * y2 + a13;
      this.data[5] = a21 * x2 + a22 * y2 + a23;
      return this;
    }
    /**
     * Applies scaling to the current matrix mutating it
     * @param x
     * @param y
     */
    scale(x2, y2) {
      const a11 = this.data[0];
      const a21 = this.data[1];
      const a12 = this.data[2];
      const a22 = this.data[3];
      this.data[0] = a11 * x2;
      this.data[1] = a21 * x2;
      this.data[2] = a12 * y2;
      this.data[3] = a22 * y2;
      this._scale[0] = x2;
      this._scale[1] = y2;
      return this;
    }
    determinant() {
      return this.data[0] * this.data[3] - this.data[1] * this.data[2];
    }
    /**
     * Return the affine inverse, optionally store it in a target matrix.
     *
     * It's recommended you call .reset() the target unless you know what you're doing
     * @param target
     */
    inverse(target) {
      const det = this.determinant();
      const inverseDet = 1 / det;
      const a2 = this.data[0];
      const b2 = this.data[2];
      const c2 = this.data[1];
      const d2 = this.data[3];
      const m2 = target || AffineMatrix.identity();
      m2.data[0] = d2 * inverseDet;
      m2.data[1] = -c2 * inverseDet;
      m2.data[2] = -b2 * inverseDet;
      m2.data[3] = a2 * inverseDet;
      const tx = this.data[4];
      const ty = this.data[5];
      m2.data[4] = -(tx * m2.data[0] + ty * m2.data[2]);
      m2.data[5] = -(tx * m2.data[1] + ty * m2.data[3]);
      return m2;
    }
    multiply(vectorOrMatrix, dest) {
      if (vectorOrMatrix instanceof Vector) {
        const result = dest || new Vector(0, 0);
        const vector2 = vectorOrMatrix;
        const resultX = vector2.x * this.data[0] + vector2.y * this.data[2] + this.data[4];
        const resultY = vector2.x * this.data[1] + vector2.y * this.data[3] + this.data[5];
        result.x = resultX;
        result.y = resultY;
        return result;
      } else {
        const result = dest || new AffineMatrix();
        const other = vectorOrMatrix;
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a12 = this.data[2];
        const a22 = this.data[3];
        const a13 = this.data[4];
        const a23 = this.data[5];
        const b11 = other.data[0];
        const b21 = other.data[1];
        const b12 = other.data[2];
        const b22 = other.data[3];
        const b13 = other.data[4];
        const b23 = other.data[5];
        result.data[0] = a11 * b11 + a12 * b21;
        result.data[1] = a21 * b11 + a22 * b21;
        result.data[2] = a11 * b12 + a12 * b22;
        result.data[3] = a21 * b12 + a22 * b22;
        result.data[4] = a11 * b13 + a12 * b23 + a13;
        result.data[5] = a21 * b13 + a22 * b23 + a23;
        const s2 = this.getScale();
        result._scaleSignX = sign(s2.x) * sign(result._scaleSignX);
        result._scaleSignY = sign(s2.y) * sign(result._scaleSignY);
        return result;
      }
    }
    to4x4() {
      const mat = new Matrix();
      mat.data[0] = this.data[0];
      mat.data[1] = this.data[1];
      mat.data[2] = 0;
      mat.data[3] = 0;
      mat.data[4] = this.data[2];
      mat.data[5] = this.data[3];
      mat.data[6] = 0;
      mat.data[7] = 0;
      mat.data[8] = 0;
      mat.data[9] = 0;
      mat.data[10] = 1;
      mat.data[11] = 0;
      mat.data[12] = this.data[4];
      mat.data[13] = this.data[5];
      mat.data[14] = 0;
      mat.data[15] = 1;
      return mat;
    }
    setRotation(angle) {
      const currentScale = this.getScale();
      const sine = Math.sin(angle);
      const cosine = Math.cos(angle);
      this.data[0] = cosine * currentScale.x;
      this.data[1] = sine * currentScale.y;
      this.data[2] = -sine * currentScale.x;
      this.data[3] = cosine * currentScale.y;
    }
    getRotation() {
      const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());
      return canonicalizeAngle(angle);
    }
    getScaleX() {
      const xscale = vec(this.data[0], this.data[2]).distance();
      return this._scaleSignX * xscale;
    }
    getScaleY() {
      const yscale = vec(this.data[1], this.data[3]).distance();
      return this._scaleSignY * yscale;
    }
    /**
     * Get the scale of the matrix
     */
    getScale() {
      return vec(this.getScaleX(), this.getScaleY());
    }
    setScaleX(val) {
      if (val === this._scale[0]) {
        return;
      }
      this._scaleSignX = sign(val);
      const xscale = vec(this.data[0] * this._scaleSignX, this.data[2] * this._scaleSignX).normalize();
      this.data[0] = xscale.x * val;
      this.data[2] = xscale.y * val;
      this._scale[0] = val;
    }
    setScaleY(val) {
      if (val === this._scale[1]) {
        return;
      }
      this._scaleSignY = sign(val);
      const yscale = vec(this.data[1] * this._scaleSignY, this.data[3] * this._scaleSignY).normalize();
      this.data[1] = yscale.x * val;
      this.data[3] = yscale.y * val;
      this._scale[1] = val;
    }
    setScale(scale2) {
      this.setScaleX(scale2.x);
      this.setScaleY(scale2.y);
    }
    isIdentity() {
      return this.data[0] === 1 && this.data[1] === 0 && this.data[2] === 0 && this.data[3] === 1 && this.data[4] === 0 && this.data[5] === 0;
    }
    /**
     * Resets the current matrix to the identity matrix, mutating it
     * @returns {AffineMatrix} Current matrix as identity
     */
    reset() {
      const mat = this;
      mat.data[0] = 1;
      mat.data[1] = 0;
      mat.data[2] = 0;
      mat.data[3] = 1;
      mat.data[4] = 0;
      mat.data[5] = 0;
      return mat;
    }
    /**
     * Creates a new Matrix with the same data as the current 4x4
     */
    clone(dest) {
      const mat = dest || new AffineMatrix();
      mat.data[0] = this.data[0];
      mat.data[1] = this.data[1];
      mat.data[2] = this.data[2];
      mat.data[3] = this.data[3];
      mat.data[4] = this.data[4];
      mat.data[5] = this.data[5];
      return mat;
    }
    toString() {
      return `
[${this.data[0]} ${this.data[2]} ${this.data[4]}]
[${this.data[1]} ${this.data[3]} ${this.data[5]}]
[0 0 1]
`;
    }
  }
  class TransformStack {
    constructor() {
      this._transforms = [];
      this._currentTransform = AffineMatrix.identity();
    }
    save() {
      this._transforms.push(this._currentTransform);
      this._currentTransform = this._currentTransform.clone();
    }
    restore() {
      this._currentTransform = this._transforms.pop();
    }
    translate(x2, y2) {
      return this._currentTransform.translate(x2, y2);
    }
    rotate(angle) {
      return this._currentTransform.rotate(angle);
    }
    scale(x2, y2) {
      return this._currentTransform.scale(x2, y2);
    }
    set current(matrix) {
      this._currentTransform = matrix;
    }
    get current() {
      return this._currentTransform;
    }
  }
  class StateStack {
    constructor() {
      this._states = [];
      this._currentState = this._getDefaultState();
    }
    _getDefaultState() {
      return {
        opacity: 1,
        z: 0,
        tint: Color.White,
        material: null
      };
    }
    _cloneState() {
      return {
        opacity: this._currentState.opacity,
        z: this._currentState.z,
        tint: this._currentState.tint.clone(),
        material: this._currentState.material
        // TODO is this going to cause problems when cloning
      };
    }
    save() {
      this._states.push(this._currentState);
      this._currentState = this._cloneState();
    }
    restore() {
      this._currentState = this._states.pop();
    }
    get current() {
      return this._currentState;
    }
    set current(val) {
      this._currentState = val;
    }
  }
  const ResourceEvents = {
    Complete: "complete",
    Load: "load",
    LoadStart: "loadstart",
    Progress: "progress",
    Error: "error"
  };
  class Resource {
    /**
     * @param path          Path to the remote resource
     * @param responseType  The type to expect as a response: "" | "arraybuffer" | "blob" | "document" | "json" | "text";
     * @param bustCache     Whether or not to cache-bust requests
     */
    constructor(path, responseType, bustCache = false) {
      this.path = path;
      this.responseType = responseType;
      this.bustCache = bustCache;
      this.data = null;
      this.logger = Logger2.getInstance();
      this.events = new EventEmitter2();
    }
    /**
     * Returns true if the Resource is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
      return this.data !== null;
    }
    _cacheBust(uri) {
      const query = /\?\w*=\w*/;
      if (query.test(uri)) {
        uri += "&__=" + Date.now();
      } else {
        uri += "?__=" + Date.now();
      }
      return uri;
    }
    /**
     * Begin loading the resource and returns a promise to be resolved on completion
     */
    load() {
      return new Promise((resolve, reject) => {
        if (this.data !== null) {
          this.logger.debug("Already have data for resource", this.path);
          this.events.emit("complete", this.data);
          resolve(this.data);
          return;
        }
        const request = new XMLHttpRequest();
        request.open("GET", this.bustCache ? this._cacheBust(this.path) : this.path, true);
        request.responseType = this.responseType;
        request.addEventListener("loadstart", (e2) => this.events.emit("loadstart", e2));
        request.addEventListener("progress", (e2) => this.events.emit("progress", e2));
        request.addEventListener("error", (e2) => this.events.emit("error", e2));
        request.addEventListener("load", (e2) => this.events.emit("load", e2));
        request.addEventListener("load", () => {
          if (request.status !== 0 && request.status !== 200) {
            this.logger.error("Failed to load resource ", this.path, " server responded with error code", request.status);
            this.events.emit("error", request.response);
            reject(new Error(request.statusText));
            return;
          }
          this.data = request.response;
          this.events.emit("complete", this.data);
          this.logger.debug("Completed loading resource", this.path);
          resolve(this.data);
        });
        request.send();
      });
    }
  }
  function watch(type, change) {
    if (!type) {
      return type;
    }
    if (type.__isProxy === void 0) {
      return new Proxy(type, {
        set: (obj, prop, value) => {
          if (obj[prop] !== value) {
            obj[prop] = value;
            if (typeof prop === "string") {
              if (prop[0] !== "_") {
                change(obj);
              }
            }
          }
          return true;
        },
        get: (obj, prop) => {
          if (prop !== "__isProxy") {
            return obj[prop];
          }
          return true;
        }
      });
    }
    return type;
  }
  function watchAny(type, change) {
    if (!type) {
      return type;
    }
    if (type.__isProxy === void 0) {
      return new Proxy(type, {
        set: (obj, prop, value) => {
          obj[prop] = value;
          if (typeof prop === "string") {
            if (prop[0] !== "_") {
              change(obj);
            }
          }
          return true;
        },
        get: (obj, prop) => {
          if (prop !== "__isProxy") {
            return obj[prop];
          }
          return true;
        }
      });
    }
    return type;
  }
  class Graphic {
    isStale() {
      return this._transformStale;
    }
    /**
     * Gets or sets the flipHorizontal, which will flip the graphic horizontally (across the y axis)
     */
    get flipHorizontal() {
      return this._flipHorizontal;
    }
    set flipHorizontal(value) {
      this._flipHorizontal = value;
      this._transformStale = true;
    }
    /**
     * Gets or sets the flipVertical, which will flip the graphic vertically (across the x axis)
     */
    get flipVertical() {
      return this._flipVertical;
    }
    set flipVertical(value) {
      this._flipVertical = value;
      this._transformStale = true;
    }
    /**
     * Gets or sets the rotation of the graphic
     */
    get rotation() {
      return this._rotation;
    }
    set rotation(value) {
      this._rotation = value;
      this._transformStale = true;
    }
    /**
     * Gets or sets the scale of the graphic, this affects the width and
     */
    get scale() {
      return this._scale;
    }
    set scale(value) {
      this._scale = watch(value, () => {
        this._transformStale = true;
      });
      this._transformStale = true;
    }
    /**
     * Gets or sets the origin of the graphic, if not set the center of the graphic is the origin
     */
    get origin() {
      return this._origin;
    }
    set origin(value) {
      this._origin = watch(value, () => {
        this._transformStale = true;
      });
      this._transformStale = true;
    }
    constructor(options) {
      var _a, _b, _c, _d, _e, _f;
      this.id = Graphic._ID++;
      this.transform = AffineMatrix.identity();
      this.tint = null;
      this._transformStale = true;
      this.showDebug = false;
      this._flipHorizontal = false;
      this._flipVertical = false;
      this._rotation = 0;
      this.opacity = 1;
      this._scale = Vector.One;
      this._origin = null;
      this._width = 0;
      this._height = 0;
      if (options) {
        this.origin = (_a = options.origin) !== null && _a !== void 0 ? _a : this.origin;
        this.flipHorizontal = (_b = options.flipHorizontal) !== null && _b !== void 0 ? _b : this.flipHorizontal;
        this.flipVertical = (_c = options.flipVertical) !== null && _c !== void 0 ? _c : this.flipVertical;
        this.rotation = (_d = options.rotation) !== null && _d !== void 0 ? _d : this.rotation;
        this.opacity = (_e = options.opacity) !== null && _e !== void 0 ? _e : this.opacity;
        this.scale = (_f = options.scale) !== null && _f !== void 0 ? _f : this.scale;
      }
    }
    cloneGraphicOptions() {
      return {
        origin: this.origin ? this.origin.clone() : null,
        flipHorizontal: this.flipHorizontal,
        flipVertical: this.flipVertical,
        rotation: this.rotation,
        opacity: this.opacity,
        scale: this.scale ? this.scale.clone() : null
      };
    }
    /**
     * Gets or sets the width of the graphic (always positive)
     */
    get width() {
      return Math.abs(this._width * this.scale.x);
    }
    /**
     * Gets or sets the height of the graphic (always positive)
     */
    get height() {
      return Math.abs(this._height * this.scale.y);
    }
    set width(value) {
      this._width = value;
      this._transformStale = true;
    }
    set height(value) {
      this._height = value;
      this._transformStale = true;
    }
    /**
     * Gets a copy of the bounds in pixels occupied by the graphic on the the screen. This includes scale.
     */
    get localBounds() {
      return BoundingBox.fromDimension(this.width, this.height, Vector.Zero);
    }
    /**
     * Draw the whole graphic to the context including transform
     * @param ex The excalibur graphics context
     * @param x
     * @param y
     */
    draw(ex, x2, y2) {
      this._preDraw(ex, x2, y2);
      this._drawImage(ex, 0, 0);
      this._postDraw(ex);
    }
    /**
     * Apply affine transformations to the graphics context to manipulate the graphic before [[Graphic._drawImage]]
     * @param ex
     * @param x
     * @param y
     */
    _preDraw(ex, x2, y2) {
      ex.save();
      ex.translate(x2, y2);
      if (this._transformStale) {
        this.transform.reset();
        this.transform.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));
        this._rotate(this.transform);
        this._flip(this.transform);
        this._transformStale = false;
      }
      ex.multiply(this.transform);
      ex.opacity = ex.opacity * this.opacity;
      if (this.tint) {
        ex.tint = this.tint;
      }
    }
    _rotate(ex) {
      var _a;
      const scaleDirX = this.scale.x > 0 ? 1 : -1;
      const scaleDirY = this.scale.y > 0 ? 1 : -1;
      const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : vec(this.width / 2, this.height / 2);
      ex.translate(origin.x, origin.y);
      ex.rotate(this.rotation);
      ex.scale(scaleDirX, scaleDirY);
      ex.translate(-origin.x, -origin.y);
    }
    _flip(ex) {
      if (this.flipHorizontal) {
        ex.translate(this.width / this.scale.x, 0);
        ex.scale(-1, 1);
      }
      if (this.flipVertical) {
        ex.translate(0, this.height / this.scale.y);
        ex.scale(1, -1);
      }
    }
    /**
     * Apply any additional work after [[Graphic._drawImage]] and restore the context state.
     * @param ex
     */
    _postDraw(ex) {
      if (this.showDebug) {
        ex.debug.drawRect(0, 0, this.width, this.height);
      }
      ex.restore();
    }
  }
  Graphic._ID = 0;
  class Sprite extends Graphic {
    static from(image) {
      return new Sprite({
        image
      });
    }
    constructor(options) {
      var _a, _b;
      super(options);
      this._logger = Logger2.getInstance();
      this._dirty = true;
      this._logNotLoadedWarning = false;
      this.image = options.image;
      const { width, height } = options;
      this.sourceView = (_a = options.sourceView) !== null && _a !== void 0 ? _a : { x: 0, y: 0, width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };
      this.destSize = (_b = options.destSize) !== null && _b !== void 0 ? _b : { width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };
      this._updateSpriteDimensions();
      this.image.ready.then(() => {
        this._updateSpriteDimensions();
      });
    }
    get width() {
      return Math.abs(this.destSize.width * this.scale.x);
    }
    get height() {
      return Math.abs(this.destSize.height * this.scale.y);
    }
    set width(newWidth) {
      newWidth /= Math.abs(this.scale.x);
      this.destSize.width = newWidth;
      super.width = Math.ceil(this.destSize.width);
    }
    set height(newHeight) {
      newHeight /= Math.abs(this.scale.y);
      this.destSize.height = newHeight;
      super.height = Math.ceil(this.destSize.height);
    }
    _updateSpriteDimensions() {
      var _a, _b, _c, _d, _e, _f;
      const { width: nativeWidth, height: nativeHeight } = this.image;
      this.sourceView.width = ((_a = this.sourceView) === null || _a === void 0 ? void 0 : _a.width) || nativeWidth;
      this.sourceView.height = ((_b = this.sourceView) === null || _b === void 0 ? void 0 : _b.height) || nativeHeight;
      this.destSize.width = ((_c = this.destSize) === null || _c === void 0 ? void 0 : _c.width) || ((_d = this.sourceView) === null || _d === void 0 ? void 0 : _d.width) || nativeWidth;
      this.destSize.height = ((_e = this.destSize) === null || _e === void 0 ? void 0 : _e.height) || ((_f = this.sourceView) === null || _f === void 0 ? void 0 : _f.height) || nativeHeight;
      this.width = Math.ceil(this.destSize.width) * this.scale.x;
      this.height = Math.ceil(this.destSize.height) * this.scale.y;
    }
    _preDraw(ex, x2, y2) {
      if (this.image.isLoaded() && this._dirty) {
        this._dirty = false;
        this._updateSpriteDimensions();
      }
      super._preDraw(ex, x2, y2);
    }
    _drawImage(ex, x2, y2) {
      if (this.image.isLoaded()) {
        ex.drawImage(this.image.image, this.sourceView.x, this.sourceView.y, this.sourceView.width, this.sourceView.height, x2, y2, this.destSize.width, this.destSize.height);
      } else {
        if (!this._logNotLoadedWarning) {
          this._logger.warn(`ImageSource ${this.image.path} is not yet loaded and won't be drawn. Please call .load() or include in a Loader.

Read https://excaliburjs.com/docs/imagesource for more information.`);
        }
        this._logNotLoadedWarning = true;
      }
    }
    clone() {
      return new Sprite({
        image: this.image,
        sourceView: { ...this.sourceView },
        destSize: { ...this.destSize },
        ...this.cloneGraphicOptions()
      });
    }
  }
  var ImageFiltering;
  (function(ImageFiltering2) {
    ImageFiltering2["Pixel"] = "Pixel";
    ImageFiltering2["Blended"] = "Blended";
  })(ImageFiltering || (ImageFiltering = {}));
  class TextureLoader {
    constructor(gl2) {
      this._textureMap = /* @__PURE__ */ new Map();
      this._gl = gl2;
      TextureLoader._MAX_TEXTURE_SIZE = gl2.getParameter(gl2.MAX_TEXTURE_SIZE);
    }
    /**
     * Get the WebGL Texture from a source image
     * @param image
     */
    get(image) {
      return this._textureMap.get(image);
    }
    /**
     * Returns whether a source image has been loaded as a texture
     * @param image
     */
    has(image) {
      return this._textureMap.has(image);
    }
    /**
     * Loads a graphic into webgl and returns it's texture info, a webgl context must be previously registered
     * @param image Source graphic
     * @param filtering {ImageFiltering} The ImageFiltering mode to apply to the loaded texture
     * @param forceUpdate Optionally force a texture to be reloaded, useful if the source graphic has changed
     */
    load(image, filtering, forceUpdate = false) {
      const gl2 = this._gl;
      if (!gl2) {
        return null;
      }
      let tex = null;
      if (this.has(image)) {
        tex = this.get(image);
      }
      if (tex) {
        if (forceUpdate) {
          gl2.bindTexture(gl2.TEXTURE_2D, tex);
          gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, gl2.RGBA, gl2.UNSIGNED_BYTE, image);
        }
        return tex;
      }
      tex = gl2.createTexture();
      TextureLoader.checkImageSizeSupportedAndLog(image);
      gl2.bindTexture(gl2.TEXTURE_2D, tex);
      gl2.pixelStorei(gl2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, gl2.CLAMP_TO_EDGE);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, gl2.CLAMP_TO_EDGE);
      const filterMode = filtering !== null && filtering !== void 0 ? filtering : TextureLoader.filtering;
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, filterMode === ImageFiltering.Pixel ? gl2.NEAREST : gl2.LINEAR);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, filterMode === ImageFiltering.Pixel ? gl2.NEAREST : gl2.LINEAR);
      gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, gl2.RGBA, gl2.UNSIGNED_BYTE, image);
      this._textureMap.set(image, tex);
      return tex;
    }
    delete(image) {
      const gl2 = this._gl;
      if (!gl2) {
        return null;
      }
      let tex = null;
      if (this.has(image)) {
        tex = this.get(image);
        gl2.deleteTexture(tex);
      }
    }
    /**
     * Takes an image and returns if it meets size criteria for hardware
     * @param image
     * @returns if the image will be supported at runtime
     */
    static checkImageSizeSupportedAndLog(image) {
      var _a;
      const originalSrc = (_a = image.dataset.originalSrc) !== null && _a !== void 0 ? _a : "internal canvas bitmap";
      if (image.width > TextureLoader._MAX_TEXTURE_SIZE || image.height > TextureLoader._MAX_TEXTURE_SIZE) {
        TextureLoader._LOGGER.error(`The image [${originalSrc}] provided to Excalibur is too large for the device's maximum texture size of (${TextureLoader._MAX_TEXTURE_SIZE}x${TextureLoader._MAX_TEXTURE_SIZE}) please resize to an image for excalibur to render properly.

Images will likely render as black rectangles.

Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);
        return false;
      } else if (image.width > 4096 || image.height > 4096) {
        TextureLoader._LOGGER.warn(`The image [${originalSrc}] provided to excalibur is too large may not work on all mobile devices, it is recommended you resize images to a maximum (4096x4096).

Images will likely render as black rectangles on some mobile platforms.

Read more here: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#understand_system_limits`);
      }
      return true;
    }
  }
  TextureLoader._LOGGER = Logger2.getInstance();
  TextureLoader.filtering = ImageFiltering.Blended;
  TextureLoader._MAX_TEXTURE_SIZE = 4096;
  class ImageSource {
    /**
     * The original size of the source image in pixels
     */
    get width() {
      return this.image.naturalWidth;
    }
    /**
     * The original height of the source image in pixels
     */
    get height() {
      return this.image.naturalHeight;
    }
    /**
     * Returns true if the Texture is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
      if (!this._src) {
        this._src = this.data.src;
      }
      return !!this._src;
    }
    get image() {
      return this.data;
    }
    /**
     * The path to the image, can also be a data url like 'data:image/'
     * @param path {string} Path to the image resource relative from the HTML document hosting the game, or absolute
     * @param bustCache {boolean} Should excalibur add a cache busting querystring?
     * @param filtering {ImageFiltering} Optionally override the image filtering set by [[EngineOptions.antialiasing]]
     */
    constructor(path, bustCache = false, filtering) {
      this.path = path;
      this._logger = Logger2.getInstance();
      this.data = new Image();
      this._readyFuture = new Future();
      this.ready = this._readyFuture.promise;
      this._resource = new Resource(path, "blob", bustCache);
      this.filtering = filtering;
      if (path.endsWith(".svg") || path.endsWith(".gif")) {
        this._logger.warn(`Image type is not fully supported, you may have mixed results ${path}. Fully supported: jpg, bmp, and png`);
      }
    }
    /**
     * Should excalibur add a cache busting querystring? By default false.
     * Must be set before loading
     */
    get bustCache() {
      return this._resource.bustCache;
    }
    set bustCache(val) {
      this._resource.bustCache = val;
    }
    /**
     * Begins loading the image and returns a promise that resolves when the image is loaded
     */
    async load() {
      if (this.isLoaded()) {
        return this.data;
      }
      try {
        let url;
        if (!this.path.includes("data:image/")) {
          const blob = await this._resource.load();
          url = URL.createObjectURL(blob);
        } else {
          url = this.path;
        }
        const image = new Image();
        const loadedFuture = new Future();
        image.onload = () => loadedFuture.resolve();
        image.src = url;
        image.setAttribute("data-original-src", this.path);
        await loadedFuture.promise;
        this.data = image;
        TextureLoader.checkImageSizeSupportedAndLog(this.data);
      } catch (error) {
        throw `Error loading ImageSource from path '${this.path}' with error [${error.message}]`;
      }
      this.data.setAttribute("filtering", this.filtering);
      this._readyFuture.resolve(this.data);
      return this.data;
    }
    /**
     * Build a sprite from this ImageSource
     */
    toSprite() {
      return Sprite.from(this);
    }
    /**
     * Unload images from memory
     */
    unload() {
      this.data = new Image();
    }
  }
  class SpriteSheet {
    /**
     * Build a new sprite sheet from a list of sprites
     *
     * Use [[SpriteSheet.fromImageSource]] to create a SpriteSheet from an [[ImageSource]] organized in a grid
     * @param options
     */
    constructor(options) {
      this._logger = Logger2.getInstance();
      this.sprites = [];
      const { sprites, rows, columns } = options;
      this.sprites = sprites;
      this.rows = rows !== null && rows !== void 0 ? rows : 1;
      this.columns = columns !== null && columns !== void 0 ? columns : this.sprites.length;
    }
    /**
     * Find a sprite by their x/y position in the SpriteSheet, for example `getSprite(0, 0)` is the [[Sprite]] in the top-left
     * @param x
     * @param y
     */
    getSprite(x2, y2) {
      if (x2 >= this.columns || x2 < 0) {
        this._logger.warn(`No sprite exists in the SpriteSheet at (${x2}, ${y2}), x: ${x2} should be between 0 and ${this.columns - 1}`);
        return null;
      }
      if (y2 >= this.rows || y2 < 0) {
        this._logger.warn(`No sprite exists in the SpriteSheet at (${x2}, ${y2}), y: ${y2} should be between 0 and ${this.rows - 1}`);
        return null;
      }
      const spriteIndex = x2 + y2 * this.columns;
      return this.sprites[spriteIndex];
    }
    /**
     * Create a sprite sheet from a sparse set of [[SourceView]] rectangles
     * @param options
     */
    static fromImageSourceWithSourceViews(options) {
      const sprites = options.sourceViews.map((sourceView) => {
        return new Sprite({
          image: options.image,
          sourceView
        });
      });
      return new SpriteSheet({ sprites });
    }
    /**
     * Create a SpriteSheet from an [[ImageSource]] organized in a grid
     *
     * Example:
     * ```
     * const spriteSheet = SpriteSheet.fromImageSource({
     *   image: imageSource,
     *   grid: {
     *     rows: 5,
     *     columns: 2,
     *     spriteWidth: 32, // pixels
     *     spriteHeight: 32 // pixels
     *   },
     *   // Optionally specify spacing
     *   spacing: {
     *     // pixels from the top left to start the sprite parsing
     *     originOffset: {
     *       x: 5,
     *       y: 5
     *     },
     *     // pixels between each sprite while parsing
     *     margin: {
     *       x: 1,
     *       y: 1
     *     }
     *   }
     * })
     * ```
     *
     * @param options
     */
    static fromImageSource(options) {
      var _a;
      const sprites = [];
      options.spacing = (_a = options.spacing) !== null && _a !== void 0 ? _a : {};
      const { image, grid: { rows, columns: cols, spriteWidth, spriteHeight }, spacing: { originOffset, margin } } = options;
      const offsetDefaults = { x: 0, y: 0, ...originOffset };
      const marginDefaults = { x: 0, y: 0, ...margin };
      for (let x2 = 0; x2 < cols; x2++) {
        for (let y2 = 0; y2 < rows; y2++) {
          sprites[x2 + y2 * cols] = new Sprite({
            image,
            sourceView: {
              x: x2 * spriteWidth + marginDefaults.x * x2 + offsetDefaults.x,
              y: y2 * spriteHeight + marginDefaults.y * y2 + offsetDefaults.y,
              width: spriteWidth,
              height: spriteHeight
            },
            destSize: { height: spriteHeight, width: spriteWidth }
          });
        }
      }
      return new SpriteSheet({
        sprites,
        rows,
        columns: cols
      });
    }
    clone() {
      return new SpriteSheet({
        sprites: this.sprites.map((sprite) => sprite.clone()),
        rows: this.rows,
        columns: this.columns
      });
    }
  }
  class SpriteFont extends Graphic {
    constructor(options) {
      super(options);
      this._text = "";
      this.alphabet = "";
      this.shadow = null;
      this.caseInsensitive = false;
      this.spacing = 0;
      this._logger = Logger2.getInstance();
      this._alreadyWarnedAlphabet = false;
      this._alreadyWarnedSpriteSheet = false;
      const { alphabet, spriteSheet, caseInsensitive, spacing, shadow } = options;
      this.alphabet = alphabet;
      this.spriteSheet = spriteSheet;
      this.caseInsensitive = caseInsensitive !== null && caseInsensitive !== void 0 ? caseInsensitive : this.caseInsensitive;
      this.spacing = spacing !== null && spacing !== void 0 ? spacing : this.spacing;
      this.shadow = shadow !== null && shadow !== void 0 ? shadow : this.shadow;
    }
    _getCharacterSprites(text) {
      const results2 = [];
      const textToRender = this.caseInsensitive ? text.toLocaleLowerCase() : text;
      const alphabet = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;
      for (let letterIndex = 0; letterIndex < textToRender.length; letterIndex++) {
        const letter = textToRender[letterIndex];
        let spriteIndex = alphabet.indexOf(letter);
        if (spriteIndex === -1) {
          spriteIndex = 0;
          if (!this._alreadyWarnedAlphabet) {
            this._logger.warn(`SpriteFont - Cannot find letter '${letter}' in configured alphabet '${alphabet}'.`);
            this._logger.warn("There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.");
            this._alreadyWarnedAlphabet = true;
          }
        }
        const letterSprite = this.spriteSheet.sprites[spriteIndex];
        if (letterSprite) {
          results2.push(letterSprite);
        } else {
          if (!this._alreadyWarnedSpriteSheet) {
            this._logger.warn(`SpriteFont - Cannot find sprite for '${letter}' at index '${spriteIndex}' in configured SpriteSheet`);
            this._logger.warn("There maybe be more issues in the SpriteFont configuration. No additional warnings will be logged.");
            this._alreadyWarnedSpriteSheet = true;
          }
        }
      }
      return results2;
    }
    measureText(text, maxWidth) {
      const lines = this._getLinesFromText(text, maxWidth);
      const maxWidthLine = lines.reduce((a2, b2) => {
        return a2.length > b2.length ? a2 : b2;
      });
      const sprites = this._getCharacterSprites(maxWidthLine);
      let width = 0;
      let height = 0;
      for (const sprite of sprites) {
        width += sprite.width + this.spacing;
        height = Math.max(height, sprite.height);
      }
      return BoundingBox.fromDimension(width, height * lines.length, Vector.Zero);
    }
    _drawImage(ex, x2, y2, maxWidth) {
      let xCursor = 0;
      let yCursor = 0;
      let height = 0;
      const lines = this._getLinesFromText(this._text, maxWidth);
      for (const line2 of lines) {
        for (const sprite of this._getCharacterSprites(line2)) {
          sprite.draw(ex, x2 + xCursor, y2 + yCursor);
          xCursor += sprite.width + this.spacing;
          height = Math.max(height, sprite.height);
        }
        xCursor = 0;
        yCursor += height;
      }
    }
    render(ex, text, _color, x2, y2, maxWidth) {
      this._text = text;
      const bounds = this.measureText(text, maxWidth);
      this.width = bounds.width;
      this.height = bounds.height;
      if (this.shadow) {
        ex.save();
        ex.translate(this.shadow.offset.x, this.shadow.offset.y);
        this._preDraw(ex, x2, y2);
        this._drawImage(ex, 0, 0, maxWidth);
        this._postDraw(ex);
        ex.restore();
      }
      this._preDraw(ex, x2, y2);
      this._drawImage(ex, 0, 0, maxWidth);
      this._postDraw(ex);
    }
    clone() {
      return new SpriteFont({
        alphabet: this.alphabet,
        spriteSheet: this.spriteSheet,
        spacing: this.spacing
      });
    }
    _getLinesFromText(text, maxWidth) {
      if (this._cachedText === text && this._cachedRenderWidth === maxWidth) {
        return this._cachedLines;
      }
      const lines = text.split("\n");
      if (maxWidth == null) {
        return lines;
      }
      for (let i2 = 0; i2 < lines.length; i2++) {
        let line2 = lines[i2];
        let newLine = "";
        if (this.measureText(line2).width > maxWidth) {
          while (this.measureText(line2).width > maxWidth) {
            newLine = line2[line2.length - 1] + newLine;
            line2 = line2.slice(0, -1);
          }
          lines[i2] = line2;
          lines[i2 + 1] = newLine;
        }
      }
      this._cachedText = text;
      this._cachedLines = lines;
      this._cachedRenderWidth = maxWidth;
      return lines;
    }
  }
  const debug_font = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAwCAYAAAD+f6R/AAAAAXNSR0IArs4c6QAABcJJREFUeJztnemu7CgMhGE07//KmT9NhrAFVzkQndQntXRP3/bCZkwCSQhCCCGEEEIIIYQQQog/TRz953Ecx/nDGIe/vdNhlc9tIz605Fk/ZmWfsO1hn9Gxuv1KHbvb3iL/VN+d1WORbyr7yR/5b9M4vjNeqko6jPJHq5wGHU151o9J2Udse9hndCxuv0rH7rY3yD/Wdyf13MrnQeDfkZIUSGKM4ff3cWN82pEZuTyQGX2IxeyR63va//8VNCYCq+1yEkLtWyagXv1P1r1H+110gP3PzT4gT8uW/mdQ8mUG8E9DqOz4MS9ICKGbXpS2BpnIrRzYeS96cll08INlCMl2/glzdcfazuuPqQO03lmqrBHsf272Q6NODXj6zzZIJd/LAHYTg3Mays5gBi7ZR27fOgs0yj8rm36DLMFiPgkAdXHKOwUQeMCQ/adSh/qBQrT/tPxbAwA9+DOZEILPAATSuHMgTv7+Auk/df2lHPCZLvMSLJe34LkEQ9PwXF1SRTllMYgvIaflqyVAjLGbsiCDcOK76jflxZ+sINPyROc5071yKWK5CJTV3dMp6+tBlyCtNlhAq/+XbWoBDcRNXYBMzD4VvQygSuPYC2jGGaSSOxXfy3dTUEsanIvNeepm38N/hssSALTPZnAXfwIYRJn2b7UBcw0FKX+nDdAMpm2j9WVnxrUa7TXaVAca/B+TgaAVh6R/rH0P/5m01dt/RLYViJn+w/bhVX2P7f/duqom5qb02pRLCLGIMgBU1wCEEN9BAUCID6MAIMSHUQAQ4sMoAAjxYRQAhPgwd1uB0fuZ7H3cnn2P+9mr/Pe4B8/eB/fwP4eRtci/0f6OfTCPt/9oHwC6G6y19RHZDumxmwzR4eE/s/2Tte/q/+XLdc9DeJ19diesQc/j7Z8fCe4tAS4CxZ7sp7eiJi7HiZmjmOTGJs+93CbS3nP0XIPH3vW8/qz6QPnX2QdsV/1uw/iZYvg8ACeHd28rpPzfNfhL+7vkw/4Ou9s+Onhbv91elpKZ48Dl6bzpwwibHigRArf+Ptk9+L3Y1Q5OB4LgCeSBw1iuB3GeJh1/HrX/zF0A9Mk+u45zMkc3r4rWPomma5+p/514LB+Zo93MErJ1JHxXPzByGa/licRYVKbpeQCoQ6Q8yxuCwJF9IPsoDkHAo/3Tx26cvA4EtJ/n04w8QOq/mrR7ddfLAC5BYFNlVI/0CnOVUflOpvJUQMx9AIMIW/nWDM67/qw0+95v9goBqD9j+72u/KD9U89IbnQbMIR2Zbneh5zUY7Hdk7XIP3UffVb+r+wDYAZLq+1n1+C7y3/ny2r7p5yeByDEh9HzAIQQJwoAQnwYBQAhPowCgBBjoNu3hNxSFACE6INuKvPajPZ4EFEAEKINcybGYzOd247WEd3TgA2jlmjEyrd+j9hvfVbD2PWQ3ZmGlu2HyO8og8eBuNUvNYWoDgMVpwHTJoLWdz1Y+ZYOy5uF7t6PPruZxANrud1lQXkP0jsGz/Yz+vGGMuygFyhSPcJnc1pMnQZElc+cRnoAlxdTvoDuK7puqF7uCQy+3fyFMiA02/vJQHh7DQDogMPTSGFNA56HTzbZ9yAfBOb1Zyo3qGM3MfMZ3f76huXf6xlmAHknMlLNXsBBBvbljIz9Uyz5Y5TzIBLR/qy/rNyrZ8+L/0BZ0m+tgXD0OK5XZxC/9P7I/g4hVFvzXf1/6i5A7+3AlijMPBLMZfCvuAp7A9rY56ApHitmLQc7c8bOv6ftAxlM9Xp35nkEK7nJetBsaMhtAAAuOLQGXwhh2dXQnn1rZ/a42BI3dL7L+jkFAbQddwdA9Ah35yMKhgEgVT46EFh5D4jz+OgavNKxeBCd1wDSJ/97oR8eoJkLi9t9/BDgDHTJ5NE7Dnzechh914OVv9M1K9PCqsfqb88XVg9qN9lm6nG176UPu+zn17GOxuO0vOWEEC/j+LFKTgghlvEfYJaLS+SA2O0AAAAASUVORK5CYII=";
  class DebugText {
    constructor() {
      this.fontSheet = debug_font;
      this.size = 16;
      this.load();
    }
    load() {
      this._imageSource = new ImageSource(this.fontSheet);
      return this._imageSource.load().then(() => {
        this._spriteSheet = SpriteSheet.fromImageSource({
          image: this._imageSource,
          grid: {
            rows: 3,
            columns: 16,
            spriteWidth: 16,
            spriteHeight: 16
          }
        });
        this._spriteFont = new SpriteFont({
          alphabet: `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,!'&."?-()+ `,
          caseInsensitive: true,
          spriteSheet: this._spriteSheet,
          spacing: -6
        });
      });
    }
    /**
     * Writes debug text using the built in sprint font
     * @param ctx
     * @param text
     * @param pos
     */
    write(ctx, text, pos) {
      if (this._imageSource.isLoaded()) {
        this._spriteFont.render(ctx, text, null, pos.x, pos.y);
      }
    }
  }
  class RenderSource {
    constructor(_gl, _texture) {
      this._gl = _gl;
      this._texture = _texture;
    }
    use() {
      const gl2 = this._gl;
      gl2.activeTexture(gl2.TEXTURE0);
      gl2.bindTexture(gl2.TEXTURE_2D, this._texture);
    }
    disable() {
      const gl2 = this._gl;
      gl2.bindTexture(gl2.TEXTURE_2D, null);
    }
  }
  class RenderTarget {
    constructor(options) {
      this.width = options.width;
      this.height = options.height;
      this._gl = options.gl;
      this._setupFramebuffer();
    }
    setResolution(width, height) {
      const gl2 = this._gl;
      this.width = width;
      this.height = height;
      gl2.bindTexture(gl2.TEXTURE_2D, this._frameTexture);
      gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, this.width, this.height, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, null);
    }
    get frameBuffer() {
      return this._frameBuffer;
    }
    get frameTexture() {
      return this._frameTexture;
    }
    _setupFramebuffer() {
      const gl2 = this._gl;
      this._frameTexture = gl2.createTexture();
      gl2.bindTexture(gl2.TEXTURE_2D, this._frameTexture);
      gl2.texImage2D(gl2.TEXTURE_2D, 0, gl2.RGBA, this.width, this.height, 0, gl2.RGBA, gl2.UNSIGNED_BYTE, null);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, gl2.NEAREST);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, gl2.NEAREST);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, gl2.CLAMP_TO_EDGE);
      gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, gl2.CLAMP_TO_EDGE);
      const attachmentPoint = gl2.COLOR_ATTACHMENT0;
      this._frameBuffer = gl2.createFramebuffer();
      gl2.bindFramebuffer(gl2.FRAMEBUFFER, this._frameBuffer);
      gl2.framebufferTexture2D(gl2.FRAMEBUFFER, attachmentPoint, gl2.TEXTURE_2D, this._frameTexture, 0);
      this.disable();
    }
    toRenderSource() {
      const source = new RenderSource(this._gl, this._frameTexture);
      return source;
    }
    /**
     * When called, all drawing gets redirected to this render target
     */
    use() {
      const gl2 = this._gl;
      gl2.bindFramebuffer(gl2.FRAMEBUFFER, this._frameBuffer);
      gl2.viewport(0, 0, this.width, this.height);
    }
    /**
     * When called, all drawing is sent back to the canvas
     */
    disable() {
      const gl2 = this._gl;
      gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
      gl2.bindTexture(gl2.TEXTURE_2D, null);
    }
  }
  const line_vertex = "#version 300 es\r\nin vec2 a_position;\r\nin vec4 a_color;\r\n\r\nout lowp vec4 v_color;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n\r\n   // Passthrough the color\r\n   v_color = a_color;\r\n}";
  const line_fragment = "#version 300 es\r\nprecision mediump float;\r\n\r\n// Color\r\nin lowp vec4 v_color;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  fragColor = v_color;\r\n}";
  function getGlTypeSizeBytes(gl2, type) {
    switch (type) {
      case gl2.FLOAT:
        return 4;
      case gl2.SHORT:
        return 2;
      case gl2.UNSIGNED_SHORT:
        return 2;
      case gl2.BYTE:
        return 1;
      case gl2.UNSIGNED_BYTE:
        return 1;
      default:
        return 1;
    }
  }
  function getAttributeComponentSize(gl2, type) {
    switch (type) {
      case gl2.LOW_FLOAT:
      case gl2.HIGH_FLOAT:
      case gl2.FLOAT:
        return 1;
      case gl2.FLOAT_VEC2:
        return 2;
      case gl2.FLOAT_VEC3:
        return 3;
      case gl2.FLOAT_VEC4:
        return 4;
      case gl2.BYTE:
        return 1;
      case gl2.UNSIGNED_BYTE:
        return 1;
      case gl2.UNSIGNED_SHORT:
      case gl2.SHORT:
        return 1;
      default:
        return 1;
    }
  }
  function getAttributePointerType(gl2, type) {
    switch (type) {
      case gl2.LOW_FLOAT:
      case gl2.HIGH_FLOAT:
      case gl2.FLOAT:
      case gl2.FLOAT_VEC2:
      case gl2.FLOAT_VEC3:
      case gl2.FLOAT_VEC4:
        return gl2.FLOAT;
      case gl2.BYTE:
        return gl2.BYTE;
      case gl2.UNSIGNED_BYTE:
        return gl2.UNSIGNED_BYTE;
      case gl2.SHORT:
        return gl2.SHORT;
      case gl2.UNSIGNED_SHORT:
        return gl2.UNSIGNED_SHORT;
      default:
        return gl2.FLOAT;
    }
  }
  class Shader {
    get compiled() {
      return this._compiled;
    }
    /**
     * Create a shader program in excalibur
     * @param options specify shader vertex and fragment source
     */
    constructor(options) {
      this._logger = Logger2.getInstance();
      this.uniforms = {};
      this.attributes = {};
      this._compiled = false;
      const { gl: gl2, vertexSource, fragmentSource } = options;
      this._gl = gl2;
      this.vertexSource = vertexSource;
      this.fragmentSource = fragmentSource;
    }
    /**
     * Binds the shader program
     */
    use() {
      const gl2 = this._gl;
      gl2.useProgram(this.program);
      Shader._ACTIVE_SHADER_INSTANCE = this;
    }
    isCurrentlyBound() {
      return Shader._ACTIVE_SHADER_INSTANCE === this;
    }
    /**
     * Compile the current shader against a webgl context
     */
    compile() {
      const gl2 = this._gl;
      const vertexShader = this._compileShader(gl2, this.vertexSource, gl2.VERTEX_SHADER);
      const fragmentShader = this._compileShader(gl2, this.fragmentSource, gl2.FRAGMENT_SHADER);
      this.program = this._createProgram(gl2, vertexShader, fragmentShader);
      const attributes = this.getAttributes();
      for (const attribute of attributes) {
        this.attributes[attribute.name] = attribute;
      }
      const uniforms = this.getUniforms();
      for (const uniform of uniforms) {
        this.uniforms[uniform.name] = uniform;
      }
      this._compiled = true;
      return this.program;
    }
    getUniforms() {
      const gl2 = this._gl;
      const uniformCount = gl2.getProgramParameter(this.program, gl2.ACTIVE_UNIFORMS);
      const uniforms = [];
      for (let i2 = 0; i2 < uniformCount; i2++) {
        const uniform = gl2.getActiveUniform(this.program, i2);
        const uniformLocation = gl2.getUniformLocation(this.program, uniform.name);
        uniforms.push({
          name: uniform.name,
          glType: uniform.type,
          location: uniformLocation
        });
      }
      return uniforms;
    }
    getAttributes() {
      const gl2 = this._gl;
      const attributeCount = gl2.getProgramParameter(this.program, gl2.ACTIVE_ATTRIBUTES);
      const attributes = [];
      for (let i2 = 0; i2 < attributeCount; i2++) {
        const attribute = gl2.getActiveAttrib(this.program, i2);
        const attributeLocation = gl2.getAttribLocation(this.program, attribute.name);
        attributes.push({
          name: attribute.name,
          glType: getAttributePointerType(gl2, attribute.type),
          size: getAttributeComponentSize(gl2, attribute.type),
          location: attributeLocation,
          normalized: false
        });
      }
      return attributes;
    }
    /**
     * Set a texture in a gpu texture slot
     * @param slotNumber
     * @param texture
     */
    setTexture(slotNumber, texture) {
      const gl2 = this._gl;
      gl2.activeTexture(gl2.TEXTURE0 + slotNumber);
      gl2.bindTexture(gl2.TEXTURE_2D, texture);
    }
    /**
     * Set an integer uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformInt(name, value) {
      this.setUniform("uniform1i", name, ~~value);
    }
    /**
     * Set an integer uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    trySetUniformInt(name, value) {
      return this.trySetUniform("uniform1i", name, ~~value);
    }
    /**
     * Set an integer array uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformIntArray(name, value) {
      this.setUniform("uniform1iv", name, value);
    }
    /**
     * Set an integer array uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    trySetUniformIntArray(name, value) {
      return this.trySetUniform("uniform1iv", name, value);
    }
    /**
     * Set a boolean uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformBoolean(name, value) {
      this.setUniform("uniform1i", name, value ? 1 : 0);
    }
    /**
     * Set a boolean uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    trySetUniformBoolean(name, value) {
      return this.trySetUniform("uniform1i", name, value ? 1 : 0);
    }
    /**
     * Set a float uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformFloat(name, value) {
      this.setUniform("uniform1f", name, value);
    }
    /**
     * Set a float uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    trySetUniformFloat(name, value) {
      return this.trySetUniform("uniform1f", name, value);
    }
    /**
     * Set a float array uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformFloatArray(name, value) {
      this.setUniform("uniform1fv", name, value);
    }
    /**
     * Set a float array uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    trySetUniformFloatArray(name, value) {
      return this.trySetUniform("uniform1fv", name, value);
    }
    /**
     * Set a [[Vector]] uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformFloatVector(name, value) {
      this.setUniform("uniform2f", name, value.x, value.y);
    }
    /**
     * Set a [[Vector]] uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    trySetUniformFloatVector(name, value) {
      return this.trySetUniform("uniform2f", name, value.x, value.y);
    }
    /**
     * Set a [[Color]] uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformFloatColor(name, value) {
      this.setUniform("uniform4f", name, value.r / 255, value.g / 255, value.b / 255, value.a);
    }
    /**
     * Set a [[Color]] uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    trySetUniformFloatColor(name, value) {
      return this.trySetUniform("uniform4f", name, value.r / 255, value.g / 255, value.b / 255, value.a);
    }
    /**
     * Set an [[Matrix]] uniform for the current shader
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    setUniformMatrix(name, value) {
      this.setUniform("uniformMatrix4fv", name, false, value.data);
    }
    /**
     * Set an [[Matrix]] uniform for the current shader, WILL NOT THROW on error.
     *
     * **Important** Must call ex.Shader.use() before setting a uniform!
     *
     * @param name
     * @param value
     */
    trySetUniformMatrix(name, value) {
      return this.trySetUniform("uniformMatrix4fv", name, false, value.data);
    }
    /**
     * Set any available uniform type in webgl
     *
     * For example setUniform('uniformMatrix2fv', 'u_my2x2_mat`, ...);
     */
    setUniform(uniformType, name, ...value) {
      if (!this._compiled) {
        throw Error(`Must compile shader before setting a uniform ${uniformType}:${name}`);
      }
      if (!this.isCurrentlyBound()) {
        throw Error("Currently accessed shader instance is not the current active shader in WebGL, must call `shader.use()` before setting uniforms");
      }
      const gl2 = this._gl;
      const location = gl2.getUniformLocation(this.program, name);
      if (location) {
        const args = [location, ...value];
        this._gl[uniformType].apply(this._gl, args);
      } else {
        throw Error(`Uniform ${uniformType}:${name} doesn't exist or is not used in the shader source code, unused uniforms are optimized away by most browsers`);
      }
    }
    /**
     * Set any available uniform type in webgl. Will try to set the uniform, will return false if the uniform didn't exist,
     * true if it was set.
     *
     * WILL NOT THROW on error
     *
     * For example setUniform('uniformMatrix2fv', 'u_my2x2_mat`, ...);
     *
     */
    trySetUniform(uniformType, name, ...value) {
      if (!this._compiled) {
        this._logger.warn(`Must compile shader before setting a uniform ${uniformType}:${name}`);
        return false;
      }
      if (!this.isCurrentlyBound()) {
        this._logger.warn("Currently accessed shader instance is not the current active shader in WebGL, must call `shader.use()` before setting uniforms");
        return false;
      }
      const gl2 = this._gl;
      const location = gl2.getUniformLocation(this.program, name);
      if (location) {
        const args = [location, ...value];
        this._gl[uniformType].apply(this._gl, args);
      } else {
        return false;
      }
      return true;
    }
    _createProgram(gl2, vertexShader, fragmentShader) {
      const program = gl2.createProgram();
      if (program === null) {
        throw Error("Could not create graphics shader program");
      }
      gl2.attachShader(program, vertexShader);
      gl2.attachShader(program, fragmentShader);
      gl2.linkProgram(program);
      const success = gl2.getProgramParameter(program, gl2.LINK_STATUS);
      if (!success) {
        throw Error(`Could not link the program: [${gl2.getProgramInfoLog(program)}]`);
      }
      return program;
    }
    _compileShader(gl2, source, type) {
      const typeName = gl2.VERTEX_SHADER === type ? "vertex" : "fragment";
      const shader = gl2.createShader(type);
      if (shader === null) {
        throw Error(`Could not build shader: [${source}]`);
      }
      gl2.shaderSource(shader, source);
      gl2.compileShader(shader);
      const success = gl2.getShaderParameter(shader, gl2.COMPILE_STATUS);
      if (!success) {
        const errorInfo = gl2.getShaderInfoLog(shader);
        throw Error(`Could not compile ${typeName} shader:

${errorInfo}${this._processSourceForError(source, errorInfo)}`);
      }
      return shader;
    }
    _processSourceForError(source, errorInfo) {
      const lines = source.split("\n");
      const errorLineStart = errorInfo.search(/\d:\d/);
      const errorLineEnd = errorInfo.indexOf(" ", errorLineStart);
      const [_2, error2] = errorInfo.slice(errorLineStart, errorLineEnd).split(":").map((v2) => Number(v2));
      for (let i2 = 0; i2 < lines.length; i2++) {
        lines[i2] = `${i2 + 1}: ${lines[i2]}${error2 === i2 + 1 ? " <----- ERROR!" : ""}`;
      }
      return "\n\nSource:\n" + lines.join("\n");
    }
  }
  Shader._ACTIVE_SHADER_INSTANCE = null;
  class VertexBuffer {
    constructor(options) {
      this.type = "dynamic";
      const { gl: gl2, size, type, data } = options;
      this._gl = gl2;
      this.buffer = this._gl.createBuffer();
      if (!data && !size) {
        throw Error("Must either provide data or a size to the VertexBuffer");
      }
      if (!data) {
        this.bufferData = new Float32Array(size);
      } else {
        this.bufferData = data;
      }
      this.type = type !== null && type !== void 0 ? type : this.type;
      gl2.bindBuffer(gl2.ARRAY_BUFFER, this.buffer);
      gl2.bufferData(gl2.ARRAY_BUFFER, this.bufferData, this.type === "static" ? gl2.STATIC_DRAW : gl2.DYNAMIC_DRAW);
    }
    /**
     * Bind this vertex buffer
     */
    bind() {
      const gl2 = this._gl;
      gl2.bindBuffer(gl2.ARRAY_BUFFER, this.buffer);
    }
    /**
     * Upload vertex buffer geometry to the GPU
     */
    upload(count) {
      const gl2 = this._gl;
      gl2.bindBuffer(gl2.ARRAY_BUFFER, this.buffer);
      if (count) {
        gl2.bufferSubData(gl2.ARRAY_BUFFER, 0, this.bufferData, 0, count);
      } else {
        gl2.bufferData(gl2.ARRAY_BUFFER, this.bufferData, this.type === "static" ? gl2.STATIC_DRAW : gl2.DYNAMIC_DRAW);
      }
    }
  }
  class VertexLayout {
    get vertexBuffer() {
      return this._vertexBuffer;
    }
    get attributes() {
      return this._attributes;
    }
    constructor(options) {
      this._logger = Logger2.getInstance();
      this._layout = [];
      this._attributes = [];
      this._vertexTotalSizeBytes = 0;
      const { gl: gl2, shader, vertexBuffer, attributes } = options;
      this._gl = gl2;
      this._vertexBuffer = vertexBuffer;
      this._attributes = attributes;
      this._shader = shader;
      if (shader) {
        this.initialize();
      }
    }
    /**
     * Total number of bytes that the vertex will take up
     */
    get totalVertexSizeBytes() {
      return this._vertexTotalSizeBytes;
    }
    set shader(shader) {
      if (shader && this._shader !== shader) {
        this._shader = shader;
        this.initialize();
      }
    }
    get shader() {
      return this._shader;
    }
    /**
     * Layouts need shader locations and must be bound to a shader
     */
    initialize() {
      if (!this._shader) {
        return;
      }
      if (!this._shader.compiled) {
        throw Error("Shader not compiled, shader must be compiled before defining a vertex layout");
      }
      this._layout.length = 0;
      const shaderAttributes = this._shader.attributes;
      for (const attribute of this._attributes) {
        const attrib = shaderAttributes[attribute[0]];
        if (!attrib) {
          throw Error(`The attribute named: ${attribute[0]} size ${attribute[1]} not found in the shader source code:
 ${this._shader.vertexSource}`);
        }
        if (attrib.size !== attribute[1]) {
          throw Error(`VertexLayout size definition for attribute: [${attribute[0]}, ${attribute[1]}], doesnt match shader source size ${attrib.size}:
 ${this._shader.vertexSource}`);
        }
        this._layout.push(attrib);
      }
      let componentsPerVertex = 0;
      for (const vertAttribute of this._layout) {
        const typeSize = getGlTypeSizeBytes(this._gl, vertAttribute.glType);
        this._vertexTotalSizeBytes += typeSize * vertAttribute.size;
        componentsPerVertex += vertAttribute.size;
      }
      if (this._vertexBuffer.bufferData.length % componentsPerVertex !== 0) {
        this._logger.warn(`The vertex component size (${componentsPerVertex})  does divide evenly into the specified vertex buffer (${this._vertexBuffer.bufferData.length})`);
      }
    }
    /**
     * Bind this layout with it's associated vertex buffer
     *
     * @param uploadBuffer Optionally indicate you wish to upload the buffer to the GPU associated with this layout
     */
    use(uploadBuffer = false, count) {
      if (!this._shader) {
        throw Error("No shader is associated with this vertex layout, a shader must be set");
      }
      const gl2 = this._gl;
      if (!this._shader.isCurrentlyBound()) {
        throw Error("Shader associated with this vertex layout is not active! Call shader.use() before layout.use()");
      }
      this._vertexBuffer.bind();
      if (uploadBuffer) {
        this._vertexBuffer.upload(count);
      }
      let offset = 0;
      for (const vert of this._layout) {
        gl2.vertexAttribPointer(vert.location, vert.size, vert.glType, vert.normalized, this.totalVertexSizeBytes, offset);
        gl2.enableVertexAttribArray(vert.location);
        offset += getGlTypeSizeBytes(gl2, vert.glType) * vert.size;
      }
    }
  }
  class GraphicsDiagnostics {
    static clear() {
      GraphicsDiagnostics.DrawCallCount = 0;
      GraphicsDiagnostics.DrawnImagesCount = 0;
    }
  }
  GraphicsDiagnostics.DrawCallCount = 0;
  GraphicsDiagnostics.DrawnImagesCount = 0;
  class LineRenderer {
    constructor() {
      this.type = "ex.line";
      this.priority = 0;
      this._maxLines = 10922;
      this._vertexIndex = 0;
      this._lineCount = 0;
    }
    initialize(gl2, context) {
      this._gl = gl2;
      this._context = context;
      this._shader = new Shader({
        gl: gl2,
        vertexSource: line_vertex,
        fragmentSource: line_fragment
      });
      this._shader.compile();
      this._shader.use();
      this._shader.setUniformMatrix("u_matrix", this._context.ortho);
      this._vertexBuffer = new VertexBuffer({
        gl: gl2,
        size: 6 * 2 * this._maxLines,
        type: "dynamic"
      });
      this._layout = new VertexLayout({
        gl: gl2,
        vertexBuffer: this._vertexBuffer,
        shader: this._shader,
        attributes: [
          ["a_position", 2],
          ["a_color", 4]
        ]
      });
    }
    draw(start, end, color2) {
      if (this._isFull()) {
        this.flush();
      }
      this._lineCount++;
      const transform = this._context.getTransform();
      const finalStart = transform.multiply(start);
      const finalEnd = transform.multiply(end);
      const vertexBuffer = this._vertexBuffer.bufferData;
      vertexBuffer[this._vertexIndex++] = finalStart.x;
      vertexBuffer[this._vertexIndex++] = finalStart.y;
      vertexBuffer[this._vertexIndex++] = color2.r / 255;
      vertexBuffer[this._vertexIndex++] = color2.g / 255;
      vertexBuffer[this._vertexIndex++] = color2.b / 255;
      vertexBuffer[this._vertexIndex++] = color2.a;
      vertexBuffer[this._vertexIndex++] = finalEnd.x;
      vertexBuffer[this._vertexIndex++] = finalEnd.y;
      vertexBuffer[this._vertexIndex++] = color2.r / 255;
      vertexBuffer[this._vertexIndex++] = color2.g / 255;
      vertexBuffer[this._vertexIndex++] = color2.b / 255;
      vertexBuffer[this._vertexIndex++] = color2.a;
    }
    _isFull() {
      if (this._lineCount >= this._maxLines) {
        return true;
      }
      return false;
    }
    hasPendingDraws() {
      return this._lineCount !== 0;
    }
    flush() {
      if (this._lineCount === 0) {
        return;
      }
      const gl2 = this._gl;
      this._shader.use();
      this._layout.use(true);
      this._shader.setUniformMatrix("u_matrix", this._context.ortho);
      gl2.drawArrays(gl2.LINES, 0, this._lineCount * 2);
      GraphicsDiagnostics.DrawnImagesCount += this._lineCount;
      GraphicsDiagnostics.DrawCallCount++;
      this._vertexIndex = 0;
      this._lineCount = 0;
    }
  }
  const point_vertex = "#version 300 es\r\nin vec2 a_position;\r\nin vec4 a_color;\r\nin float a_size;\r\nout lowp vec4 v_color;\r\nuniform mat4 u_matrix;\r\n\r\nvoid main() {\r\n  gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n  gl_PointSize = a_size * 2.0;\r\n  v_color = a_color;\r\n}";
  const point_fragment = '#version 300 es\r\n\r\nprecision mediump float;\r\nin lowp vec4 v_color;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  float r = 0.0, delta = 0.0, alpha = 1.0;\r\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\r\n  r = dot(cxy, cxy);\r\n\r\n  delta = fwidth(r);\r\n  alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\r\n  // "premultiply" the color by alpha\r\n  vec4 color = v_color;\r\n  color.a = color.a * alpha;\r\n  color.rgb = color.rgb * color.a;\r\n  fragColor = color;\r\n}';
  class PointRenderer {
    constructor() {
      this.type = "ex.point";
      this.priority = 0;
      this._maxPoints = 10922;
      this._pointCount = 0;
      this._vertexIndex = 0;
    }
    initialize(gl2, context) {
      this._gl = gl2;
      this._context = context;
      this._shader = new Shader({
        gl: gl2,
        vertexSource: point_vertex,
        fragmentSource: point_fragment
      });
      this._shader.compile();
      this._shader.use();
      this._shader.setUniformMatrix("u_matrix", this._context.ortho);
      this._buffer = new VertexBuffer({
        gl: gl2,
        size: 7 * this._maxPoints,
        type: "dynamic"
      });
      this._layout = new VertexLayout({
        gl: gl2,
        shader: this._shader,
        vertexBuffer: this._buffer,
        attributes: [
          ["a_position", 2],
          ["a_color", 4],
          ["a_size", 1]
        ]
      });
    }
    draw(point2, color2, size) {
      if (this._isFull()) {
        this.flush();
      }
      this._pointCount++;
      const transform = this._context.getTransform();
      const opacity = this._context.opacity;
      const snapToPixel = this._context.snapToPixel;
      const finalPoint = transform.multiply(point2);
      if (snapToPixel) {
        finalPoint.x = ~~(finalPoint.x + pixelSnapEpsilon);
        finalPoint.y = ~~(finalPoint.y + pixelSnapEpsilon);
      }
      const vertexBuffer = this._buffer.bufferData;
      vertexBuffer[this._vertexIndex++] = finalPoint.x;
      vertexBuffer[this._vertexIndex++] = finalPoint.y;
      vertexBuffer[this._vertexIndex++] = color2.r / 255;
      vertexBuffer[this._vertexIndex++] = color2.g / 255;
      vertexBuffer[this._vertexIndex++] = color2.b / 255;
      vertexBuffer[this._vertexIndex++] = color2.a * opacity;
      vertexBuffer[this._vertexIndex++] = size * Math.max(transform.getScaleX(), transform.getScaleY());
    }
    _isFull() {
      if (this._pointCount >= this._maxPoints) {
        return true;
      }
      return false;
    }
    hasPendingDraws() {
      return this._pointCount !== 0;
    }
    flush() {
      if (this._pointCount === 0) {
        return;
      }
      const gl2 = this._gl;
      this._shader.use();
      this._layout.use(true);
      this._shader.setUniformMatrix("u_matrix", this._context.ortho);
      gl2.drawArrays(gl2.POINTS, 0, this._pointCount);
      GraphicsDiagnostics.DrawnImagesCount += this._pointCount;
      GraphicsDiagnostics.DrawCallCount++;
      this._pointCount = 0;
      this._vertexIndex = 0;
    }
  }
  const screen_vertex = "#version 300 es\r\nin vec2 a_position;\r\n\r\nin vec2 a_texcoord;\r\nout vec2 v_texcoord;\r\n\r\nvoid main() {\r\n  gl_Position = vec4(a_position, 0.0, 1.0);\r\n\r\n  // Pass the texcoord to the fragment shader.\r\n  v_texcoord = a_texcoord;\r\n}";
  const screen_fragment = "#version 300 es\r\nprecision mediump float;\r\n\r\n// Passed in from the vertex shader.\r\nin vec2 v_texcoord;\r\n\r\n// The texture.\r\nuniform sampler2D u_texture;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n   fragColor = texture(u_texture, v_texcoord);\r\n}";
  class ScreenPassPainter {
    constructor(gl2) {
      this._gl = gl2;
      this._shader = new Shader({
        gl: gl2,
        vertexSource: screen_vertex,
        fragmentSource: screen_fragment
      });
      this._shader.compile();
      this._buffer = new VertexBuffer({
        gl: gl2,
        type: "static",
        // clip space quad + uv since we don't need a camera
        data: new Float32Array([
          -1,
          -1,
          0,
          0,
          -1,
          1,
          0,
          1,
          1,
          -1,
          1,
          0,
          1,
          -1,
          1,
          0,
          -1,
          1,
          0,
          1,
          1,
          1,
          1,
          1
        ])
      });
      this._layout = new VertexLayout({
        gl: gl2,
        shader: this._shader,
        vertexBuffer: this._buffer,
        attributes: [
          ["a_position", 2],
          ["a_texcoord", 2]
        ]
      });
      this._buffer.upload();
    }
    renderWithPostProcessor(postprocessor) {
      const gl2 = this._gl;
      postprocessor.getShader().use();
      postprocessor.getLayout().use();
      gl2.drawArrays(gl2.TRIANGLES, 0, 6);
    }
    renderToScreen() {
      const gl2 = this._gl;
      this._shader.use();
      this._layout.use();
      gl2.drawArrays(gl2.TRIANGLES, 0, 6);
    }
  }
  class QuadIndexBuffer {
    /**
     * @param gl WebGL2RenderingContext this layout will be attached to, these cannot be reused across contexts.
     * @param numberOfQuads Specify the max number of quads you want to draw
     * @param useUint16 Optionally force a uint16 buffer
     */
    constructor(gl2, numberOfQuads, useUint16) {
      this._logger = Logger2.getInstance();
      this._gl = gl2;
      this.buffer = gl2.createBuffer();
      gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, this.buffer);
      const totalVertices = numberOfQuads * 6;
      if (!useUint16) {
        this.bufferData = new Uint32Array(totalVertices);
      } else {
        const maxUint16 = 65535;
        const maxUint16Index = Math.floor((maxUint16 - 1) / 4);
        this.bufferGlType = gl2.UNSIGNED_SHORT;
        this.bufferData = new Uint16Array(totalVertices);
        if (numberOfQuads > maxUint16Index) {
          this._logger.warn(`Total quads exceeds hardware index buffer limit (uint16), max(${maxUint16Index}) requested quads(${numberOfQuads})`);
        }
      }
      let currentQuad = 0;
      for (let i2 = 0; i2 < totalVertices; i2 += 6) {
        this.bufferData[i2 + 0] = currentQuad + 0;
        this.bufferData[i2 + 1] = currentQuad + 1;
        this.bufferData[i2 + 2] = currentQuad + 2;
        this.bufferData[i2 + 3] = currentQuad + 2;
        this.bufferData[i2 + 4] = currentQuad + 1;
        this.bufferData[i2 + 5] = currentQuad + 3;
        currentQuad += 4;
      }
      gl2.bufferData(gl2.ELEMENT_ARRAY_BUFFER, this.bufferData, gl2.STATIC_DRAW);
    }
    get size() {
      return this.bufferData.length;
    }
    /**
     * Upload data to the GPU
     */
    upload() {
      const gl2 = this._gl;
      gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, this.buffer);
      gl2.bufferData(gl2.ELEMENT_ARRAY_BUFFER, this.bufferData, gl2.STATIC_DRAW);
    }
    /**
     * Bind this index buffer
     */
    bind() {
      const gl2 = this._gl;
      gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, this.buffer);
    }
  }
  const image_renderer_frag = "#version 300 es\r\nprecision mediump float;\r\n\r\n// UV coord\r\nin vec2 v_texcoord;\r\n\r\n// Texture index\r\nin lowp float v_textureIndex;\r\n\r\n// Textures in the current draw\r\nuniform sampler2D u_textures[%%count%%];\r\n\r\n// Opacity\r\nin float v_opacity;\r\n\r\nin vec4 v_tint;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n   // In order to support the most efficient sprite batching, we have multiple\r\n   // textures loaded into the gpu (usually 8) this picker logic skips over textures\r\n   // that do not apply to a particular sprite.\r\n\r\n   vec4 color = vec4(1.0, 0, 0, 1.0);\r\n\r\n   // GLSL is templated out to pick the right texture and set the vec4 color\r\n   %%texture_picker%%\r\n\r\n   color.rgb = color.rgb * v_opacity;\r\n   color.a = color.a * v_opacity;\r\n   fragColor = color * v_tint;\r\n}";
  const image_renderer_vert = "#version 300 es\r\nin vec2 a_position;\r\n\r\n// Opacity \r\nin float a_opacity;\r\nout float v_opacity;\r\n\r\n// UV coordinate\r\nin vec2 a_texcoord;\r\nout vec2 v_texcoord;\r\n\r\n// Texture number\r\nin lowp float a_textureIndex;\r\nout lowp float v_textureIndex;\r\n\r\nin vec4 a_tint;\r\nout vec4 v_tint;\r\n\r\nuniform mat4 u_matrix;\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n\r\n   // Pass through the Opacity to the fragment shader\r\n   v_opacity = a_opacity;\r\n   // Pass through the UV coord to the fragment shader\r\n   v_texcoord = a_texcoord;\r\n   // Pass through the texture number to the fragment shader\r\n   v_textureIndex = a_textureIndex;\r\n   // Pass through the tint\r\n   v_tint = a_tint;\r\n}";
  class ImageRenderer {
    constructor() {
      this.type = "ex.image";
      this.priority = 0;
      this._maxImages = 10922;
      this._maxTextures = 0;
      this._imageCount = 0;
      this._textures = [];
      this._vertexIndex = 0;
    }
    initialize(gl2, context) {
      this._gl = gl2;
      this._context = context;
      this._maxTextures = Math.min(gl2.getParameter(gl2.MAX_TEXTURE_IMAGE_UNITS), 125);
      const transformedFrag = this._transformFragmentSource(image_renderer_frag, this._maxTextures);
      this._shader = new Shader({
        gl: gl2,
        fragmentSource: transformedFrag,
        vertexSource: image_renderer_vert
      });
      this._shader.compile();
      this._shader.use();
      this._shader.setUniformMatrix("u_matrix", context.ortho);
      this._shader.setUniformIntArray("u_textures", [...Array(this._maxTextures)].map((_2, i2) => i2));
      this._buffer = new VertexBuffer({
        gl: gl2,
        size: 10 * 4 * this._maxImages,
        type: "dynamic"
      });
      this._layout = new VertexLayout({
        gl: gl2,
        shader: this._shader,
        vertexBuffer: this._buffer,
        attributes: [
          ["a_position", 2],
          ["a_opacity", 1],
          ["a_texcoord", 2],
          ["a_textureIndex", 1],
          ["a_tint", 4]
        ]
      });
      this._quads = new QuadIndexBuffer(gl2, this._maxImages, true);
    }
    _transformFragmentSource(source, maxTextures) {
      let newSource = source.replace("%%count%%", maxTextures.toString());
      let texturePickerBuilder = "";
      for (let i2 = 0; i2 < maxTextures; i2++) {
        if (i2 === 0) {
          texturePickerBuilder += `if (v_textureIndex <= ${i2}.5) {
`;
        } else {
          texturePickerBuilder += `   else if (v_textureIndex <= ${i2}.5) {
`;
        }
        texturePickerBuilder += `      color = texture(u_textures[${i2}], v_texcoord);
`;
        texturePickerBuilder += `   }
`;
      }
      newSource = newSource.replace("%%texture_picker%%", texturePickerBuilder);
      return newSource;
    }
    _addImageAsTexture(image) {
      const maybeFiltering = image.getAttribute("filtering");
      let filtering = null;
      if (maybeFiltering === ImageFiltering.Blended || maybeFiltering === ImageFiltering.Pixel) {
        filtering = maybeFiltering;
      }
      const force = image.getAttribute("forceUpload") === "true" ? true : false;
      const texture = this._context.textureLoader.load(image, filtering, force);
      image.removeAttribute("forceUpload");
      if (this._textures.indexOf(texture) === -1) {
        this._textures.push(texture);
      }
    }
    _bindTextures(gl2) {
      for (let i2 = 0; i2 < this._maxTextures; i2++) {
        gl2.activeTexture(gl2.TEXTURE0 + i2);
        gl2.bindTexture(gl2.TEXTURE_2D, this._textures[i2] || this._textures[0]);
      }
    }
    _getTextureIdForImage(image) {
      if (image) {
        const maybeTexture = this._context.textureLoader.get(image);
        return this._textures.indexOf(maybeTexture);
      }
      return -1;
    }
    _isFull() {
      if (this._imageCount >= this._maxImages) {
        return true;
      }
      if (this._textures.length >= this._maxTextures) {
        return true;
      }
      return false;
    }
    draw(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
      var _a, _b, _c, _d;
      if (this._isFull()) {
        this.flush();
      }
      this._imageCount++;
      this._addImageAsTexture(image);
      let width = (image === null || image === void 0 ? void 0 : image.width) || swidth || 0;
      let height = (image === null || image === void 0 ? void 0 : image.height) || sheight || 0;
      let view = [0, 0, (_a = swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width) !== null && _a !== void 0 ? _a : 0, (_b = sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height) !== null && _b !== void 0 ? _b : 0];
      let dest = [sx !== null && sx !== void 0 ? sx : 1, sy !== null && sy !== void 0 ? sy : 1];
      if (dx !== void 0 && dy !== void 0 && dwidth !== void 0 && dheight !== void 0) {
        view = [sx !== null && sx !== void 0 ? sx : 1, sy !== null && sy !== void 0 ? sy : 1, (_c = swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width) !== null && _c !== void 0 ? _c : 0, (_d = sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height) !== null && _d !== void 0 ? _d : 0];
        dest = [dx, dy];
        width = dwidth;
        height = dheight;
      }
      sx = view[0];
      sy = view[1];
      const sw = view[2];
      const sh2 = view[3];
      const transform = this._context.getTransform();
      const opacity = this._context.opacity;
      const snapToPixel = this._context.snapToPixel;
      let topLeft = vec(dest[0], dest[1]);
      let topRight = vec(dest[0] + width, dest[1]);
      let bottomLeft = vec(dest[0], dest[1] + height);
      let bottomRight = vec(dest[0] + width, dest[1] + height);
      topLeft = transform.multiply(topLeft);
      topRight = transform.multiply(topRight);
      bottomLeft = transform.multiply(bottomLeft);
      bottomRight = transform.multiply(bottomRight);
      if (snapToPixel) {
        topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);
        topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);
        topRight.x = ~~(topRight.x + pixelSnapEpsilon);
        topRight.y = ~~(topRight.y + pixelSnapEpsilon);
        bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);
        bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);
        bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);
        bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);
      }
      const tint = this._context.tint;
      const textureId = this._getTextureIdForImage(image);
      const imageWidth = image.width || width;
      const imageHeight = image.height || height;
      const uvx0 = sx / imageWidth;
      const uvy0 = sy / imageHeight;
      const uvx1 = (sx + sw - 0.01) / imageWidth;
      const uvy1 = (sy + sh2 - 0.01) / imageHeight;
      const vertexBuffer = this._layout.vertexBuffer.bufferData;
      vertexBuffer[this._vertexIndex++] = topLeft.x;
      vertexBuffer[this._vertexIndex++] = topLeft.y;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = uvx0;
      vertexBuffer[this._vertexIndex++] = uvy0;
      vertexBuffer[this._vertexIndex++] = textureId;
      vertexBuffer[this._vertexIndex++] = tint.r / 255;
      vertexBuffer[this._vertexIndex++] = tint.g / 255;
      vertexBuffer[this._vertexIndex++] = tint.b / 255;
      vertexBuffer[this._vertexIndex++] = tint.a;
      vertexBuffer[this._vertexIndex++] = bottomLeft.x;
      vertexBuffer[this._vertexIndex++] = bottomLeft.y;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = uvx0;
      vertexBuffer[this._vertexIndex++] = uvy1;
      vertexBuffer[this._vertexIndex++] = textureId;
      vertexBuffer[this._vertexIndex++] = tint.r / 255;
      vertexBuffer[this._vertexIndex++] = tint.g / 255;
      vertexBuffer[this._vertexIndex++] = tint.b / 255;
      vertexBuffer[this._vertexIndex++] = tint.a;
      vertexBuffer[this._vertexIndex++] = topRight.x;
      vertexBuffer[this._vertexIndex++] = topRight.y;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = uvx1;
      vertexBuffer[this._vertexIndex++] = uvy0;
      vertexBuffer[this._vertexIndex++] = textureId;
      vertexBuffer[this._vertexIndex++] = tint.r / 255;
      vertexBuffer[this._vertexIndex++] = tint.g / 255;
      vertexBuffer[this._vertexIndex++] = tint.b / 255;
      vertexBuffer[this._vertexIndex++] = tint.a;
      vertexBuffer[this._vertexIndex++] = bottomRight.x;
      vertexBuffer[this._vertexIndex++] = bottomRight.y;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = uvx1;
      vertexBuffer[this._vertexIndex++] = uvy1;
      vertexBuffer[this._vertexIndex++] = textureId;
      vertexBuffer[this._vertexIndex++] = tint.r / 255;
      vertexBuffer[this._vertexIndex++] = tint.g / 255;
      vertexBuffer[this._vertexIndex++] = tint.b / 255;
      vertexBuffer[this._vertexIndex++] = tint.a;
    }
    hasPendingDraws() {
      return this._imageCount !== 0;
    }
    flush() {
      if (this._imageCount === 0) {
        return;
      }
      const gl2 = this._gl;
      this._shader.use();
      this._layout.use(true, 4 * 10 * this._imageCount);
      this._shader.setUniformMatrix("u_matrix", this._context.ortho);
      this._bindTextures(gl2);
      this._quads.bind();
      gl2.drawElements(gl2.TRIANGLES, this._imageCount * 6, this._quads.bufferGlType, 0);
      GraphicsDiagnostics.DrawnImagesCount += this._imageCount;
      GraphicsDiagnostics.DrawCallCount++;
      this._imageCount = 0;
      this._vertexIndex = 0;
      this._textures.length = 0;
    }
  }
  const rectangle_renderer_frag = "#version 300 es\r\n\r\nprecision mediump float;\r\n\r\n// UV coord\r\nin vec2 v_uv;\r\n\r\nin vec2 v_size; // in pixels\r\n\r\n// Color coord to blend with image\r\nin lowp vec4 v_color;\r\n\r\n// Stroke color if used\r\nin lowp vec4 v_strokeColor;\r\n\r\n// Stroke thickness if used\r\nin lowp float v_strokeThickness; // in pixels\r\n\r\n// Opacity\r\nin float v_opacity;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n    // modified from https://stackoverflow.com/questions/59197671/glsl-rounded-rectangle-with-variable-border\r\n    vec2 uv = v_uv;\r\n    vec2 fragCoord = uv * v_size;\r\n    float maxX = v_size.x - v_strokeThickness;\r\n    float minX = v_strokeThickness;\r\n    float maxY = v_size.y - v_strokeThickness;\r\n    float minY = v_strokeThickness;\r\n\r\n    if (fragCoord.x < maxX && fragCoord.x > minX &&\r\n        fragCoord.y < maxY && fragCoord.y > minY) {\r\n      fragColor = v_color;\r\n    } else {\r\n      fragColor = v_strokeColor;\r\n    }\r\n    fragColor.a *= v_opacity;\r\n    fragColor.rgb *= fragColor.a;\r\n\r\n    // vec2 v2CenteredPos     = abs(fragCoord - v_size.xy / 2.0);\r\n    // vec2 v2HalfShapeSizePx = v_size.xy/2.0 - v_strokeThickness/2.0;\r\n\r\n    // float fHalfBorderDist      = 0.0;\r\n    // float fHalfBorderThickness = 0.0;\r\n\r\n    // if (fragCoord.x > max(v_radius, v_strokeThickness) && \r\n    //     fragCoord.x < v_size.x - max(v_radius, v_strokeThickness))\r\n    // {\r\n    //     fHalfBorderDist      = v2CenteredPos.y - v2HalfShapeSizePx.y;\r\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\r\n    // }\r\n    // else if (fragCoord.y > max(v_radius, v_strokeThickness) && \r\n    //          fragCoord.y < v_size.y - max(v_radius, v_strokeThickness))\r\n    // {\r\n    //     fHalfBorderDist      = v2CenteredPos.x - v2HalfShapeSizePx.x;\r\n    //     fHalfBorderThickness = v_strokeThickness / 2.0;\r\n    // }\r\n    // else\r\n    // {\r\n    //     vec2 edgeVec = max(vec2(0.0), v_radius - vec2(\r\n    //         uv.x > 0.5 ? v_size.x - fragCoord.x : fragCoord.x,\r\n    //         uv.y > 0.5 ? v_size.y - fragCoord.y : fragCoord.y));\r\n        \r\n    //     float ellipse_ab    = v_radius-v_strokeThickness;\r\n    //     vec2 ellipse_isect = (v_strokeThickness > v_radius || v_strokeThickness > v_radius) ? vec2(0.0) :\r\n    //                             edgeVec.xy * ellipse_ab*ellipse_ab / length(ellipse_ab*edgeVec.yx); \r\n            \r\n    //     fHalfBorderThickness = (v_radius - length(ellipse_isect)) / 2.0;\r\n    //     fHalfBorderDist      = length(edgeVec) - (v_radius - fHalfBorderThickness);\r\n    // }\r\n\r\n    // vec4 v4FromColor = v_strokeColor;\r\n    // v4FromColor.rgb *= v4FromColor.a;\r\n    // vec4 v4ToColor   = vec4(0.0); // background color is transparent\r\n    // if (fHalfBorderDist < 0.0) {\r\n    //     v4ToColor = v_color;\r\n    //     v4ToColor.rgb *= v4ToColor.a;\r\n    // }\r\n\r\n    // float mixPct = abs(fHalfBorderDist) - fHalfBorderThickness;\r\n\r\n    // vec4 finalColor = mix(v4FromColor, v4ToColor, mixPct);\r\n    // gl_FragColor = finalColor;\r\n}";
  const rectangle_renderer_vert = "#version 300 es\r\nin vec2 a_position;\r\n\r\n// UV coordinate\r\nin vec2 a_uv;\r\nout vec2 v_uv;\r\n\r\nin vec2 a_size;\r\nout vec2 v_size;\r\n\r\n// Opacity \r\nin float a_opacity;\r\nout float v_opacity;\r\n\r\nin vec4 a_color;\r\nout vec4 v_color;\r\n\r\nin vec4 a_strokeColor;\r\nout vec4 v_strokeColor;\r\n\r\nin float a_strokeThickness;\r\nout float v_strokeThickness;\r\n\r\nuniform mat4 u_matrix;\r\n\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n\r\n   // Pass through UV coords\r\n   v_uv = a_uv;\r\n   // Pass through size\r\n   v_size = a_size;\r\n   // Pass through the Opacity to the fragment shader\r\n   v_opacity = a_opacity;\r\n   // Pass through the color to the fragment shader\r\n   v_color = a_color;\r\n   // Pass through the stroke color to the fragment shader\r\n   v_strokeColor = a_strokeColor;\r\n   // Pass through the stroke thickenss to the fragment shader\r\n   v_strokeThickness = a_strokeThickness;\r\n}";
  class RectangleRenderer {
    constructor() {
      this.type = "ex.rectangle";
      this.priority = 0;
      this._maxRectangles = 10922;
      this._rectangleCount = 0;
      this._vertexIndex = 0;
    }
    initialize(gl2, context) {
      this._gl = gl2;
      this._context = context;
      this._shader = new Shader({
        gl: gl2,
        fragmentSource: rectangle_renderer_frag,
        vertexSource: rectangle_renderer_vert
      });
      this._shader.compile();
      this._shader.use();
      this._shader.setUniformMatrix("u_matrix", context.ortho);
      this._buffer = new VertexBuffer({
        gl: gl2,
        size: 16 * 4 * this._maxRectangles,
        type: "dynamic"
      });
      this._layout = new VertexLayout({
        gl: gl2,
        shader: this._shader,
        vertexBuffer: this._buffer,
        attributes: [
          ["a_position", 2],
          ["a_uv", 2],
          ["a_size", 2],
          ["a_opacity", 1],
          ["a_color", 4],
          ["a_strokeColor", 4],
          ["a_strokeThickness", 1]
        ]
      });
      this._quads = new QuadIndexBuffer(gl2, this._maxRectangles, true);
    }
    _isFull() {
      if (this._rectangleCount >= this._maxRectangles) {
        return true;
      }
      return false;
    }
    draw(...args) {
      if (args[0] instanceof Vector && args[1] instanceof Vector) {
        this.drawLine.apply(this, args);
      } else {
        this.drawRectangle.apply(this, args);
      }
    }
    drawLine(start, end, color2, thickness = 1) {
      if (this._isFull()) {
        this.flush();
      }
      this._rectangleCount++;
      const transform = this._context.getTransform();
      const opacity = this._context.opacity;
      const snapToPixel = this._context.snapToPixel;
      const dir = end.sub(start);
      const length = dir.size;
      const normal = dir.normalize().perpendicular();
      const halfThick = thickness / 2;
      const startTop = transform.multiply(normal.scale(halfThick).add(start));
      const startBottom = transform.multiply(normal.scale(-halfThick).add(start));
      const endTop = transform.multiply(normal.scale(halfThick).add(end));
      const endBottom = transform.multiply(normal.scale(-halfThick).add(end));
      if (snapToPixel) {
        startTop.x = ~~(startTop.x + pixelSnapEpsilon);
        startTop.y = ~~(startTop.y + pixelSnapEpsilon);
        endTop.x = ~~(endTop.x + pixelSnapEpsilon);
        endTop.y = ~~(endTop.y + pixelSnapEpsilon);
        startBottom.x = ~~(startBottom.x + pixelSnapEpsilon);
        startBottom.y = ~~(startBottom.y + pixelSnapEpsilon);
        endBottom.x = ~~(endBottom.x + pixelSnapEpsilon);
        endBottom.y = ~~(endBottom.y + pixelSnapEpsilon);
      }
      const uvx0 = 0;
      const uvy0 = 0;
      const uvx1 = 1;
      const uvy1 = 1;
      const stroke = Color.Transparent;
      const strokeThickness = 0;
      const width = 1;
      const vertexBuffer = this._layout.vertexBuffer.bufferData;
      vertexBuffer[this._vertexIndex++] = startTop.x;
      vertexBuffer[this._vertexIndex++] = startTop.y;
      vertexBuffer[this._vertexIndex++] = uvx0;
      vertexBuffer[this._vertexIndex++] = uvy0;
      vertexBuffer[this._vertexIndex++] = length;
      vertexBuffer[this._vertexIndex++] = thickness;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = color2.r / 255;
      vertexBuffer[this._vertexIndex++] = color2.g / 255;
      vertexBuffer[this._vertexIndex++] = color2.b / 255;
      vertexBuffer[this._vertexIndex++] = color2.a;
      vertexBuffer[this._vertexIndex++] = stroke.r / 255;
      vertexBuffer[this._vertexIndex++] = stroke.g / 255;
      vertexBuffer[this._vertexIndex++] = stroke.b / 255;
      vertexBuffer[this._vertexIndex++] = stroke.a;
      vertexBuffer[this._vertexIndex++] = strokeThickness / width;
      vertexBuffer[this._vertexIndex++] = startBottom.x;
      vertexBuffer[this._vertexIndex++] = startBottom.y;
      vertexBuffer[this._vertexIndex++] = uvx0;
      vertexBuffer[this._vertexIndex++] = uvy1;
      vertexBuffer[this._vertexIndex++] = length;
      vertexBuffer[this._vertexIndex++] = thickness;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = color2.r / 255;
      vertexBuffer[this._vertexIndex++] = color2.g / 255;
      vertexBuffer[this._vertexIndex++] = color2.b / 255;
      vertexBuffer[this._vertexIndex++] = color2.a;
      vertexBuffer[this._vertexIndex++] = stroke.r / 255;
      vertexBuffer[this._vertexIndex++] = stroke.g / 255;
      vertexBuffer[this._vertexIndex++] = stroke.b / 255;
      vertexBuffer[this._vertexIndex++] = stroke.a;
      vertexBuffer[this._vertexIndex++] = strokeThickness / width;
      vertexBuffer[this._vertexIndex++] = endTop.x;
      vertexBuffer[this._vertexIndex++] = endTop.y;
      vertexBuffer[this._vertexIndex++] = uvx1;
      vertexBuffer[this._vertexIndex++] = uvy0;
      vertexBuffer[this._vertexIndex++] = length;
      vertexBuffer[this._vertexIndex++] = thickness;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = color2.r / 255;
      vertexBuffer[this._vertexIndex++] = color2.g / 255;
      vertexBuffer[this._vertexIndex++] = color2.b / 255;
      vertexBuffer[this._vertexIndex++] = color2.a;
      vertexBuffer[this._vertexIndex++] = stroke.r / 255;
      vertexBuffer[this._vertexIndex++] = stroke.g / 255;
      vertexBuffer[this._vertexIndex++] = stroke.b / 255;
      vertexBuffer[this._vertexIndex++] = stroke.a;
      vertexBuffer[this._vertexIndex++] = strokeThickness / width;
      vertexBuffer[this._vertexIndex++] = endBottom.x;
      vertexBuffer[this._vertexIndex++] = endBottom.y;
      vertexBuffer[this._vertexIndex++] = uvx1;
      vertexBuffer[this._vertexIndex++] = uvy1;
      vertexBuffer[this._vertexIndex++] = length;
      vertexBuffer[this._vertexIndex++] = thickness;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = color2.r / 255;
      vertexBuffer[this._vertexIndex++] = color2.g / 255;
      vertexBuffer[this._vertexIndex++] = color2.b / 255;
      vertexBuffer[this._vertexIndex++] = color2.a;
      vertexBuffer[this._vertexIndex++] = stroke.r / 255;
      vertexBuffer[this._vertexIndex++] = stroke.g / 255;
      vertexBuffer[this._vertexIndex++] = stroke.b / 255;
      vertexBuffer[this._vertexIndex++] = stroke.a;
      vertexBuffer[this._vertexIndex++] = strokeThickness / width;
    }
    drawRectangle(pos, width, height, color2, stroke = Color.Transparent, strokeThickness = 0) {
      if (this._isFull()) {
        this.flush();
      }
      this._rectangleCount++;
      const transform = this._context.getTransform();
      const opacity = this._context.opacity;
      const snapToPixel = this._context.snapToPixel;
      const topLeft = transform.multiply(pos.add(vec(0, 0)));
      const topRight = transform.multiply(pos.add(vec(width, 0)));
      const bottomRight = transform.multiply(pos.add(vec(width, height)));
      const bottomLeft = transform.multiply(pos.add(vec(0, height)));
      if (snapToPixel) {
        topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);
        topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);
        topRight.x = ~~(topRight.x + pixelSnapEpsilon);
        topRight.y = ~~(topRight.y + pixelSnapEpsilon);
        bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);
        bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);
        bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);
        bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);
      }
      const uvx0 = 0;
      const uvy0 = 0;
      const uvx1 = 1;
      const uvy1 = 1;
      const vertexBuffer = this._layout.vertexBuffer.bufferData;
      vertexBuffer[this._vertexIndex++] = topLeft.x;
      vertexBuffer[this._vertexIndex++] = topLeft.y;
      vertexBuffer[this._vertexIndex++] = uvx0;
      vertexBuffer[this._vertexIndex++] = uvy0;
      vertexBuffer[this._vertexIndex++] = width;
      vertexBuffer[this._vertexIndex++] = height;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = color2.r / 255;
      vertexBuffer[this._vertexIndex++] = color2.g / 255;
      vertexBuffer[this._vertexIndex++] = color2.b / 255;
      vertexBuffer[this._vertexIndex++] = color2.a;
      vertexBuffer[this._vertexIndex++] = stroke.r / 255;
      vertexBuffer[this._vertexIndex++] = stroke.g / 255;
      vertexBuffer[this._vertexIndex++] = stroke.b / 255;
      vertexBuffer[this._vertexIndex++] = stroke.a;
      vertexBuffer[this._vertexIndex++] = strokeThickness;
      vertexBuffer[this._vertexIndex++] = bottomLeft.x;
      vertexBuffer[this._vertexIndex++] = bottomLeft.y;
      vertexBuffer[this._vertexIndex++] = uvx0;
      vertexBuffer[this._vertexIndex++] = uvy1;
      vertexBuffer[this._vertexIndex++] = width;
      vertexBuffer[this._vertexIndex++] = height;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = color2.r / 255;
      vertexBuffer[this._vertexIndex++] = color2.g / 255;
      vertexBuffer[this._vertexIndex++] = color2.b / 255;
      vertexBuffer[this._vertexIndex++] = color2.a;
      vertexBuffer[this._vertexIndex++] = stroke.r / 255;
      vertexBuffer[this._vertexIndex++] = stroke.g / 255;
      vertexBuffer[this._vertexIndex++] = stroke.b / 255;
      vertexBuffer[this._vertexIndex++] = stroke.a;
      vertexBuffer[this._vertexIndex++] = strokeThickness;
      vertexBuffer[this._vertexIndex++] = topRight.x;
      vertexBuffer[this._vertexIndex++] = topRight.y;
      vertexBuffer[this._vertexIndex++] = uvx1;
      vertexBuffer[this._vertexIndex++] = uvy0;
      vertexBuffer[this._vertexIndex++] = width;
      vertexBuffer[this._vertexIndex++] = height;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = color2.r / 255;
      vertexBuffer[this._vertexIndex++] = color2.g / 255;
      vertexBuffer[this._vertexIndex++] = color2.b / 255;
      vertexBuffer[this._vertexIndex++] = color2.a;
      vertexBuffer[this._vertexIndex++] = stroke.r / 255;
      vertexBuffer[this._vertexIndex++] = stroke.g / 255;
      vertexBuffer[this._vertexIndex++] = stroke.b / 255;
      vertexBuffer[this._vertexIndex++] = stroke.a;
      vertexBuffer[this._vertexIndex++] = strokeThickness;
      vertexBuffer[this._vertexIndex++] = bottomRight.x;
      vertexBuffer[this._vertexIndex++] = bottomRight.y;
      vertexBuffer[this._vertexIndex++] = uvx1;
      vertexBuffer[this._vertexIndex++] = uvy1;
      vertexBuffer[this._vertexIndex++] = width;
      vertexBuffer[this._vertexIndex++] = height;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = color2.r / 255;
      vertexBuffer[this._vertexIndex++] = color2.g / 255;
      vertexBuffer[this._vertexIndex++] = color2.b / 255;
      vertexBuffer[this._vertexIndex++] = color2.a;
      vertexBuffer[this._vertexIndex++] = stroke.r / 255;
      vertexBuffer[this._vertexIndex++] = stroke.g / 255;
      vertexBuffer[this._vertexIndex++] = stroke.b / 255;
      vertexBuffer[this._vertexIndex++] = stroke.a;
      vertexBuffer[this._vertexIndex++] = strokeThickness;
    }
    hasPendingDraws() {
      return this._rectangleCount !== 0;
    }
    flush() {
      if (this._rectangleCount === 0) {
        return;
      }
      const gl2 = this._gl;
      this._shader.use();
      this._layout.use(true);
      this._shader.setUniformMatrix("u_matrix", this._context.ortho);
      this._quads.bind();
      gl2.drawElements(gl2.TRIANGLES, this._rectangleCount * 6, this._quads.bufferGlType, 0);
      GraphicsDiagnostics.DrawnImagesCount += this._rectangleCount;
      GraphicsDiagnostics.DrawCallCount++;
      this._rectangleCount = 0;
      this._vertexIndex = 0;
    }
  }
  const circle_renderer_frag = "#version 300 es\r\nprecision highp float;\r\n\r\n// UV coord\r\nin vec2 v_uv;\r\n\r\n// Color coord to blend with image\r\nin lowp vec4 v_color;\r\n\r\n// Stroke color if used\r\nin lowp vec4 v_strokeColor;\r\n\r\n// Stroke thickness if used\r\nin lowp float v_strokeThickness;\r\n\r\n// Opacity\r\nin float v_opacity;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  // make (0, 0) the center the uv \r\n  vec2 uv = v_uv * 2.0 - 1.0;\r\n\r\n  vec4 color = v_color;\r\n  vec4 strokeColor = v_strokeColor;\r\n\r\n  // circle border is at radius 1.0 \r\n  // dist is > 0 when inside the circle \r\n  float d = length(uv);\r\n  float dist = 1.0 - length(uv);\r\n\r\n  // Fade based on fwidth\r\n  float fade = fwidth(dot(uv, uv));\r\n\r\n  // if dist is greater than 0 step to 1;\r\n  // when we cross this 0 threshold add a smooth fade\r\n  float fill = smoothstep(-fade/2.0, fade/2.0, dist);\r\n\r\n  // if dist is greater than the stroke thickness step to 1\r\n  float stroke = 1.0 - smoothstep(v_strokeThickness, v_strokeThickness + fade, dist);\r\n\r\n  strokeColor.a *= fill * stroke;\r\n  strokeColor.rgb *= strokeColor.a;\r\n\r\n  color.a *= fill * (1.0 - stroke);\r\n  color.rgb *= color.a;\r\n\r\n  vec4 finalColor = mix(vec4(0.0), (color + strokeColor), fill);\r\n  finalColor.rgb = finalColor.rgb * v_opacity;\r\n  finalColor.a = finalColor.a * v_opacity;\r\n  fragColor = finalColor;\r\n}";
  const circle_renderer_vert = "#version 300 es\r\nin vec2 a_position;\r\n\r\n// UV coordinate\r\nin vec2 a_uv;\r\nout vec2 v_uv;\r\n\r\n// Opacity \r\nin float a_opacity;\r\nout float v_opacity;\r\n\r\nin vec4 a_color;\r\nout vec4 v_color;\r\n\r\nin vec4 a_strokeColor;\r\nout vec4 v_strokeColor;\r\n\r\nin float a_strokeThickness;\r\nout float v_strokeThickness;\r\n\r\nuniform mat4 u_matrix;\r\n\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);\r\n\r\n   // Pass through UV coords\r\n   v_uv = a_uv;\r\n   // Pass through the Opacity to the fragment shader\r\n   v_opacity = a_opacity;\r\n   // Pass through the color to the fragment shader\r\n   v_color = a_color;\r\n   // Pass through the stroke color to the fragment shader\r\n   v_strokeColor = a_strokeColor;\r\n   // Pass through the stroke thickenss to the fragment shader\r\n   v_strokeThickness = a_strokeThickness;\r\n}";
  class CircleRenderer {
    constructor() {
      this.type = "ex.circle";
      this.priority = 0;
      this._maxCircles = 10922;
      this._circleCount = 0;
      this._vertexIndex = 0;
    }
    initialize(gl2, context) {
      this._gl = gl2;
      this._context = context;
      this._shader = new Shader({
        gl: gl2,
        fragmentSource: circle_renderer_frag,
        vertexSource: circle_renderer_vert
      });
      this._shader.compile();
      this._shader.use();
      this._shader.setUniformMatrix("u_matrix", context.ortho);
      this._buffer = new VertexBuffer({
        gl: gl2,
        size: 14 * 4 * this._maxCircles,
        type: "dynamic"
      });
      this._layout = new VertexLayout({
        gl: gl2,
        shader: this._shader,
        vertexBuffer: this._buffer,
        attributes: [
          ["a_position", 2],
          ["a_uv", 2],
          ["a_opacity", 1],
          ["a_color", 4],
          ["a_strokeColor", 4],
          ["a_strokeThickness", 1]
        ]
      });
      this._quads = new QuadIndexBuffer(gl2, this._maxCircles, true);
    }
    _isFull() {
      if (this._circleCount >= this._maxCircles) {
        return true;
      }
      return false;
    }
    draw(pos, radius, color2, stroke = Color.Transparent, strokeThickness = 0) {
      if (this._isFull()) {
        this.flush();
      }
      this._circleCount++;
      const transform = this._context.getTransform();
      const opacity = this._context.opacity;
      const snapToPixel = this._context.snapToPixel;
      const topLeft = transform.multiply(pos.add(vec(-radius, -radius)));
      const topRight = transform.multiply(pos.add(vec(radius, -radius)));
      const bottomRight = transform.multiply(pos.add(vec(radius, radius)));
      const bottomLeft = transform.multiply(pos.add(vec(-radius, radius)));
      if (snapToPixel) {
        topLeft.x = ~~(topLeft.x + pixelSnapEpsilon);
        topLeft.y = ~~(topLeft.y + pixelSnapEpsilon);
        topRight.x = ~~(topRight.x + pixelSnapEpsilon);
        topRight.y = ~~(topRight.y + pixelSnapEpsilon);
        bottomLeft.x = ~~(bottomLeft.x + pixelSnapEpsilon);
        bottomLeft.y = ~~(bottomLeft.y + pixelSnapEpsilon);
        bottomRight.x = ~~(bottomRight.x + pixelSnapEpsilon);
        bottomRight.y = ~~(bottomRight.y + pixelSnapEpsilon);
      }
      const uvx0 = 0;
      const uvy0 = 0;
      const uvx1 = 1;
      const uvy1 = 1;
      const vertexBuffer = this._layout.vertexBuffer.bufferData;
      vertexBuffer[this._vertexIndex++] = topLeft.x;
      vertexBuffer[this._vertexIndex++] = topLeft.y;
      vertexBuffer[this._vertexIndex++] = uvx0;
      vertexBuffer[this._vertexIndex++] = uvy0;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = color2.r / 255;
      vertexBuffer[this._vertexIndex++] = color2.g / 255;
      vertexBuffer[this._vertexIndex++] = color2.b / 255;
      vertexBuffer[this._vertexIndex++] = color2.a;
      vertexBuffer[this._vertexIndex++] = stroke.r / 255;
      vertexBuffer[this._vertexIndex++] = stroke.g / 255;
      vertexBuffer[this._vertexIndex++] = stroke.b / 255;
      vertexBuffer[this._vertexIndex++] = stroke.a;
      vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
      vertexBuffer[this._vertexIndex++] = bottomLeft.x;
      vertexBuffer[this._vertexIndex++] = bottomLeft.y;
      vertexBuffer[this._vertexIndex++] = uvx0;
      vertexBuffer[this._vertexIndex++] = uvy1;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = color2.r / 255;
      vertexBuffer[this._vertexIndex++] = color2.g / 255;
      vertexBuffer[this._vertexIndex++] = color2.b / 255;
      vertexBuffer[this._vertexIndex++] = color2.a;
      vertexBuffer[this._vertexIndex++] = stroke.r / 255;
      vertexBuffer[this._vertexIndex++] = stroke.g / 255;
      vertexBuffer[this._vertexIndex++] = stroke.b / 255;
      vertexBuffer[this._vertexIndex++] = stroke.a;
      vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
      vertexBuffer[this._vertexIndex++] = topRight.x;
      vertexBuffer[this._vertexIndex++] = topRight.y;
      vertexBuffer[this._vertexIndex++] = uvx1;
      vertexBuffer[this._vertexIndex++] = uvy0;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = color2.r / 255;
      vertexBuffer[this._vertexIndex++] = color2.g / 255;
      vertexBuffer[this._vertexIndex++] = color2.b / 255;
      vertexBuffer[this._vertexIndex++] = color2.a;
      vertexBuffer[this._vertexIndex++] = stroke.r / 255;
      vertexBuffer[this._vertexIndex++] = stroke.g / 255;
      vertexBuffer[this._vertexIndex++] = stroke.b / 255;
      vertexBuffer[this._vertexIndex++] = stroke.a;
      vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
      vertexBuffer[this._vertexIndex++] = bottomRight.x;
      vertexBuffer[this._vertexIndex++] = bottomRight.y;
      vertexBuffer[this._vertexIndex++] = uvx1;
      vertexBuffer[this._vertexIndex++] = uvy1;
      vertexBuffer[this._vertexIndex++] = opacity;
      vertexBuffer[this._vertexIndex++] = color2.r / 255;
      vertexBuffer[this._vertexIndex++] = color2.g / 255;
      vertexBuffer[this._vertexIndex++] = color2.b / 255;
      vertexBuffer[this._vertexIndex++] = color2.a;
      vertexBuffer[this._vertexIndex++] = stroke.r / 255;
      vertexBuffer[this._vertexIndex++] = stroke.g / 255;
      vertexBuffer[this._vertexIndex++] = stroke.b / 255;
      vertexBuffer[this._vertexIndex++] = stroke.a;
      vertexBuffer[this._vertexIndex++] = strokeThickness / radius;
    }
    hasPendingDraws() {
      return this._circleCount !== 0;
    }
    flush() {
      if (this._circleCount === 0) {
        return;
      }
      const gl2 = this._gl;
      this._shader.use();
      this._layout.use(true);
      this._shader.setUniformMatrix("u_matrix", this._context.ortho);
      this._quads.bind();
      gl2.drawElements(gl2.TRIANGLES, this._circleCount * 6, this._quads.bufferGlType, 0);
      GraphicsDiagnostics.DrawnImagesCount += this._circleCount;
      GraphicsDiagnostics.DrawCallCount++;
      this._circleCount = 0;
      this._vertexIndex = 0;
    }
  }
  class Pool {
    constructor(builder, recycler, maxObjects = 100) {
      this.builder = builder;
      this.recycler = recycler;
      this.maxObjects = maxObjects;
      this.totalAllocations = 0;
      this.index = 0;
      this.objects = [];
      this.disableWarnings = false;
      this._logger = Logger2.getInstance();
    }
    preallocate() {
      for (let i2 = 0; i2 < this.maxObjects; i2++) {
        this.objects[i2] = this.builder();
      }
    }
    /**
     * Use many instances out of the in the context and return all to the pool.
     *
     * By returning values out of the context they will be un-hooked from the pool and are free to be passed to consumers
     * @param context
     */
    using(context) {
      const result = context(this);
      if (result) {
        return this.done(...result);
      }
      return this.done();
    }
    /**
     * Use a single instance out of th pool and immediately return it to the pool
     * @param context
     */
    borrow(context) {
      const object = this.get();
      context(object);
      this.index--;
    }
    /**
     * Retrieve a value from the pool, will allocate a new instance if necessary or recycle from the pool
     * @param args
     */
    get(...args) {
      if (this.index === this.maxObjects) {
        if (!this.disableWarnings) {
          this._logger.warn("Max pooled objects reached, possible memory leak? Doubling");
        }
        this.maxObjects = this.maxObjects * 2;
      }
      if (this.objects[this.index]) {
        return this.recycler(this.objects[this.index++], ...args);
      } else {
        this.totalAllocations++;
        const object = this.objects[this.index++] = this.builder(...args);
        return object;
      }
    }
    done(...objects) {
      this.index = 0;
      for (const object of objects) {
        const poolIndex = this.objects.indexOf(object);
        this.objects[poolIndex] = this.builder();
        this.totalAllocations++;
      }
      return objects;
    }
  }
  class DrawCall {
    constructor() {
      this.z = 0;
      this.priority = 0;
      this.transform = AffineMatrix.identity();
      this.state = {
        z: 0,
        opacity: 1,
        tint: Color.White,
        material: null
      };
    }
  }
  const defaultVertexSource = `#version 300 es
in vec2 a_position;

in vec2 a_uv;
out vec2 v_uv;

uniform mat4 u_matrix;
uniform mat4 u_transform;

void main() {
  // Set the vertex position using the ortho & transform matrix
  gl_Position = u_matrix * u_transform * vec4(a_position, 0.0, 1.0);

  // Pass through the UV coord to the fragment shader
  v_uv = a_uv;
}
`;
  class Material {
    constructor(options) {
      this._color = Color.Transparent;
      this._initialized = false;
      const { color: color2, name, vertexSource, fragmentSource } = options;
      this._name = name;
      this._vertexSource = vertexSource !== null && vertexSource !== void 0 ? vertexSource : defaultVertexSource;
      this._fragmentSource = fragmentSource;
      this._color = color2 !== null && color2 !== void 0 ? color2 : this._color;
    }
    initialize(_gl, _context) {
      if (this._initialized) {
        return;
      }
      this._shader = _context.createShader({
        vertexSource: this._vertexSource,
        fragmentSource: this._fragmentSource
      });
      this._shader.compile();
      this._initialized = true;
    }
    get name() {
      var _a;
      return (_a = this._name) !== null && _a !== void 0 ? _a : "anonymous material";
    }
    getShader() {
      return this._shader;
    }
    use() {
      if (this._initialized) {
        this._shader.use();
        this._shader.trySetUniformFloatColor("u_color", this._color);
      } else {
        throw Error(`Material ${this.name} not yet initialized, use the ExcaliburGraphicsContext.createMaterial() to work around this.`);
      }
    }
  }
  class MaterialRenderer {
    constructor() {
      this.type = "ex.material";
      this.priority = 0;
      this._textures = [];
    }
    initialize(gl2, context) {
      this._gl = gl2;
      this._context = context;
      this._buffer = new VertexBuffer({
        gl: gl2,
        size: 4 * 4,
        type: "dynamic"
      });
      this._layout = new VertexLayout({
        gl: gl2,
        vertexBuffer: this._buffer,
        attributes: [
          ["a_position", 2],
          ["a_uv", 2]
        ]
      });
      this._quads = new QuadIndexBuffer(gl2, 1, true);
    }
    draw(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
      var _a, _b, _c, _d;
      const gl2 = this._gl;
      const material = this._context.material;
      material.initialize(gl2, this._context);
      const transform = this._context.getTransform();
      const opacity = this._context.opacity;
      const shader = material.getShader();
      const vertexBuffer = this._layout.vertexBuffer.bufferData;
      let vertexIndex = 0;
      let width = (image === null || image === void 0 ? void 0 : image.width) || swidth || 0;
      let height = (image === null || image === void 0 ? void 0 : image.height) || sheight || 0;
      let view = [0, 0, (_a = swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width) !== null && _a !== void 0 ? _a : 0, (_b = sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height) !== null && _b !== void 0 ? _b : 0];
      let dest = [sx !== null && sx !== void 0 ? sx : 1, sy !== null && sy !== void 0 ? sy : 1];
      if (dx !== void 0 && dy !== void 0 && dwidth !== void 0 && dheight !== void 0) {
        view = [sx !== null && sx !== void 0 ? sx : 1, sy !== null && sy !== void 0 ? sy : 1, (_c = swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width) !== null && _c !== void 0 ? _c : 0, (_d = sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height) !== null && _d !== void 0 ? _d : 0];
        dest = [dx, dy];
        width = dwidth;
        height = dheight;
      }
      sx = view[0];
      sy = view[1];
      const sw = view[2];
      const sh2 = view[3];
      const topLeft = vec(dest[0], dest[1]);
      const topRight = vec(dest[0] + width, dest[1]);
      const bottomLeft = vec(dest[0], dest[1] + height);
      const bottomRight = vec(dest[0] + width, dest[1] + height);
      const imageWidth = image.width || width;
      const imageHeight = image.height || height;
      const uvx0 = sx / imageWidth;
      const uvy0 = sy / imageHeight;
      const uvx1 = (sx + sw - 0.01) / imageWidth;
      const uvy1 = (sy + sh2 - 0.01) / imageHeight;
      vertexBuffer[vertexIndex++] = topLeft.x;
      vertexBuffer[vertexIndex++] = topLeft.y;
      vertexBuffer[vertexIndex++] = uvx0;
      vertexBuffer[vertexIndex++] = uvy0;
      vertexBuffer[vertexIndex++] = bottomLeft.x;
      vertexBuffer[vertexIndex++] = bottomLeft.y;
      vertexBuffer[vertexIndex++] = uvx0;
      vertexBuffer[vertexIndex++] = uvy1;
      vertexBuffer[vertexIndex++] = topRight.x;
      vertexBuffer[vertexIndex++] = topRight.y;
      vertexBuffer[vertexIndex++] = uvx1;
      vertexBuffer[vertexIndex++] = uvy0;
      vertexBuffer[vertexIndex++] = bottomRight.x;
      vertexBuffer[vertexIndex++] = bottomRight.y;
      vertexBuffer[vertexIndex++] = uvx1;
      vertexBuffer[vertexIndex++] = uvy1;
      const texture = this._addImageAsTexture(image);
      material.use();
      this._layout.shader = shader;
      this._layout.use(true);
      shader.trySetUniformFloat("u_opacity", opacity);
      shader.trySetUniformFloatVector("u_resolution", vec(this._context.width, this._context.height));
      shader.trySetUniformFloatVector("u_size", vec(sw, sh2));
      shader.trySetUniformMatrix("u_matrix", this._context.ortho);
      shader.trySetUniformMatrix("u_transform", transform.to4x4());
      gl2.activeTexture(gl2.TEXTURE0 + 0);
      gl2.bindTexture(gl2.TEXTURE_2D, texture);
      shader.trySetUniformInt("u_graphic", 0);
      this._quads.bind();
      gl2.drawElements(gl2.TRIANGLES, 6, this._quads.bufferGlType, 0);
    }
    _addImageAsTexture(image) {
      const maybeFiltering = image.getAttribute("filtering");
      let filtering = null;
      if (maybeFiltering === ImageFiltering.Blended || maybeFiltering === ImageFiltering.Pixel) {
        filtering = maybeFiltering;
      }
      const force = image.getAttribute("forceUpload") === "true" ? true : false;
      const texture = this._context.textureLoader.load(image, filtering, force);
      image.removeAttribute("forceUpload");
      if (this._textures.indexOf(texture) === -1) {
        this._textures.push(texture);
      }
      return texture;
    }
    hasPendingDraws() {
      return false;
    }
    flush() {
    }
  }
  const pixelSnapEpsilon = 1e-4;
  class ExcaliburGraphicsContextWebGLDebug {
    constructor(_webglCtx) {
      this._webglCtx = _webglCtx;
      this._debugText = new DebugText();
    }
    /**
     * Draw a debugging rectangle to the context
     * @param x
     * @param y
     * @param width
     * @param height
     */
    drawRect(x2, y2, width, height, rectOptions = { color: Color.Black }) {
      this.drawLine(vec(x2, y2), vec(x2 + width, y2), { ...rectOptions });
      this.drawLine(vec(x2 + width, y2), vec(x2 + width, y2 + height), { ...rectOptions });
      this.drawLine(vec(x2 + width, y2 + height), vec(x2, y2 + height), { ...rectOptions });
      this.drawLine(vec(x2, y2 + height), vec(x2, y2), { ...rectOptions });
    }
    /**
     * Draw a debugging line to the context
     * @param start
     * @param end
     * @param lineOptions
     */
    drawLine(start, end, lineOptions = { color: Color.Black }) {
      this._webglCtx.draw("ex.line", start, end, lineOptions.color);
    }
    /**
     * Draw a debugging point to the context
     * @param point
     * @param pointOptions
     */
    drawPoint(point2, pointOptions = { color: Color.Black, size: 5 }) {
      this._webglCtx.draw("ex.point", point2, pointOptions.color, pointOptions.size);
    }
    drawText(text, pos) {
      this._debugText.write(this._webglCtx, text, pos);
    }
  }
  class ExcaliburGraphicsContextWebGL {
    get z() {
      return this._state.current.z;
    }
    set z(value) {
      this._state.current.z = value;
    }
    get opacity() {
      return this._state.current.opacity;
    }
    set opacity(value) {
      this._state.current.opacity = value;
    }
    get tint() {
      return this._state.current.tint;
    }
    set tint(color2) {
      this._state.current.tint = color2;
    }
    get width() {
      return this.__gl.canvas.width;
    }
    get height() {
      return this.__gl.canvas.height;
    }
    get ortho() {
      return this._ortho;
    }
    /**
     * Checks the underlying webgl implementation if the requested internal resolution is supported
     * @param dim
     */
    checkIfResolutionSupported(dim) {
      let supported = true;
      if (dim.width > 4096 || dim.height > 4096) {
        supported = false;
      }
      return supported;
    }
    constructor(options) {
      this._logger = Logger2.getInstance();
      this._renderers = /* @__PURE__ */ new Map();
      this._isDrawLifecycle = false;
      this.useDrawSorting = true;
      this._drawCallPool = new Pool(() => new DrawCall(), (instance2) => {
        instance2.priority = 0;
        instance2.z = 0;
        instance2.renderer = void 0;
        instance2.args = void 0;
        return instance2;
      }, 4e3);
      this._drawCalls = [];
      this._postProcessTargets = [];
      this._postprocessors = [];
      this._transform = new TransformStack();
      this._state = new StateStack();
      this.snapToPixel = false;
      this.smoothing = false;
      this.backgroundColor = Color.ExcaliburBlue;
      this._alreadyWarnedDrawLifecycle = false;
      this.debug = new ExcaliburGraphicsContextWebGLDebug(this);
      this._totalPostProcessorTime = 0;
      const { canvasElement, enableTransparency, smoothing, snapToPixel, backgroundColor, useDrawSorting } = options;
      this.__gl = canvasElement.getContext("webgl2", {
        antialias: smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing,
        premultipliedAlpha: false,
        alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true,
        depth: true,
        powerPreference: "high-performance"
        // TODO Chromium fixed the bug where this didn't work now it breaks CI :(
        // failIfMajorPerformanceCaveat: true
      });
      if (!this.__gl) {
        throw Error("Failed to retrieve webgl context from browser");
      }
      this.textureLoader = new TextureLoader(this.__gl);
      this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;
      this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;
      this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;
      this.useDrawSorting = useDrawSorting !== null && useDrawSorting !== void 0 ? useDrawSorting : this.useDrawSorting;
      this._drawCallPool.disableWarnings = true;
      this._drawCallPool.preallocate();
      this._init();
    }
    _init() {
      const gl2 = this.__gl;
      this._ortho = Matrix.ortho(0, gl2.canvas.width, gl2.canvas.height, 0, 400, -400);
      gl2.viewport(0, 0, gl2.canvas.width, gl2.canvas.height);
      gl2.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
      gl2.clear(gl2.COLOR_BUFFER_BIT);
      gl2.enable(gl2.BLEND);
      gl2.blendEquation(gl2.FUNC_ADD);
      gl2.blendFunc(gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA);
      gl2.blendEquationSeparate(gl2.FUNC_ADD, gl2.FUNC_ADD);
      gl2.blendFuncSeparate(gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA, gl2.ONE, gl2.ONE_MINUS_SRC_ALPHA);
      this.register(new ImageRenderer());
      this.register(new MaterialRenderer());
      this.register(new RectangleRenderer());
      this.register(new CircleRenderer());
      this.register(new PointRenderer());
      this.register(new LineRenderer());
      this._screenRenderer = new ScreenPassPainter(gl2);
      this._renderTarget = new RenderTarget({
        gl: gl2,
        width: gl2.canvas.width,
        height: gl2.canvas.height
      });
      this._postProcessTargets = [
        new RenderTarget({
          gl: gl2,
          width: gl2.canvas.width,
          height: gl2.canvas.height
        }),
        new RenderTarget({
          gl: gl2,
          width: gl2.canvas.width,
          height: gl2.canvas.height
        })
      ];
    }
    register(renderer) {
      this._renderers.set(renderer.type, renderer);
      renderer.initialize(this.__gl, this);
    }
    get(rendererName) {
      return this._renderers.get(rendererName);
    }
    _isCurrentRenderer(renderer) {
      if (!this._currentRenderer || this._currentRenderer === renderer) {
        return true;
      }
      return false;
    }
    beginDrawLifecycle() {
      this._isDrawLifecycle = true;
    }
    endDrawLifecycle() {
      this._isDrawLifecycle = false;
    }
    draw(rendererName, ...args) {
      if (!this._isDrawLifecycle && !this._alreadyWarnedDrawLifecycle) {
        this._logger.warn(`Attempting to draw outside the the drawing lifecycle (preDraw/postDraw) is not supported and is a source of bugs/errors.
If you want to do custom drawing, use Actor.graphics, or any onPreDraw or onPostDraw handler.`);
        this._alreadyWarnedDrawLifecycle = true;
      }
      const renderer = this._renderers.get(rendererName);
      if (renderer) {
        if (this.useDrawSorting) {
          const drawCall = this._drawCallPool.get();
          drawCall.z = this._state.current.z;
          drawCall.priority = renderer.priority;
          drawCall.renderer = rendererName;
          this.getTransform().clone(drawCall.transform);
          drawCall.state.z = this._state.current.z;
          drawCall.state.opacity = this._state.current.opacity;
          drawCall.state.tint = this._state.current.tint;
          drawCall.state.material = this._state.current.material;
          drawCall.args = args;
          this._drawCalls.push(drawCall);
        } else {
          if (!this._currentRenderer) {
            this._currentRenderer = renderer;
          }
          if (!this._isCurrentRenderer(renderer)) {
            this._currentRenderer.flush();
          }
          renderer.draw(...args);
          this._currentRenderer = renderer;
        }
      } else {
        throw Error(`No renderer with name ${rendererName} has been registered`);
      }
    }
    resetTransform() {
      this._transform.current = AffineMatrix.identity();
    }
    updateViewport(resolution) {
      const gl2 = this.__gl;
      this._ortho = this._ortho = Matrix.ortho(0, resolution.width, resolution.height, 0, 400, -400);
      this._renderTarget.setResolution(gl2.canvas.width, gl2.canvas.height);
      this._postProcessTargets[0].setResolution(gl2.canvas.width, gl2.canvas.height);
      this._postProcessTargets[1].setResolution(gl2.canvas.width, gl2.canvas.height);
    }
    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
      if (swidth === 0 || sheight === 0) {
        return;
      } else if (dwidth === 0 || dheight === 0) {
        return;
      } else if (image.width === 0 || image.height === 0) {
        return;
      }
      if (!image) {
        Logger2.getInstance().warn("Cannot draw a null or undefined image");
        if (console.trace) {
          console.trace();
        }
        return;
      }
      if (this._state.current.material) {
        this.draw("ex.material", image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
      } else {
        this.draw("ex.image", image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
      }
    }
    drawLine(start, end, color2, thickness = 1) {
      this.draw("ex.rectangle", start, end, color2, thickness);
    }
    drawRectangle(pos, width, height, color2, stroke, strokeThickness) {
      this.draw("ex.rectangle", pos, width, height, color2, stroke, strokeThickness);
    }
    drawCircle(pos, radius, color2, stroke, thickness) {
      this.draw("ex.circle", pos, radius, color2, stroke, thickness);
    }
    save() {
      this._transform.save();
      this._state.save();
    }
    restore() {
      this._transform.restore();
      this._state.restore();
    }
    translate(x2, y2) {
      this._transform.translate(this.snapToPixel ? ~~(x2 + pixelSnapEpsilon) : x2, this.snapToPixel ? ~~(y2 + pixelSnapEpsilon) : y2);
    }
    rotate(angle) {
      this._transform.rotate(angle);
    }
    scale(x2, y2) {
      this._transform.scale(x2, y2);
    }
    transform(matrix) {
      this._transform.current = matrix;
    }
    getTransform() {
      return this._transform.current;
    }
    multiply(m2) {
      this._transform.current.multiply(m2, this._transform.current);
    }
    addPostProcessor(postprocessor) {
      this._postprocessors.push(postprocessor);
      postprocessor.initialize(this.__gl);
    }
    removePostProcessor(postprocessor) {
      const index = this._postprocessors.indexOf(postprocessor);
      if (index !== -1) {
        this._postprocessors.splice(index, 1);
      }
    }
    clearPostProcessors() {
      this._postprocessors.length = 0;
    }
    updatePostProcessors(delta) {
      for (const postprocessor of this._postprocessors) {
        const shader = postprocessor.getShader();
        shader.use();
        const uniforms = shader.getUniforms();
        this._totalPostProcessorTime += delta;
        if (uniforms.find((u2) => u2.name === "u_time_ms")) {
          shader.setUniformFloat("u_time_ms", this._totalPostProcessorTime);
        }
        if (uniforms.find((u2) => u2.name === "u_elapsed_ms")) {
          shader.setUniformFloat("u_elapsed_ms", delta);
        }
        if (uniforms.find((u2) => u2.name === "u_resolution")) {
          shader.setUniformFloatVector("u_resolution", vec(this.width, this.height));
        }
        if (postprocessor.onUpdate) {
          postprocessor.onUpdate(delta);
        }
      }
    }
    set material(material) {
      this._state.current.material = material;
    }
    get material() {
      return this._state.current.material;
    }
    /**
     * Creates and initializes the material which compiles the internal shader
     * @param options
     * @returns Material
     */
    createMaterial(options) {
      const material = new Material(options);
      material.initialize(this.__gl, this);
      return material;
    }
    createShader(options) {
      const gl2 = this.__gl;
      const { vertexSource, fragmentSource } = options;
      const shader = new Shader({
        gl: gl2,
        vertexSource,
        fragmentSource
      });
      shader.compile();
      return shader;
    }
    clear() {
      const gl2 = this.__gl;
      this._renderTarget.use();
      gl2.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
      gl2.clear(gl2.COLOR_BUFFER_BIT);
    }
    /**
     * Flushes all batched rendering to the screen
     */
    flush() {
      const gl2 = this.__gl;
      this._renderTarget.use();
      if (this.useDrawSorting) {
        const originalSort = /* @__PURE__ */ new Map();
        for (const [name] of this._renderers) {
          const firstIndex = this._drawCalls.findIndex((dc2) => dc2.renderer === name);
          originalSort.set(name, firstIndex);
        }
        this._drawCalls.sort((a2, b2) => {
          const zIndex = a2.z - b2.z;
          const originalSortOrder = originalSort.get(a2.renderer) - originalSort.get(b2.renderer);
          const priority = a2.priority - b2.priority;
          if (zIndex === 0) {
            if (priority === 0) {
              return originalSortOrder;
            }
            return priority;
          }
          return zIndex;
        });
        const oldTransform = this._transform.current;
        const oldState = this._state.current;
        if (this._drawCalls.length) {
          let currentRendererName = this._drawCalls[0].renderer;
          let currentRenderer = this._renderers.get(currentRendererName);
          for (let i2 = 0; i2 < this._drawCalls.length; i2++) {
            this._transform.current = this._drawCalls[i2].transform;
            this._state.current = this._drawCalls[i2].state;
            if (this._drawCalls[i2].renderer !== currentRendererName) {
              currentRenderer.flush();
              currentRendererName = this._drawCalls[i2].renderer;
              currentRenderer = this._renderers.get(currentRendererName);
            }
            currentRenderer.draw(...this._drawCalls[i2].args);
          }
          if (currentRenderer.hasPendingDraws()) {
            currentRenderer.flush();
          }
        }
        this._transform.current = oldTransform;
        this._state.current = oldState;
        this._drawCallPool.done();
        this._drawCalls.length = 0;
      } else {
        for (const renderer of this._renderers.values()) {
          if (renderer.hasPendingDraws()) {
            renderer.flush();
          }
        }
      }
      this._renderTarget.disable();
      const source = this._renderTarget.toRenderSource();
      source.use();
      for (let i2 = 0; i2 < this._postprocessors.length; i2++) {
        this._postProcessTargets[i2 % 2].use();
        this._screenRenderer.renderWithPostProcessor(this._postprocessors[i2]);
        this._postProcessTargets[i2 % 2].toRenderSource().use();
      }
      gl2.bindFramebuffer(gl2.FRAMEBUFFER, null);
      this._screenRenderer.renderToScreen();
    }
  }
  const ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon = 1e-4;
  class ExcaliburGraphicsContext2DCanvasDebug {
    constructor(_ex) {
      this._ex = _ex;
      this._debugText = new DebugText();
    }
    /**
     * Draw a debug rectangle to the context
     * @param x
     * @param y
     * @param width
     * @param height
     */
    drawRect(x2, y2, width, height) {
      this._ex.__ctx.save();
      this._ex.__ctx.strokeStyle = "red";
      this._ex.__ctx.strokeRect(this._ex.snapToPixel ? ~~(x2 + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : x2, this._ex.snapToPixel ? ~~(y2 + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : y2, this._ex.snapToPixel ? ~~(width + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : width, this._ex.snapToPixel ? ~~(height + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : height);
      this._ex.__ctx.restore();
    }
    drawLine(start, end, lineOptions = { color: Color.Black }) {
      this._ex.__ctx.save();
      this._ex.__ctx.beginPath();
      this._ex.__ctx.strokeStyle = lineOptions.color.toString();
      this._ex.__ctx.moveTo(this._ex.snapToPixel ? ~~(start.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.x, this._ex.snapToPixel ? ~~(start.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.y);
      this._ex.__ctx.lineTo(this._ex.snapToPixel ? ~~(end.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.x, this._ex.snapToPixel ? ~~(end.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.y);
      this._ex.__ctx.lineWidth = 2;
      this._ex.__ctx.stroke();
      this._ex.__ctx.closePath();
      this._ex.__ctx.restore();
    }
    drawPoint(point2, pointOptions = { color: Color.Black, size: 5 }) {
      this._ex.__ctx.save();
      this._ex.__ctx.beginPath();
      this._ex.__ctx.fillStyle = pointOptions.color.toString();
      this._ex.__ctx.arc(this._ex.snapToPixel ? ~~(point2.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : point2.x, this._ex.snapToPixel ? ~~(point2.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : point2.y, pointOptions.size, 0, Math.PI * 2);
      this._ex.__ctx.fill();
      this._ex.__ctx.closePath();
      this._ex.__ctx.restore();
    }
    drawText(text, pos) {
      this._debugText.write(this._ex, text, pos);
    }
  }
  class ExcaliburGraphicsContext2DCanvas {
    get width() {
      return this.__ctx.canvas.width;
    }
    get height() {
      return this.__ctx.canvas.height;
    }
    get opacity() {
      return this._state.current.opacity;
    }
    set opacity(value) {
      this._state.current.opacity = value;
    }
    get tint() {
      return this._state.current.tint;
    }
    set tint(color2) {
      this._state.current.tint = color2;
    }
    get smoothing() {
      return this.__ctx.imageSmoothingEnabled;
    }
    set smoothing(value) {
      this.__ctx.imageSmoothingEnabled = value;
    }
    constructor(options) {
      this.useDrawSorting = false;
      this.z = 0;
      this.backgroundColor = Color.ExcaliburBlue;
      this._state = new StateStack();
      this.snapToPixel = false;
      this.debug = new ExcaliburGraphicsContext2DCanvasDebug(this);
      const { canvasElement, enableTransparency, snapToPixel, smoothing, backgroundColor } = options;
      this.__ctx = canvasElement.getContext("2d", {
        alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true
      });
      this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;
      this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;
      this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;
    }
    resetTransform() {
      this.__ctx.resetTransform();
    }
    updateViewport(_resolution) {
    }
    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
      if (swidth === 0 || sheight === 0) {
        return;
      } else if (dwidth === 0 || dheight === 0) {
        return;
      } else if (image.width === 0 || image.height === 0) {
        return;
      }
      this.__ctx.globalAlpha = this.opacity;
      const args = [image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight].filter((a2) => a2 !== void 0).map((a2) => typeof a2 === "number" && this.snapToPixel ? ~~a2 : a2);
      this.__ctx.drawImage.apply(this.__ctx, args);
      GraphicsDiagnostics.DrawCallCount++;
      GraphicsDiagnostics.DrawnImagesCount = 1;
    }
    drawLine(start, end, color2, thickness = 1) {
      this.__ctx.save();
      this.__ctx.beginPath();
      this.__ctx.strokeStyle = color2.toString();
      this.__ctx.moveTo(this.snapToPixel ? ~~(start.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.x, this.snapToPixel ? ~~(start.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : start.y);
      this.__ctx.lineTo(this.snapToPixel ? ~~(end.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.x, this.snapToPixel ? ~~(end.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : end.y);
      this.__ctx.lineWidth = thickness;
      this.__ctx.stroke();
      this.__ctx.closePath();
      this.__ctx.restore();
    }
    drawRectangle(pos, width, height, color2) {
      this.__ctx.save();
      this.__ctx.fillStyle = color2.toString();
      this.__ctx.fillRect(this.snapToPixel ? ~~(pos.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.x, this.snapToPixel ? ~~(pos.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.y, this.snapToPixel ? ~~(width + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : width, this.snapToPixel ? ~~(height + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : height);
      this.__ctx.restore();
    }
    drawCircle(pos, radius, color2, stroke, thickness) {
      this.__ctx.save();
      this.__ctx.beginPath();
      if (stroke) {
        this.__ctx.strokeStyle = stroke.toString();
      }
      if (thickness) {
        this.__ctx.lineWidth = thickness;
      }
      this.__ctx.fillStyle = color2.toString();
      this.__ctx.arc(this.snapToPixel ? ~~(pos.x + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.x, this.snapToPixel ? ~~(pos.y + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : pos.y, radius, 0, Math.PI * 2);
      this.__ctx.fill();
      if (stroke) {
        this.__ctx.stroke();
      }
      this.__ctx.closePath();
      this.__ctx.restore();
    }
    /**
     * Save the current state of the canvas to the stack (transforms and opacity)
     */
    save() {
      this.__ctx.save();
    }
    /**
     * Restore the state of the canvas from the stack
     */
    restore() {
      this.__ctx.restore();
    }
    /**
     * Translate the origin of the context by an x and y
     * @param x
     * @param y
     */
    translate(x2, y2) {
      this.__ctx.translate(this.snapToPixel ? ~~(x2 + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : x2, this.snapToPixel ? ~~(y2 + ExcaliburGraphicsContext2DCanvas_pixelSnapEpsilon) : y2);
    }
    /**
     * Rotate the context about the current origin
     */
    rotate(angle) {
      this.__ctx.rotate(angle);
    }
    /**
     * Scale the context by an x and y factor
     * @param x
     * @param y
     */
    scale(x2, y2) {
      this.__ctx.scale(x2, y2);
    }
    getTransform() {
      throw new Error("Not implemented");
    }
    multiply(_m) {
      this.__ctx.setTransform(this.__ctx.getTransform().multiply(_m.toDOMMatrix()));
    }
    addPostProcessor(_postprocessor) {
    }
    removePostProcessor(_postprocessor) {
    }
    clearPostProcessors() {
    }
    updatePostProcessors(_delta) {
    }
    beginDrawLifecycle() {
    }
    endDrawLifecycle() {
    }
    set material(material) {
      this._state.current.material = material;
    }
    get material() {
      return this._state.current.material;
    }
    createMaterial(_options) {
      return null;
    }
    clear() {
      this.__ctx.clearRect(0, 0, this.width, this.height);
      this.__ctx.fillStyle = this.backgroundColor.toString();
      this.__ctx.fillRect(0, 0, this.width, this.height);
      GraphicsDiagnostics.clear();
    }
    /**
     * Flushes the batched draw calls to the screen
     */
    flush() {
    }
  }
  var DisplayMode;
  (function(DisplayMode2) {
    DisplayMode2["Fixed"] = "Fixed";
    DisplayMode2["FitContainerAndFill"] = "FitContainerAndFill";
    DisplayMode2["FitScreenAndFill"] = "FitScreenAndFill";
    DisplayMode2["FitContainerAndZoom"] = "FitContainerAndZoom";
    DisplayMode2["FitScreenAndZoom"] = "FitScreenAndZoom";
    DisplayMode2["FitScreen"] = "FitScreen";
    DisplayMode2["FillScreen"] = "FillScreen";
    DisplayMode2["FitContainer"] = "FitContainer";
    DisplayMode2["FillContainer"] = "FillContainer";
  })(DisplayMode || (DisplayMode = {}));
  class Resolution {
    /* istanbul ignore next */
    static get SVGA() {
      return { width: 800, height: 600 };
    }
    /* istanbul ignore next */
    static get Standard() {
      return { width: 1920, height: 1080 };
    }
    /* istanbul ignore next */
    static get Atari2600() {
      return { width: 160, height: 192 };
    }
    /* istanbul ignore next */
    static get GameBoy() {
      return { width: 160, height: 144 };
    }
    /* istanbul ignore next */
    static get GameBoyAdvance() {
      return { width: 240, height: 160 };
    }
    /* istanbul ignore next */
    static get NintendoDS() {
      return { width: 256, height: 192 };
    }
    /* istanbul ignore next */
    static get NES() {
      return { width: 256, height: 224 };
    }
    /* istanbul ignore next */
    static get SNES() {
      return { width: 256, height: 244 };
    }
  }
  class Screen {
    constructor(options) {
      var _a, _b, _c;
      this._antialiasing = true;
      this._resolutionStack = [];
      this._viewportStack = [];
      this._pixelRatioOverride = null;
      this._isFullScreen = false;
      this._isDisposed = false;
      this._logger = Logger2.getInstance();
      this._fullscreenChangeHandler = () => {
        this._isFullScreen = !this._isFullScreen;
        this._logger.debug("Fullscreen Change", this._isFullScreen);
      };
      this._pixelRatioChangeHandler = () => {
        this._logger.debug("Pixel Ratio Change", window.devicePixelRatio);
        this._listenForPixelRatio();
        this._devicePixelRatio = this._calculateDevicePixelRatio();
        this.applyResolutionAndViewport();
      };
      this._resizeHandler = () => {
        const parent = this.parent;
        this._logger.debug("View port resized");
        this._setResolutionAndViewportByDisplayMode(parent);
        this.applyResolutionAndViewport();
      };
      this._devicePixelRatio = this._calculateDevicePixelRatio();
      this._alreadyWarned = false;
      this._contentArea = new BoundingBox();
      this.viewport = options.viewport;
      this.resolution = (_a = options.resolution) !== null && _a !== void 0 ? _a : { ...this.viewport };
      this._contentResolution = this.resolution;
      this._displayMode = (_b = options.displayMode) !== null && _b !== void 0 ? _b : DisplayMode.Fixed;
      this._canvas = options.canvas;
      this.graphicsContext = options.context;
      this._antialiasing = (_c = options.antialiasing) !== null && _c !== void 0 ? _c : this._antialiasing;
      this._browser = options.browser;
      this._pixelRatioOverride = options.pixelRatio;
      this._applyDisplayMode();
      this._listenForPixelRatio();
      this._canvas.addEventListener("fullscreenchange", this._fullscreenChangeHandler);
      this.applyResolutionAndViewport();
    }
    _listenForPixelRatio() {
      if (this._mediaQueryList && !this._mediaQueryList.addEventListener) {
        this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);
      }
      this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
      if (this._mediaQueryList.addEventListener) {
        this._mediaQueryList.addEventListener("change", this._pixelRatioChangeHandler, { once: true });
      } else {
        this._mediaQueryList.addListener(this._pixelRatioChangeHandler);
      }
    }
    dispose() {
      if (!this._isDisposed) {
        this._isDisposed = true;
        this._browser.window.off("resize", this._resizeHandler);
        if (this._resizeObserver) {
          this._resizeObserver.disconnect();
        }
        this.parent.removeEventListener("resize", this._resizeHandler);
        if (this._mediaQueryList.removeEventListener) {
          this._mediaQueryList.removeEventListener("change", this._pixelRatioChangeHandler);
        } else {
          this._mediaQueryList.removeListener(this._pixelRatioChangeHandler);
        }
        this._canvas.removeEventListener("fullscreenchange", this._fullscreenChangeHandler);
      }
    }
    _calculateDevicePixelRatio() {
      if (window.devicePixelRatio < 1) {
        return 1;
      }
      const devicePixelRatio = window.devicePixelRatio || 1;
      return devicePixelRatio;
    }
    get pixelRatio() {
      if (this._pixelRatioOverride) {
        return this._pixelRatioOverride;
      }
      return this._devicePixelRatio;
    }
    get isHiDpi() {
      return this.pixelRatio !== 1;
    }
    get displayMode() {
      return this._displayMode;
    }
    get canvas() {
      return this._canvas;
    }
    get parent() {
      switch (this.displayMode) {
        case DisplayMode.FillContainer:
        case DisplayMode.FitContainer:
        case DisplayMode.FitContainerAndFill:
        case DisplayMode.FitContainerAndZoom:
          return this.canvas.parentElement || document.body;
        default:
          return window;
      }
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(resolution) {
      this._resolution = resolution;
    }
    get viewport() {
      if (this._viewport) {
        return this._viewport;
      }
      return this._resolution;
    }
    set viewport(viewport) {
      this._viewport = viewport;
    }
    get aspectRatio() {
      return this._resolution.width / this._resolution.height;
    }
    get scaledWidth() {
      return this._resolution.width * this.pixelRatio;
    }
    get scaledHeight() {
      return this._resolution.height * this.pixelRatio;
    }
    setCurrentCamera(camera) {
      this._camera = camera;
    }
    pushResolutionAndViewport() {
      this._resolutionStack.push(this.resolution);
      this._viewportStack.push(this.viewport);
      this.resolution = { ...this.resolution };
      this.viewport = { ...this.viewport };
    }
    peekViewport() {
      return this._viewportStack[this._viewportStack.length - 1];
    }
    peekResolution() {
      return this._resolutionStack[this._resolutionStack.length - 1];
    }
    popResolutionAndViewport() {
      this.resolution = this._resolutionStack.pop();
      this.viewport = this._viewportStack.pop();
    }
    applyResolutionAndViewport() {
      this._canvas.width = this.scaledWidth;
      this._canvas.height = this.scaledHeight;
      if (this.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {
        const supported = this.graphicsContext.checkIfResolutionSupported({
          width: this.scaledWidth,
          height: this.scaledHeight
        });
        if (!supported && !this._alreadyWarned) {
          this._alreadyWarned = true;
          this._logger.warn(`The currently configured resolution (${this.resolution.width}x${this.resolution.height}) and pixel ratio (${this.pixelRatio}) are too large for the platform WebGL implementation, this may work but cause WebGL rendering to behave oddly. Try reducing the resolution or disabling Hi DPI scaling to avoid this (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).`);
        }
      }
      if (this._antialiasing) {
        this._canvas.style.imageRendering = "auto";
      } else {
        this._canvas.style.imageRendering = "pixelated";
        if (this._canvas.style.imageRendering === "") {
          this._canvas.style.imageRendering = "crisp-edges";
        }
      }
      this._canvas.style.width = this.viewport.width + "px";
      this._canvas.style.height = this.viewport.height + "px";
      this.graphicsContext.updateViewport(this.resolution);
      this.graphicsContext.resetTransform();
      this.graphicsContext.smoothing = this._antialiasing;
      if (this.graphicsContext instanceof ExcaliburGraphicsContext2DCanvas) {
        this.graphicsContext.scale(this.pixelRatio, this.pixelRatio);
      }
    }
    get antialiasing() {
      return this._antialiasing;
    }
    set antialiasing(isSmooth) {
      this._antialiasing = isSmooth;
      this.graphicsContext.smoothing = this._antialiasing;
    }
    /**
     * Returns true if excalibur is fullscreen using the browser fullscreen api
     */
    get isFullScreen() {
      return this._isFullScreen;
    }
    /**
     * Requests to go fullscreen using the browser fullscreen api, requires user interaction to be successful.
     * For example, wire this to a user click handler.
     *
     * Optionally specify a target element id to go fullscreen, by default the game canvas is used
     * @param elementId
     */
    goFullScreen(elementId) {
      if (elementId) {
        const maybeElement = document.getElementById(elementId);
        if (maybeElement) {
          return maybeElement.requestFullscreen();
        }
      }
      return this._canvas.requestFullscreen();
    }
    /**
     * Requests to exit fullscreen using the browser fullscreen api
     */
    exitFullScreen() {
      return document.exitFullscreen();
    }
    /**
     * Takes a coordinate in normal html page space, for example from a pointer move event, and translates it to
     * Excalibur screen space.
     *
     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
     * bottom right corner (resolutionX, resolutionY)
     * @param point
     */
    pageToScreenCoordinates(point2) {
      let newX = point2.x;
      let newY = point2.y;
      if (!this._isFullScreen) {
        newX -= getPosition(this._canvas).x;
        newY -= getPosition(this._canvas).y;
      }
      if (this._isFullScreen) {
        if (window.innerWidth / this.aspectRatio < window.innerHeight) {
          const screenHeight = window.innerWidth / this.aspectRatio;
          const screenMarginY = (window.innerHeight - screenHeight) / 2;
          newY = (newY - screenMarginY) / screenHeight * this.viewport.height;
          newX = newX / window.innerWidth * this.viewport.width;
        } else {
          const screenWidth = window.innerHeight * this.aspectRatio;
          const screenMarginX = (window.innerWidth - screenWidth) / 2;
          newX = (newX - screenMarginX) / screenWidth * this.viewport.width;
          newY = newY / window.innerHeight * this.viewport.height;
        }
      }
      newX = newX / this.viewport.width * this.resolution.width;
      newY = newY / this.viewport.height * this.resolution.height;
      return new Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur screen space, and translates it to normal html page space. For example,
     * this is where html elements might live if you want to position them relative to Excalibur.
     *
     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
     * bottom right corner (resolutionX, resolutionY)
     * @param point
     */
    screenToPageCoordinates(point2) {
      let newX = point2.x;
      let newY = point2.y;
      newX = newX / this.resolution.width * this.viewport.width;
      newY = newY / this.resolution.height * this.viewport.height;
      if (this._isFullScreen) {
        if (window.innerWidth / this.aspectRatio < window.innerHeight) {
          const screenHeight = window.innerWidth / this.aspectRatio;
          const screenMarginY = (window.innerHeight - screenHeight) / 2;
          newY = newY / this.viewport.height * screenHeight + screenMarginY;
          newX = newX / this.viewport.width * window.innerWidth;
        } else {
          const screenWidth = window.innerHeight * this.aspectRatio;
          const screenMarginX = (window.innerWidth - screenWidth) / 2;
          newX = newX / this.viewport.width * screenWidth + screenMarginX;
          newY = newY / this.viewport.height * window.innerHeight;
        }
      }
      if (!this._isFullScreen) {
        newX += getPosition(this._canvas).x;
        newY += getPosition(this._canvas).y;
      }
      return new Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur screen space, and translates it to Excalibur world space.
     *
     * World space is where [[Entity|entities]] in Excalibur live by default [[CoordPlane.World]]
     * and extends infinitely out relative from the [[Camera]].
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point2) {
      if (this._camera) {
        return this._camera.inverse.multiply(point2);
      }
      return point2.sub(vec(this.resolution.width / 2, this.resolution.height / 2));
    }
    /**
     * Takes a coordinate in Excalibur world space, and translates it to Excalibur screen space.
     *
     * Screen space is where [[ScreenElement|screen elements]] and [[Entity|entities]] with [[CoordPlane.Screen]] live.
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point2) {
      if (this._camera) {
        return this._camera.transform.multiply(point2);
      }
      return point2.add(vec(this.resolution.width / 2, this.resolution.height / 2));
    }
    pageToWorldCoordinates(point2) {
      const screen = this.pageToScreenCoordinates(point2);
      return this.screenToWorldCoordinates(screen);
    }
    worldToPageCoordinates(point2) {
      const screen = this.worldToScreenCoordinates(point2);
      return this.screenToPageCoordinates(screen);
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     *
     * World bounds are in world coordinates, useful for culling objects offscreen
     */
    getWorldBounds() {
      const bounds = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Half).scale(vec(1 / this._camera.zoom, 1 / this._camera.zoom)).rotate(this._camera.rotation).translate(this._camera.pos);
      return bounds;
    }
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
      return this.canvas.width;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
      return this.canvas.width / 2;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
      return this.canvas.height;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
      return this.canvas.height / 2;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
      if (this._camera) {
        return this.resolution.width / this._camera.zoom;
      }
      return this.resolution.width;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
      return this.drawWidth / 2;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
      if (this._camera) {
        return this.resolution.height / this._camera.zoom;
      }
      return this.resolution.height;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
      return this.drawHeight / 2;
    }
    /**
     * Returns screen center coordinates including zoom and device pixel ratio.
     */
    get center() {
      return vec(this.halfDrawWidth, this.halfDrawHeight);
    }
    /**
     * Returns the content area in screen space where it is safe to place content
     */
    get contentArea() {
      return this._contentArea;
    }
    _computeFit() {
      document.body.style.margin = "0px";
      document.body.style.overflow = "hidden";
      const aspect = this.aspectRatio;
      let adjustedWidth = 0;
      let adjustedHeight = 0;
      if (window.innerWidth / aspect < window.innerHeight) {
        adjustedWidth = window.innerWidth;
        adjustedHeight = window.innerWidth / aspect;
      } else {
        adjustedWidth = window.innerHeight * aspect;
        adjustedHeight = window.innerHeight;
      }
      this.viewport = {
        width: adjustedWidth,
        height: adjustedHeight
      };
      this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);
    }
    _computeFitScreenAndFill() {
      document.body.style.margin = "0px";
      document.body.style.overflow = "hidden";
      const vw2 = window.innerWidth;
      const vh2 = window.innerHeight;
      this._computeFitAndFill(vw2, vh2);
    }
    _computeFitContainerAndFill() {
      document.body.style.margin = "0px";
      document.body.style.overflow = "hidden";
      const parent = this.canvas.parentElement;
      const vw2 = parent.clientWidth;
      const vh2 = parent.clientHeight;
      this._computeFitAndFill(vw2, vh2);
    }
    _computeFitAndFill(vw2, vh2) {
      this.viewport = {
        width: vw2,
        height: vh2
      };
      if (vw2 / vh2 <= this._contentResolution.width / this._contentResolution.height) {
        this.resolution = {
          width: vw2 * this._contentResolution.width / vw2,
          height: vw2 * this._contentResolution.width / vw2 * vh2 / vw2
        };
        const clip = (this.resolution.height - this._contentResolution.height) / 2;
        this._contentArea = new BoundingBox({
          top: clip,
          left: 0,
          right: this._contentResolution.width,
          bottom: this.resolution.height - clip
        });
      } else {
        this.resolution = {
          width: vh2 * this._contentResolution.height / vh2 * vw2 / vh2,
          height: vh2 * this._contentResolution.height / vh2
        };
        const clip = (this.resolution.width - this._contentResolution.width) / 2;
        this._contentArea = new BoundingBox({
          top: 0,
          left: clip,
          right: this.resolution.width - clip,
          bottom: this._contentResolution.height
        });
      }
    }
    _computeFitScreenAndZoom() {
      document.body.style.margin = "0px";
      document.body.style.overflow = "hidden";
      this.canvas.style.position = "absolute";
      const vw2 = window.innerWidth;
      const vh2 = window.innerHeight;
      this._computeFitAndZoom(vw2, vh2);
    }
    _computeFitContainerAndZoom() {
      document.body.style.margin = "0px";
      document.body.style.overflow = "hidden";
      this.canvas.style.position = "absolute";
      const parent = this.canvas.parentElement;
      parent.style.position = "relative";
      parent.style.overflow = "hidden";
      const vw2 = parent.clientWidth;
      const vh2 = parent.clientHeight;
      this._computeFitAndZoom(vw2, vh2);
    }
    _computeFitAndZoom(vw2, vh2) {
      const aspect = this.aspectRatio;
      let adjustedWidth = 0;
      let adjustedHeight = 0;
      if (vw2 / aspect < vh2) {
        adjustedWidth = vw2;
        adjustedHeight = vw2 / aspect;
      } else {
        adjustedWidth = vh2 * aspect;
        adjustedHeight = vh2;
      }
      const scaleX = vw2 / adjustedWidth;
      const scaleY = vh2 / adjustedHeight;
      const maxScaleFactor = Math.max(scaleX, scaleY);
      const zoomedWidth = adjustedWidth * maxScaleFactor;
      const zoomedHeight = adjustedHeight * maxScaleFactor;
      if (zoomedWidth > vw2) {
        this.canvas.style.left = -(zoomedWidth - vw2) / 2 + "px";
      } else {
        this.canvas.style.left = "";
      }
      if (zoomedHeight > vh2) {
        this.canvas.style.top = -(zoomedHeight - vh2) / 2 + "px";
      } else {
        this.canvas.style.top = "";
      }
      this.viewport = {
        width: zoomedWidth,
        height: zoomedHeight
      };
      const bounds = BoundingBox.fromDimension(this.viewport.width, this.viewport.height, Vector.Zero);
      if (this.viewport.width > vw2) {
        const clip = (this.viewport.width - vw2) / this.viewport.width * this.resolution.width;
        bounds.top = 0;
        bounds.left = clip / 2;
        bounds.right = this.resolution.width - clip / 2;
        bounds.bottom = this.resolution.height;
      }
      if (this.viewport.height > vh2) {
        const clip = (this.viewport.height - vh2) / this.viewport.height * this.resolution.height;
        bounds.top = clip / 2;
        bounds.left = 0;
        bounds.bottom = this.resolution.height - clip / 2;
        bounds.right = this.resolution.width;
      }
      this._contentArea = bounds;
    }
    _computeFitContainer() {
      const aspect = this.aspectRatio;
      let adjustedWidth = 0;
      let adjustedHeight = 0;
      const parent = this.canvas.parentElement;
      if (parent.clientWidth / aspect < parent.clientHeight) {
        adjustedWidth = parent.clientWidth;
        adjustedHeight = parent.clientWidth / aspect;
      } else {
        adjustedWidth = parent.clientHeight * aspect;
        adjustedHeight = parent.clientHeight;
      }
      this.viewport = {
        width: adjustedWidth,
        height: adjustedHeight
      };
      this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);
    }
    _applyDisplayMode() {
      this._setResolutionAndViewportByDisplayMode(this.parent);
      if (this.parent instanceof Window) {
        this._browser.window.on("resize", this._resizeHandler);
      } else {
        this._resizeObserver = new ResizeObserver(() => {
          this._resizeHandler();
        });
        this._resizeObserver.observe(this.parent);
      }
      this.parent.addEventListener("resize", this._resizeHandler);
    }
    /**
     * Sets the resolution and viewport based on the selected display mode.
     */
    _setResolutionAndViewportByDisplayMode(parent) {
      if (this.displayMode === DisplayMode.FillContainer) {
        this.resolution = {
          width: parent.clientWidth,
          height: parent.clientHeight
        };
        this.viewport = this.resolution;
      }
      if (this.displayMode === DisplayMode.FillScreen) {
        document.body.style.margin = "0px";
        document.body.style.overflow = "hidden";
        this.resolution = {
          width: parent.innerWidth,
          height: parent.innerHeight
        };
        this.viewport = this.resolution;
      }
      this._contentArea = BoundingBox.fromDimension(this.resolution.width, this.resolution.height, Vector.Zero);
      if (this.displayMode === DisplayMode.FitScreen) {
        this._computeFit();
      }
      if (this.displayMode === DisplayMode.FitContainer) {
        this._computeFitContainer();
      }
      if (this.displayMode === DisplayMode.FitScreenAndFill) {
        this._computeFitScreenAndFill();
      }
      if (this.displayMode === DisplayMode.FitContainerAndFill) {
        this._computeFitContainerAndFill();
      }
      if (this.displayMode === DisplayMode.FitScreenAndZoom) {
        this._computeFitScreenAndZoom();
      }
      if (this.displayMode === DisplayMode.FitContainerAndZoom) {
        this._computeFitContainerAndZoom();
      }
    }
  }
  class AudioContextFactory {
    static create() {
      if (!this._INSTANCE) {
        if (window.AudioContext || window.webkitAudioContext) {
          this._INSTANCE = new AudioContext();
        }
      }
      return this._INSTANCE;
    }
  }
  AudioContextFactory._INSTANCE = null;
  function isLegacyWebAudioSource(source) {
    return !!source.playbackState;
  }
  class WebAudio {
    /**
     * Play an empty sound to unlock Safari WebAudio context. Call this function
     * right after a user interaction event.
     * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     */
    static unlock() {
      const promise = new Promise((resolve, reject) => {
        if (WebAudio._UNLOCKED || !AudioContextFactory.create()) {
          return resolve(true);
        }
        const unlockTimeoutTimer = setTimeout(() => {
          Logger2.getInstance().warn("Excalibur was unable to unlock the audio context, audio probably will not play in this browser.");
          resolve(false);
        }, 200);
        const audioContext = AudioContextFactory.create();
        audioContext.resume().then(() => {
          const buffer = audioContext.createBuffer(1, 1, 22050);
          const source = audioContext.createBufferSource();
          let ended = false;
          source.buffer = buffer;
          source.connect(audioContext.destination);
          source.onended = () => ended = true;
          source.start(0);
          setTimeout(() => {
            if (isLegacyWebAudioSource(source)) {
              if (source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE) {
                WebAudio._UNLOCKED = true;
              }
            } else {
              if (audioContext.currentTime > 0 || ended) {
                WebAudio._UNLOCKED = true;
              }
            }
          }, 0);
          clearTimeout(unlockTimeoutTimer);
          resolve(true);
        }, () => {
          reject();
        });
      });
      return promise;
    }
    static isUnlocked() {
      return this._UNLOCKED;
    }
  }
  WebAudio._UNLOCKED = false;
  function line(ctx, color2 = Color.Red, x1, y1, x2, y2, thickness = 1, cap = "butt") {
    ctx.save();
    ctx.beginPath();
    ctx.lineWidth = thickness;
    ctx.lineCap = cap;
    ctx.strokeStyle = color2.toString();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function point(ctx, color2 = Color.Red, point2) {
    ctx.beginPath();
    ctx.strokeStyle = color2.toString();
    ctx.arc(point2.x, point2.y, 5, 0, Math.PI * 2);
    ctx.closePath();
    ctx.stroke();
  }
  function vector(ctx, color2, origin, vector2, scale2 = 1) {
    const c2 = color2 ? color2.toString() : "blue";
    const v2 = vector2.scale(scale2);
    ctx.beginPath();
    ctx.strokeStyle = c2;
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(origin.x + v2.x, origin.y + v2.y);
    ctx.closePath();
    ctx.stroke();
  }
  function roundRect(ctx, x2, y2, width, height, radius = 5, stroke = Color.White, fill = null) {
    let br;
    if (typeof radius === "number") {
      br = { tl: radius, tr: radius, br: radius, bl: radius };
    } else {
      const defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
      for (const prop in defaultRadius) {
        if (defaultRadius.hasOwnProperty(prop)) {
          const side = prop;
          br[side] = radius[side] || defaultRadius[side];
        }
      }
    }
    ctx.beginPath();
    ctx.moveTo(x2 + br.tl, y2);
    ctx.lineTo(x2 + width - br.tr, y2);
    ctx.quadraticCurveTo(x2 + width, y2, x2 + width, y2 + br.tr);
    ctx.lineTo(x2 + width, y2 + height - br.br);
    ctx.quadraticCurveTo(x2 + width, y2 + height, x2 + width - br.br, y2 + height);
    ctx.lineTo(x2 + br.bl, y2 + height);
    ctx.quadraticCurveTo(x2, y2 + height, x2, y2 + height - br.bl);
    ctx.lineTo(x2, y2 + br.tl);
    ctx.quadraticCurveTo(x2, y2, x2 + br.tl, y2);
    ctx.closePath();
    if (fill) {
      ctx.fillStyle = fill.toString();
      ctx.fill();
    }
    if (stroke) {
      ctx.strokeStyle = stroke.toString();
      ctx.stroke();
    }
  }
  function circle(ctx, x2, y2, radius, stroke = Color.White, fill = null) {
    ctx.beginPath();
    ctx.arc(x2, y2, radius, 0, Math.PI * 2);
    ctx.closePath();
    if (fill) {
      ctx.fillStyle = fill.toString();
      ctx.fill();
    }
    if (stroke) {
      ctx.strokeStyle = stroke.toString();
      ctx.stroke();
    }
  }
  const Loader_logo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAB2CAYAAABxhGI9AAAACXBIWXMAAAsSAAALEgHS3X78AAAKnUlEQVR42u3dP2wjSx0H8N8hJIonIRmJjsq0SBR+BQ1dcqKhe0lD77SvSwpKkJKGPulpktfRIMUdEqKIqV57rpAokM4dbSiyq7ONPTP7x39ifz7SFbnEnp3xer47O7uzH15fXwMA6OYHmgAABCoACFQAEKgAgEAFAIEKAAIVAAQqACBQAUCgAoBABQCBCgAIVAAQqAAgUAFAoAIAAhUABCoACFQAEKgAgECFLbmOiNeFf2PbAyz68Pr6qhUgbRwR92v+/zwiJrYHMEKFMmcN///UtgcQqFBk1PD/97U9Qx8VCFSgu4EmAIEKAAIVAAQqACBQ4Z25jojP8eX+0WtNAgIVaOY+Im5j+eKh24h41jQgUIEyZ7F5NaPU7wCBCiwYd/w9cOB+qAlgJ3KLLow0EV198803RWvJfvfddx+0lhEqHKu5JgAjVCBvlhmFzjQRXUekHz9+TP79y8uLRjNChXfvoePvAYEKxNtj1e42/O5JoIJABcrdRMRVLM+X3kTEpaaB988cKuzWg9EobTWdMx0Oly8uN4dqhAoARqgnaN3arHfqu7OyH8ItKLVB/P+CEfMTHyGPY3npx1m8zWGDEeoBfUk/xdti57dr/r1Wv2+6EPow3tZ5rRdS72s1neuF97xvWd+XTH0/V+UMttDWqbI/r2nrxfp+jv2uSjSO7S+OXy/A/3lN+9xX5T5HxEUPZZ0tfB71+w57eJ/HFu+z+jkv1u92YX9fbI/HhX3JA9rp5MPr66tWaG9UfUGbrHIzi7cLUyYFf/tpTady03EEeL8mUJ6i7MKYNvWNqr4Pe2jradXO60LrvPAz2PQ5RPX684ah8dxD+2zantnCgVipSVV+m/tgB9W2DDq2Sx/vM95wcHhZhWVJm8yrv58cSgfTdc70+++/X/r522+/tUKSEepBqo+om4ZLPerMjUwuNnQCtx1GWJtee1FwdD5uWd86xLs8UaVt2aNEO1/saZ/Z5rYMW4zq6v34rGV9Bg3q2eZ9SkeNm9qwyUh30OPIHYFKx5FG03C7znSOqYBq+qW/zpQ3anH037TNHluG6f0WPsPhHvab4QFty7ogOeuxDYcNy2/zu2214WNYWxmBurNO8bGn97pNBOO8xy/9uCorZZ4I2r4C7aJgO7ZV9iE49Dm6NvOWx+pWE9CUq3zbdTp9doz38TbXtzqH9RT5CyWe422OaZoZGeZCabrhPQY9HjwsjpTvCg4YtlE2+Ta/j2bzn8fqrDqgm+6yUHOmAvWUjAtGhbNYvsBknDnqH1Qhc7VmxHgeb/NbudA5j/UXlYwif2p6luhAc9teu1npiHKnDs8if6tCm7JLX3NKpgttXe9ruc9mHMd7a83iwdxF5vt8tutARaCeklRnNK9C8WnNF7geJQ4T4XG3JhSnVdilQrG+yOnrlVHfsEGYzhNBn7Lu6tS7+HJafJQ4EMiNlNqWXZ9WPvVgnVYHG5M1ByDXkT6leX2EgTqJtyt45yv7S2qO3sEZjZhDLXeR+YKdJ0Zdk8QocvH9N732KrNtq+FZ/zzIHABcJrYpd+Xv14lOd5ap76SgrduW/VTQ1qcQpqnbgu4ifZvUMNpd9XuoZmvCtPaQ2Y/BCHVLgbrJTeRPDdVf6pfMKDU2fOkHmVFFfXr3MsouLsnNvV5kRoe5+s431PeuoKPqWnaurY/ZPBEeqwceN4l96iwO6H7Mjq4y7VGPVNe10VaZMzVCPVWpI/Z6FZbcv5fMqGCU+dLfFGzj58jP8+bCdJCo7yzKTwdOF0bu9Ug7V4c+yz7FJfYeGoysUss0HssIdVZwYLDujMqlESoCdTtGsZtbHnJBeNdDSJSs0jTKdMJN1HNX54Wv7bvsU9NkVJVa13dX+/wuArV0X/l5RHyo/lnfF4G6p6DrS0kHdtXhy35TGErDPYZUn2WfWqDOo/lVqdMD2O/hKJhD7S/odukymq9s02QN4EEPR/zbaOumZc+r15zK1Zqznl9jsfiemTM1QmV3HUuTkedlg9HIQzRbUD93dfC+2tpj2fIHEH2+RqCCQH13gZq7hWXTNpVu19OB1fc9nQ0AKOKUb5lU0P1kDyOneoWk0lOZ9cIP0x7qu8+2BhCoR2wYu1+e7DmaXzBSsu5vaX1ne2zrpmUPTmxf7PM1Dm4y/vC7ny7Nif7+z/9ZmtM0Z3panPLtPmra9f16bcK0Dpbnwk43Vd/RHtu6zfNQTy1QBy3aqG2g9nVmxml+BOoJyT3NpWmn9xhfFnu4bvDa+44BXhqqfdf3uUF9+yz77AT31Yue2mjecYQ62NLfgkA9ghHqLNEhNem4H1c6vdyDxhf/bpz5m4coW/c39wi6VH2bPtHlcaV9cvXts+zxCe6rTeqc2ndL7uGd93QwM9bFcAzMoZZ7SgTBbWx+asui61h/iq1+RmjqdbnQXQ3T1DNQ63V/U9ucqm/pMzPb1rePsk/1iTOjgvatR4W3Lc8ULB78pELyrnAfeTcj1NU509/86mfJ33/8+Mf00a05UyPUEw7UVCeWG/WNEiExyHRMt5ltW30izUPk18ytt7lNfc8i//DvtvXto+ySA5BjljsLUF8lPkqMPEtW1JomDsiGBZ9Byb4NAvUITSN9GuwsIj6t6UTOqk7jJREkmzqli8xIs96udSO20sX0H1vW92IL9e1a9rgqVyf91gbPsTy9UD9n9lOkT8k+RfkFR5PMNqxOcdSf32PBvg3vilO+zdxE+okx9Wm0ph36XYsRZCpMF993GOk5qvqB3Dct6jvssb67KvuUNJ3frw92bhr8/STSF0JdRPMLpUCgnsgo9S76PZ246ZFk1wWvK5m3vVoYvW1Sz7nN91jfXbQ1ZQc7TW6HeaoOalypG/8/p/rP1aNAc6ZHzSnfdqPUPhdy2PQw6Nz9gSVhuhiqueUHR3uu7y7K3rdDX4u46ZrPbUa0IFBZ0seKQ3XQTRt2vm3W/a2DbNKys++rvm3ep6+y1x2UdP3bWU9lzra47U1GmlctX/sQ23t+aOlByLTh/4NAPaCRxtcdO5HLSJ/6vNtCwGx67VPmPbvWd1q9frKHtp4kAqRJ2HR9j762JfX3bZ//elPtj13PPDx1+D5tqk/Xi6NO8SHz7MmH19dXrdBNfVFP6T2PT1UHNit87/t4m5+aRH+nQBdvqyhZDKJLfZs8h7XPsqdV2ZOV+tanKB8aln0dyxdAXbV4j4gvt4oMOrbP6vbU73NW7TMlbdTnPrWpfqXfh9HKZ9vke7KuTeZRNtXRSe6+1FV//ce/ln5eXfsXgcqXzr6+9261M3moOoa7E6nvTZTfy7iNsmfb7kjfgXGsvxe0vihsEts9HTquPpt1q1vtahu2TqAiUAEEKj0zhwoARqgAu/OnX/442WH+9xc/Wvr58re/Tr7f41/+ZsRqhAoACFQAEKgAcHjMoQJskJsz/eqrr5Z+vvr7v5fmQFevAl5lztQIFQAQqAAgUAHgIJlDBdhgdQ41N2eKESoAIFABQKACwFEwhwoARqgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAEKgAgUAFAoAKAQAUAgQoACFQAEKgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAQqAAgUAFAoAKAQAUAlvwPcFDns1DsH4sAAAAASUVORK5CYII=";
  var Loader_0 = __webpack_require__(1388);
  class Raster extends Graphic {
    constructor(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      super(options);
      this.filtering = null;
      this.lineCap = "butt";
      this.quality = 1;
      this._dirty = true;
      this._smoothing = false;
      this._color = watch(Color.Black, () => this.flagDirty());
      this._lineWidth = 1;
      this._lineDash = [];
      this._padding = 0;
      if (options) {
        this.quality = (_a = options.quality) !== null && _a !== void 0 ? _a : this.quality;
        this.color = (_b = options.color) !== null && _b !== void 0 ? _b : Color.Black;
        this.strokeColor = options === null || options === void 0 ? void 0 : options.strokeColor;
        this.smoothing = (_c = options.smoothing) !== null && _c !== void 0 ? _c : this.smoothing;
        this.lineWidth = (_d = options.lineWidth) !== null && _d !== void 0 ? _d : this.lineWidth;
        this.lineDash = (_e = options.lineDash) !== null && _e !== void 0 ? _e : this.lineDash;
        this.lineCap = (_f = options.lineCap) !== null && _f !== void 0 ? _f : this.lineCap;
        this.padding = (_g = options.padding) !== null && _g !== void 0 ? _g : this.padding;
        this.filtering = (_h = options.filtering) !== null && _h !== void 0 ? _h : this.filtering;
      }
      this._bitmap = document.createElement("canvas");
      const bitmapWidth = (_j = options === null || options === void 0 ? void 0 : options.width) !== null && _j !== void 0 ? _j : this._bitmap.width;
      const bitmapHeight = (_k = options === null || options === void 0 ? void 0 : options.height) !== null && _k !== void 0 ? _k : this._bitmap.height;
      this.width = bitmapWidth;
      this.height = bitmapHeight;
      const maybeCtx = this._bitmap.getContext("2d");
      if (!maybeCtx) {
        throw new Error("Browser does not support 2d canvas drawing, cannot create Raster graphic");
      } else {
        this._ctx = maybeCtx;
      }
    }
    cloneRasterOptions() {
      return {
        color: this.color ? this.color.clone() : null,
        strokeColor: this.strokeColor ? this.strokeColor.clone() : null,
        smoothing: this.smoothing,
        lineWidth: this.lineWidth,
        lineDash: this.lineDash,
        lineCap: this.lineCap,
        quality: this.quality,
        padding: this.padding
      };
    }
    /**
     * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized
     */
    get dirty() {
      return this._dirty;
    }
    /**
     * Flags the graphic as dirty, meaning it must be re-rasterized before draw.
     * This should be called any time the graphics state changes such that it affects the outputted drawing
     */
    flagDirty() {
      this._dirty = true;
    }
    /**
     * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding`s or `quality` set will be factored into the width
     */
    get width() {
      return Math.abs(this._getTotalWidth() * this.scale.x);
    }
    set width(value) {
      value /= Math.abs(this.scale.x);
      this._bitmap.width = value;
      this._originalWidth = value;
      this.flagDirty();
    }
    /**
     * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding` or `quality` set will be factored into the height
     */
    get height() {
      return Math.abs(this._getTotalHeight() * this.scale.y);
    }
    set height(value) {
      value /= Math.abs(this.scale.y);
      this._bitmap.height = value;
      this._originalHeight = value;
      this.flagDirty();
    }
    _getTotalWidth() {
      var _a;
      return (((_a = this._originalWidth) !== null && _a !== void 0 ? _a : this._bitmap.width) + this.padding * 2) * 1;
    }
    _getTotalHeight() {
      var _a;
      return (((_a = this._originalHeight) !== null && _a !== void 0 ? _a : this._bitmap.height) + this.padding * 2) * 1;
    }
    /**
     * Returns the local bounds of the Raster including the padding
     */
    get localBounds() {
      return BoundingBox.fromDimension(this._getTotalWidth() * this.scale.x, this._getTotalHeight() * this.scale.y, Vector.Zero);
    }
    /**
     * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     */
    get smoothing() {
      return this._smoothing;
    }
    set smoothing(value) {
      this._smoothing = value;
      this.flagDirty();
    }
    /**
     * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get color() {
      return this._color;
    }
    set color(value) {
      this.flagDirty();
      this._color = watch(value, () => this.flagDirty());
    }
    /**
     * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get strokeColor() {
      return this._strokeColor;
    }
    set strokeColor(value) {
      this.flagDirty();
      this._strokeColor = watch(value, () => this.flagDirty());
    }
    /**
     * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get lineWidth() {
      return this._lineWidth;
    }
    set lineWidth(value) {
      this._lineWidth = value;
      this.flagDirty();
    }
    get lineDash() {
      return this._lineDash;
    }
    set lineDash(value) {
      this._lineDash = value;
      this.flagDirty();
    }
    get padding() {
      return this._padding;
    }
    set padding(value) {
      this._padding = value;
      this.flagDirty();
    }
    /**
     * Rasterize the graphic to a bitmap making it usable as in excalibur. Rasterize is called automatically if
     * the graphic is [[Raster.dirty]] on the next [[Graphic.draw]] call
     */
    rasterize() {
      this._dirty = false;
      this._ctx.clearRect(0, 0, this._getTotalWidth(), this._getTotalHeight());
      this._ctx.save();
      this._applyRasterProperties(this._ctx);
      this.execute(this._ctx);
      this._ctx.restore();
    }
    _applyRasterProperties(ctx) {
      var _a, _b, _c;
      this._bitmap.width = this._getTotalWidth() * this.quality;
      this._bitmap.height = this._getTotalHeight() * this.quality;
      this._bitmap.setAttribute("filtering", this.filtering);
      this._bitmap.setAttribute("forceUpload", "true");
      ctx.scale(this.quality, this.quality);
      ctx.translate(this.padding, this.padding);
      ctx.imageSmoothingEnabled = this.smoothing;
      ctx.lineWidth = this.lineWidth;
      ctx.setLineDash((_a = this.lineDash) !== null && _a !== void 0 ? _a : ctx.getLineDash());
      ctx.lineCap = this.lineCap;
      ctx.strokeStyle = (_b = this.strokeColor) === null || _b === void 0 ? void 0 : _b.toString();
      ctx.fillStyle = (_c = this.color) === null || _c === void 0 ? void 0 : _c.toString();
    }
    _drawImage(ex, x2, y2) {
      if (this._dirty) {
        this.rasterize();
      }
      ex.scale(1 / this.quality, 1 / this.quality);
      ex.drawImage(this._bitmap, x2, y2);
    }
  }
  class Canvas extends Raster {
    /**
     * Return the 2D graphics context of this canvas
     */
    get ctx() {
      return this._ctx;
    }
    constructor(_options) {
      super(_options);
      this._options = _options;
    }
    clone() {
      return new Canvas({
        ...this._options,
        ...this.cloneGraphicOptions(),
        ...this.cloneRasterOptions()
      });
    }
    execute(ctx) {
      var _a, _b;
      if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.draw) {
        (_b = this._options) === null || _b === void 0 ? void 0 : _b.draw(ctx);
      }
      if (!this._options.cache) {
        this.flagDirty();
      }
    }
  }
  class ExResponse {
  }
  ExResponse.type = {
    any: "",
    blob: "blob",
    json: "json",
    text: "text",
    document: "document",
    arraybuffer: "arraybuffer"
  };
  class StateMachine {
    constructor() {
      this.states = /* @__PURE__ */ new Map();
    }
    get currentState() {
      return this._currentState;
    }
    set currentState(state) {
      this._currentState = state;
    }
    static create(machineDescription, data) {
      const machine = new StateMachine();
      machine.data = data;
      for (const stateName in machineDescription.states) {
        machine.states.set(stateName, {
          name: stateName,
          ...machineDescription.states[stateName]
        });
      }
      for (const state of machine.states.values()) {
        for (const transitionState of state.transitions) {
          if (transitionState === "*") {
            continue;
          }
          if (!machine.states.has(transitionState)) {
            throw Error(`Invalid state machine, state [${state.name}] has a transition to another state that doesn't exist [${transitionState}]`);
          }
        }
      }
      machine.currentState = machine.startState = machine.states.get(machineDescription.start);
      return machine;
    }
    in(state) {
      return this.currentState.name === state;
    }
    go(stateName, eventData) {
      var _a, _b;
      if (this.currentState.transitions.includes(stateName) || this.currentState.transitions.includes("*")) {
        const potentialNewState = this.states.get(stateName);
        if (this.currentState.onExit) {
          const canExit = (_a = this.currentState) === null || _a === void 0 ? void 0 : _a.onExit({ to: potentialNewState.name, data: this.data });
          if (canExit === false) {
            return false;
          }
        }
        if (potentialNewState === null || potentialNewState === void 0 ? void 0 : potentialNewState.onEnter) {
          const canEnter = potentialNewState === null || potentialNewState === void 0 ? void 0 : potentialNewState.onEnter({ from: this.currentState.name, eventData, data: this.data });
          if (canEnter === false) {
            return false;
          }
        }
        this.currentState = potentialNewState;
        if ((_b = this.currentState) === null || _b === void 0 ? void 0 : _b.onState) {
          this.currentState.onState();
        }
        return true;
      }
      return false;
    }
    update(elapsedMs) {
      if (this.currentState.onUpdate) {
        this.currentState.onUpdate(this.data, elapsedMs);
      }
    }
    save(saveKey) {
      localStorage.setItem(saveKey, JSON.stringify({
        currentState: this.currentState.name,
        data: this.data
      }));
    }
    restore(saveKey) {
      const state = JSON.parse(localStorage.getItem(saveKey));
      this.currentState = this.states.get(state.currentState);
      this.data = state.data;
    }
  }
  class WebAudioInstance {
    _createNewBufferSource() {
      this._instance = this._audioContext.createBufferSource();
      this._instance.buffer = this._src;
      this._instance.loop = this.loop;
      this._instance.playbackRate.value = this._playbackRate;
      this._instance.connect(this._volumeNode);
      this._volumeNode.connect(this._audioContext.destination);
    }
    _handleEnd() {
      if (!this.loop) {
        this._instance.onended = () => {
          this._playingResolve(true);
        };
      }
    }
    set loop(value) {
      this._loop = value;
      if (this._instance) {
        this._instance.loop = value;
        if (!this.loop) {
          this._instance.onended = () => {
            this._playingResolve(true);
          };
        }
      }
    }
    get loop() {
      return this._loop;
    }
    set volume(value) {
      value = clamp2(value, 0, 1);
      this._volume = value;
      if (this._stateMachine.in("PLAYING") && this._volumeNode.gain.setTargetAtTime) {
        this._volumeNode.gain.setTargetAtTime(value, this._audioContext.currentTime, 0.1);
      } else {
        this._volumeNode.gain.value = value;
      }
    }
    get volume() {
      return this._volume;
    }
    /**
     * Returns the set duration to play, otherwise returns the total duration if unset
     */
    get duration() {
      var _a;
      return (_a = this._duration) !== null && _a !== void 0 ? _a : this.getTotalPlaybackDuration();
    }
    /**
     * Set the duration that this audio should play.
     *
     * Note: if you seek to a specific point the duration will start from that point, for example
     *
     * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.
     */
    set duration(duration) {
      this._duration = duration;
    }
    constructor(_src) {
      this._src = _src;
      this._audioContext = AudioContextFactory.create();
      this._volumeNode = this._audioContext.createGain();
      this._playingPromise = new Promise((resolve) => {
        this._playingResolve = resolve;
      });
      this._stateMachine = StateMachine.create({
        start: "STOPPED",
        states: {
          PLAYING: {
            onEnter: ({ data }) => {
              this._createNewBufferSource();
              this._handleEnd();
              if (this.loop) {
                this._instance.start(0, data.pausedAt * this._playbackRate);
              } else {
                this._instance.start(0, data.pausedAt * this._playbackRate, this.duration);
              }
              data.startedAt = this._audioContext.currentTime - data.pausedAt;
              data.pausedAt = 0;
            },
            onState: () => this._playStarted(),
            onExit: ({ to }) => {
              if (to === "STOPPED") {
                this._playingResolve(true);
              }
              this._instance.onended = null;
              this._instance.disconnect();
              this._instance.stop(0);
              this._instance = null;
            },
            transitions: ["STOPPED", "PAUSED", "SEEK"]
          },
          SEEK: {
            onEnter: ({ eventData: position, data }) => {
              data.pausedAt = (position !== null && position !== void 0 ? position : 0) / this._playbackRate;
              data.startedAt = 0;
            },
            transitions: ["*"]
          },
          STOPPED: {
            onEnter: ({ data }) => {
              data.pausedAt = 0;
              data.startedAt = 0;
              this._playingResolve(true);
            },
            transitions: ["PLAYING", "PAUSED", "SEEK"]
          },
          PAUSED: {
            onEnter: ({ data }) => {
              data.pausedAt = this._audioContext.currentTime - data.startedAt;
            },
            transitions: ["PLAYING", "STOPPED", "SEEK"]
          }
        }
      }, {
        startedAt: 0,
        pausedAt: 0
      });
      this._volume = 1;
      this._loop = false;
      this._playStarted = () => {
      };
      this._playbackRate = 1;
      this._createNewBufferSource();
    }
    isPlaying() {
      return this._stateMachine.in("PLAYING");
    }
    isPaused() {
      return this._stateMachine.in("PAUSED") || this._stateMachine.in("SEEK");
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    play(playStarted = () => {
    }) {
      this._playStarted = playStarted;
      this._stateMachine.go("PLAYING");
      return this._playingPromise;
    }
    pause() {
      this._stateMachine.go("PAUSED");
    }
    stop() {
      this._stateMachine.go("STOPPED");
    }
    seek(position) {
      this._stateMachine.go("PAUSED");
      this._stateMachine.go("SEEK", position);
    }
    getTotalPlaybackDuration() {
      return this._src.duration;
    }
    getPlaybackPosition() {
      const { pausedAt, startedAt } = this._stateMachine.data;
      if (pausedAt) {
        return pausedAt * this._playbackRate;
      }
      if (startedAt) {
        return (this._audioContext.currentTime - startedAt) * this._playbackRate;
      }
      return 0;
    }
    set playbackRate(playbackRate) {
      this._instance.playbackRate.value = this._playbackRate = playbackRate;
    }
    get playbackRate() {
      return this._instance.playbackRate.value;
    }
  }
  class MediaEvent extends GameEvent {
    /**
     * Media event cannot bubble
     */
    set bubbles(_value) {
    }
    /**
     * Media event cannot bubble
     */
    get bubbles() {
      return false;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    get _path() {
      return null;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    set _path(_val) {
    }
    constructor(target, _name = "MediaEvent") {
      super();
      this.target = target;
      this._name = _name;
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
    }
    /**
     * Action, that calls when event happens
     */
    action() {
    }
    /**
     * Propagate event further through event path
     */
    propagate() {
    }
    layPath(_actor) {
    }
  }
  class NativeSoundEvent extends MediaEvent {
    constructor(target, track) {
      super(target, "NativeSoundEvent");
      this.track = track;
    }
  }
  class NativeSoundProcessedEvent extends MediaEvent {
    constructor(target, _processedData) {
      super(target, "NativeSoundProcessedEvent");
      this._processedData = _processedData;
      this.data = this._processedData;
    }
  }
  function canPlayFile(file) {
    try {
      const a2 = new Audio();
      const filetype = /.*\.([A-Za-z0-9]+)(?:(?:\?|\#).*)*$/;
      const type = file.match(filetype)[1];
      if (a2.canPlayType("audio/" + type)) {
        return true;
      } else {
        return false;
      }
    } catch (e2) {
      Logger2.getInstance().warn("Cannot determine audio support, assuming no support for the Audio Tag", e2);
      return false;
    }
  }
  const SoundEvents = {
    VolumeChange: "volumechange",
    Processed: "processed",
    Pause: "pause",
    Stop: "stop",
    PlaybackEnd: "playbackend",
    Resume: "resume",
    PlaybackStart: "playbackstart"
  };
  class Sound {
    /**
     * Indicates whether the clip should loop when complete
     * @param value  Set the looping flag
     */
    set loop(value) {
      this._loop = value;
      for (const track of this._tracks) {
        track.loop = this._loop;
      }
      this.logger.debug("Set loop for all instances of sound", this.path, "to", this._loop);
    }
    get loop() {
      return this._loop;
    }
    set volume(value) {
      this._volume = value;
      for (const track of this._tracks) {
        track.volume = this._volume;
      }
      this.events.emit("volumechange", new NativeSoundEvent(this));
      this.logger.debug("Set loop for all instances of sound", this.path, "to", this._volume);
    }
    get volume() {
      return this._volume;
    }
    /**
     * Get the duration that this audio should play. If unset the total natural playback duration will be used.
     */
    get duration() {
      return this._duration;
    }
    /**
     * Set the duration that this audio should play. If unset the total natural playback duration will be used.
     *
     * Note: if you seek to a specific point the duration will start from that point, for example
     *
     * If you have a 10 second clip, seek to 5 seconds, then set the duration to 2, it will play the clip from 5-7 seconds.
     */
    set duration(duration) {
      this._duration = duration;
    }
    /**
     * Return array of Current AudioInstances playing or being paused
     */
    get instances() {
      return this._tracks;
    }
    get path() {
      return this._resource.path;
    }
    set path(val) {
      this._resource.path = val;
    }
    /**
     * Should excalibur add a cache busting querystring? By default false.
     * Must be set before loading
     */
    get bustCache() {
      return this._resource.bustCache;
    }
    set bustCache(val) {
      this._resource.bustCache = val;
    }
    /**
     * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
     */
    constructor(...paths) {
      this.events = new EventEmitter2();
      this.logger = Logger2.getInstance();
      this._loop = false;
      this._volume = 1;
      this._isStopped = false;
      this._tracks = [];
      this._wasPlayingOnHidden = false;
      this._playbackRate = 1;
      this._audioContext = AudioContextFactory.create();
      this._resource = new Resource("", ExResponse.type.arraybuffer);
      for (const path of paths) {
        if (canPlayFile(path)) {
          this.path = path;
          break;
        }
      }
      if (!this.path) {
        this.logger.warn("This browser does not support any of the audio files specified:", paths.join(", "));
        this.logger.warn("Attempting to use", paths[0]);
        this.path = paths[0];
      }
    }
    isLoaded() {
      return !!this.data;
    }
    async load() {
      var _a, _b;
      if (this.data) {
        return this.data;
      }
      const arraybuffer = await this._resource.load();
      const audiobuffer = await this.decodeAudio(arraybuffer.slice(0));
      this._duration = (_b = (_a = this._duration) !== null && _a !== void 0 ? _a : audiobuffer === null || audiobuffer === void 0 ? void 0 : audiobuffer.duration) !== null && _b !== void 0 ? _b : void 0;
      this.events.emit("processed", new NativeSoundProcessedEvent(this, audiobuffer));
      return this.data = audiobuffer;
    }
    async decodeAudio(data) {
      try {
        return await this._audioContext.decodeAudioData(data.slice(0));
      } catch (e2) {
        this.logger.error("Unable to decode  this browser may not fully support this format, or the file may be corrupt, if this is an mp3 try removing id3 tags and album art from the file.");
        return await Promise.reject();
      }
    }
    wireEngine(engine) {
      if (engine) {
        this._engine = engine;
        this._engine.on("hidden", () => {
          if (engine.pauseAudioWhenHidden && this.isPlaying()) {
            this._wasPlayingOnHidden = true;
            this.pause();
          }
        });
        this._engine.on("visible", () => {
          if (engine.pauseAudioWhenHidden && this._wasPlayingOnHidden) {
            this.play();
            this._wasPlayingOnHidden = false;
          }
        });
        this._engine.on("start", () => {
          this._isStopped = false;
        });
        this._engine.on("stop", () => {
          this.stop();
          this._isStopped = true;
        });
      }
    }
    /**
     * Returns how many instances of the sound are currently playing
     */
    instanceCount() {
      return this._tracks.length;
    }
    /**
     * Whether or not the sound is playing right now
     */
    isPlaying() {
      return this._tracks.some((t2) => t2.isPlaying());
    }
    isPaused() {
      return this._tracks.some((t2) => t2.isPaused());
    }
    /**
     * Play the sound, returns a promise that resolves when the sound is done playing
     * An optional volume argument can be passed in to play the sound. Max volume is 1.0
     */
    play(volume) {
      if (!this.isLoaded()) {
        this.logger.warn("Cannot start playing. Resource", this.path, "is not loaded yet");
        return Promise.resolve(true);
      }
      if (this._isStopped) {
        this.logger.warn("Cannot start playing. Engine is in a stopped state.");
        return Promise.resolve(false);
      }
      this.volume = volume || this.volume;
      if (this.isPaused()) {
        return this._resumePlayback();
      } else {
        return this._startPlayback();
      }
    }
    /**
     * Stop the sound, and do not rewind
     */
    pause() {
      if (!this.isPlaying()) {
        return;
      }
      for (const track of this._tracks) {
        track.pause();
      }
      this.events.emit("pause", new NativeSoundEvent(this));
      this.logger.debug("Paused all instances of sound", this.path);
    }
    /**
     * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.
     */
    stop() {
      for (const track of this._tracks) {
        track.stop();
      }
      this.events.emit("stop", new NativeSoundEvent(this));
      this._tracks.length = 0;
      this.logger.debug("Stopped all instances of sound", this.path);
    }
    get playbackRate() {
      return this._playbackRate;
    }
    set playbackRate(playbackRate) {
      this._playbackRate = playbackRate;
      this._tracks.forEach((t2) => {
        t2.playbackRate = this._playbackRate;
      });
    }
    seek(position, trackId = 0) {
      if (this._tracks.length === 0) {
        this._getTrackInstance(this.data);
      }
      this._tracks[trackId].seek(position);
    }
    getTotalPlaybackDuration() {
      return this.data.duration;
    }
    /**
     * Return the current playback time of the playing track in seconds from the start.
     *
     * Optionally specify the track to query if multiple are playing at once.
     * @param trackId
     */
    getPlaybackPosition(trackId = 0) {
      if (this._tracks.length) {
        return this._tracks[trackId].getPlaybackPosition();
      }
      return 0;
    }
    /**
     * Get Id of provided AudioInstance in current trackList
     * @param track [[Audio]] which Id is to be given
     */
    getTrackId(track) {
      return this._tracks.indexOf(track);
    }
    async _resumePlayback() {
      if (this.isPaused) {
        const resumed = [];
        for (const track of this._tracks) {
          resumed.push(track.play().then(() => {
            this.events.emit("playbackend", new NativeSoundEvent(this, track));
            this._tracks.splice(this.getTrackId(track), 1);
            return true;
          }));
        }
        this.events.emit("resume", new NativeSoundEvent(this));
        this.logger.debug("Resuming paused instances for sound", this.path, this._tracks);
        await Promise.all(resumed);
      }
      return true;
    }
    /**
     * Starts playback, returns a promise that resolves when playback is complete
     */
    async _startPlayback() {
      const track = await this._getTrackInstance(this.data);
      const complete = await track.play(() => {
        this.events.emit("playbackstart", new NativeSoundEvent(this, track));
        this.logger.debug("Playing new instance for sound", this.path);
      });
      this.events.emit("playbackend", new NativeSoundEvent(this, track));
      this._tracks.splice(this.getTrackId(track), 1);
      return complete;
    }
    _getTrackInstance(data) {
      const newTrack = new WebAudioInstance(data);
      newTrack.loop = this.loop;
      newTrack.volume = this.volume;
      newTrack.duration = this.duration;
      newTrack.playbackRate = this._playbackRate;
      this._tracks.push(newTrack);
      return newTrack;
    }
    emit(eventName, event) {
      this.events.emit(eventName, event);
    }
    on(eventName, handler) {
      return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
      return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
      this.events.off(eventName, handler);
    }
  }
  const LoaderEvents = {
    // Add event types here
  };
  class Loader {
    get _image() {
      if (!this._imageElement) {
        this._imageElement = new Image();
        this._imageElement.src = this.logo;
      }
      return this._imageElement;
    }
    get playButtonRootElement() {
      return this._playButtonRootElement;
    }
    get playButtonElement() {
      return this._playButtonElement;
    }
    get _playButton() {
      const existingRoot = document.getElementById("excalibur-play-root");
      if (existingRoot) {
        this._playButtonRootElement = existingRoot;
      }
      if (!this._playButtonRootElement) {
        this._playButtonRootElement = document.createElement("div");
        this._playButtonRootElement.id = "excalibur-play-root";
        this._playButtonRootElement.style.position = "absolute";
        document.body.appendChild(this._playButtonRootElement);
      }
      if (!this._styleBlock) {
        this._styleBlock = document.createElement("style");
        this._styleBlock.textContent = this._playButtonStyles;
        document.head.appendChild(this._styleBlock);
      }
      if (!this._playButtonElement) {
        this._playButtonElement = this.startButtonFactory();
        this._playButtonRootElement.appendChild(this._playButtonElement);
      }
      return this._playButtonElement;
    }
    /**
     * @param loadables  Optionally provide the list of resources you want to load at constructor time
     */
    constructor(loadables) {
      this.events = new EventEmitter2();
      this.canvas = new Canvas({
        filtering: ImageFiltering.Blended,
        smoothing: true,
        cache: true,
        draw: this.draw.bind(this)
      });
      this._resourceList = [];
      this._index = 0;
      this._playButtonShown = false;
      this._resourceCount = 0;
      this._numLoaded = 0;
      this._progressCounts = {};
      this._totalCounts = {};
      this.logo = Loader_logo;
      this.logoWidth = 468;
      this.logoHeight = 118;
      this.loadingBarColor = Color.White;
      this.backgroundColor = "#176BAA";
      this.suppressPlayButton = false;
      this._playButtonStyles = Loader_0.Z.toString();
      this.playButtonText = "Play game";
      this.startButtonFactory = () => {
        let buttonElement = document.getElementById("excalibur-play");
        if (!buttonElement) {
          buttonElement = document.createElement("button");
        }
        buttonElement.id = "excalibur-play";
        buttonElement.textContent = this.playButtonText;
        buttonElement.style.display = "none";
        return buttonElement;
      };
      this._loadingFuture = new Future();
      if (loadables) {
        this.addResources(loadables);
      }
    }
    wireEngine(engine) {
      this._engine = engine;
      this.canvas.width = this._engine.canvas.width;
      this.canvas.height = this._engine.canvas.height;
    }
    /**
     * Add a resource to the loader to load
     * @param loadable  Resource to add
     */
    addResource(loadable) {
      const key = this._index++;
      this._resourceList.push(loadable);
      this._progressCounts[key] = 0;
      this._totalCounts[key] = 1;
      this._resourceCount++;
    }
    /**
     * Add a list of resources to the loader to load
     * @param loadables  The list of resources to load
     */
    addResources(loadables) {
      let i2 = 0;
      const len = loadables.length;
      for (i2; i2 < len; i2++) {
        this.addResource(loadables[i2]);
      }
    }
    /**
     * Returns true if the loader has completely loaded all resources
     */
    isLoaded() {
      return this._numLoaded === this._resourceCount;
    }
    /**
     * Shows the play button and returns a promise that resolves when clicked
     */
    async showPlayButton() {
      var _a, _b;
      if (this.suppressPlayButton) {
        this.hidePlayButton();
        await delay2(500, (_a = this._engine) === null || _a === void 0 ? void 0 : _a.clock);
      } else {
        const resizeHandler = () => {
          this._positionPlayButton();
        };
        if ((_b = this._engine) === null || _b === void 0 ? void 0 : _b.browser) {
          this._engine.browser.window.on("resize", resizeHandler);
        }
        this._playButtonShown = true;
        this._playButton.style.display = "block";
        document.body.addEventListener("keyup", (evt) => {
          if (evt.key === "Enter") {
            this._playButton.click();
          }
        });
        this._positionPlayButton();
        const playButtonClicked = new Promise((resolve) => {
          const startButtonHandler = (e2) => {
            var _a2;
            e2.stopPropagation();
            this.hidePlayButton();
            if ((_a2 = this._engine) === null || _a2 === void 0 ? void 0 : _a2.browser) {
              this._engine.browser.window.off("resize", resizeHandler);
            }
            resolve();
          };
          this._playButton.addEventListener("click", startButtonHandler);
          this._playButton.addEventListener("touchend", startButtonHandler);
          this._playButton.addEventListener("pointerup", startButtonHandler);
        });
        return await playButtonClicked;
      }
    }
    hidePlayButton() {
      this._playButtonShown = false;
      this._playButton.style.display = "none";
    }
    /**
     * Clean up generated elements for the loader
     */
    dispose() {
      if (this._playButtonRootElement.parentElement) {
        this._playButtonRootElement.removeChild(this._playButtonElement);
        document.body.removeChild(this._playButtonRootElement);
        document.head.removeChild(this._styleBlock);
        this._playButtonRootElement = null;
        this._playButtonElement = null;
        this._styleBlock = null;
      }
    }
    update(_engine, _delta) {
    }
    areResourcesLoaded() {
      return this._loadingFuture.promise;
    }
    /**
     * Begin loading all of the supplied resources, returning a promise
     * that resolves when loading of all is complete AND the user has clicked the "Play button"
     */
    async load() {
      var _a, _b;
      await ((_a = this._image) === null || _a === void 0 ? void 0 : _a.decode());
      this.canvas.flagDirty();
      await Promise.all(this._resourceList.map(async (r2) => {
        await r2.load().finally(() => {
          this._numLoaded++;
          this.canvas.flagDirty();
        });
      }));
      for (const resource of this._resourceList) {
        if (resource instanceof Sound) {
          resource.wireEngine(this._engine);
        }
      }
      this._loadingFuture.resolve();
      await delay2(200, (_b = this._engine) === null || _b === void 0 ? void 0 : _b.clock);
      this.canvas.flagDirty();
      await this.showPlayButton();
      await WebAudio.unlock();
      return this.data = this._resourceList;
    }
    markResourceComplete() {
      this._numLoaded++;
    }
    /**
     * Returns the progress of the loader as a number between [0, 1] inclusive.
     */
    get progress() {
      return this._resourceCount > 0 ? clamp2(this._numLoaded, 0, this._resourceCount) / this._resourceCount : 1;
    }
    _positionPlayButton() {
      if (this._engine) {
        const screenHeight = this._engine.screen.viewport.height;
        const screenWidth = this._engine.screen.viewport.width;
        if (this._playButtonRootElement) {
          const left = this._engine.canvas.offsetLeft;
          const top = this._engine.canvas.offsetTop;
          const buttonWidth = this._playButton.clientWidth;
          const buttonHeight = this._playButton.clientHeight;
          if (this.playButtonPosition) {
            this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`;
            this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`;
          } else {
            this._playButtonRootElement.style.left = `${left + screenWidth / 2 - buttonWidth / 2}px`;
            this._playButtonRootElement.style.top = `${top + screenHeight / 2 - buttonHeight / 2 + 100}px`;
          }
        }
      }
    }
    /**
     * Loader draw function. Draws the default Excalibur loading screen.
     * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties
     * to customize the drawing, or just override entire method.
     */
    draw(ctx) {
      const canvasHeight = this._engine.canvasHeight / this._engine.pixelRatio;
      const canvasWidth = this._engine.canvasWidth / this._engine.pixelRatio;
      this._positionPlayButton();
      ctx.fillStyle = this.backgroundColor;
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      let logoY = canvasHeight / 2;
      const width = Math.min(this.logoWidth, canvasWidth * 0.75);
      let logoX = canvasWidth / 2 - width / 2;
      if (this.logoPosition) {
        logoX = this.logoPosition.x;
        logoY = this.logoPosition.y;
      }
      const imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth));
      const oldAntialias = this._engine.getAntialiasing();
      this._engine.setAntialiasing(true);
      if (!this.logoPosition) {
        ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY - imageHeight - 20, width, imageHeight);
      } else {
        ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY, width, imageHeight);
      }
      if (!this.suppressPlayButton && this._playButtonShown) {
        this._engine.setAntialiasing(oldAntialias);
        return;
      }
      let loadingX = logoX;
      let loadingY = logoY;
      if (this.loadingBarPosition) {
        loadingX = this.loadingBarPosition.x;
        loadingY = this.loadingBarPosition.y;
      }
      ctx.lineWidth = 2;
      roundRect(ctx, loadingX, loadingY, width, 20, 10, this.loadingBarColor);
      const progress2 = width * this.progress;
      const margin = 5;
      const progressWidth = progress2 - margin * 2;
      const height = 20 - margin * 2;
      roundRect(ctx, loadingX + margin, loadingY + margin, progressWidth > 10 ? progressWidth : 10, height, 5, null, this.loadingBarColor);
      this._engine.setAntialiasing(oldAntialias);
    }
    emit(eventName, event) {
      this.events.emit(eventName, event);
    }
    on(eventName, handler) {
      return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
      return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
      this.events.off(eventName, handler);
    }
  }
  const REPORTED_FEATURES = {
    webgl: "WebGL",
    webaudio: "WebAudio",
    gamepadapi: "Gamepad API"
  };
  class Detector {
    constructor() {
      this._features = null;
      this.failedTests = [];
      this._criticalTests = {
        // Test canvas/2d context support
        canvasSupport: function() {
          const elem = document.createElement("canvas");
          return !!(elem.getContext && elem.getContext("2d"));
        },
        // Test array buffer support ex uses for downloading binary data
        arrayBufferSupport: function() {
          const xhr = new XMLHttpRequest();
          xhr.open("GET", "/");
          try {
            xhr.responseType = "arraybuffer";
          } catch (e2) {
            return false;
          }
          return xhr.responseType === "arraybuffer";
        },
        // Test data urls ex uses for sprites
        dataUrlSupport: function() {
          const canvas = document.createElement("canvas");
          return canvas.toDataURL("image/png").indexOf("data:image/png") === 0;
        },
        // Test object url support for loading
        objectUrlSupport: function() {
          return "URL" in window && "revokeObjectURL" in URL && "createObjectURL" in URL;
        },
        // RGBA support for colors
        rgbaSupport: function() {
          const style = document.createElement("a").style;
          style.cssText = "background-color:rgba(150,255,150,.5)";
          return ("" + style.backgroundColor).indexOf("rgba") > -1;
        }
      };
      this._warningTest = {
        webAudioSupport: function() {
          return !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext || window.oAudioContext);
        },
        webglSupport: function() {
          const elem = document.createElement("canvas");
          return !!(elem.getContext && elem.getContext("webgl"));
        }
      };
      this._features = this._loadBrowserFeatures();
    }
    /**
     * Returns a map of currently supported browser features. This method
     * treats the features as a singleton and will only calculate feature
     * support if it has not previously been done.
     */
    getBrowserFeatures() {
      if (this._features === null) {
        this._features = this._loadBrowserFeatures();
      }
      return this._features;
    }
    /**
     * Report on non-critical browser support for debugging purposes.
     * Use native browser console colors for visibility.
     */
    logBrowserFeatures() {
      let msg = "%cSUPPORTED BROWSER FEATURES\n==========================%c\n";
      const args = ["font-weight: bold; color: navy", "font-weight: normal; color: inherit"];
      const supported = this.getBrowserFeatures();
      for (const feature of Object.keys(REPORTED_FEATURES)) {
        if (supported[feature]) {
          msg += "(%c%c)";
          args.push("font-weight: bold; color: green");
          args.push("font-weight: normal; color: inherit");
        } else {
          msg += "(%c%c)";
          args.push("font-weight: bold; color: red");
          args.push("font-weight: normal; color: inherit");
        }
        msg += " " + REPORTED_FEATURES[feature] + "\n";
      }
      args.unshift(msg);
      console.log.apply(console, args);
    }
    /**
     * Executes several IIFE's to get a constant reference to supported
     * features within the current execution context.
     */
    _loadBrowserFeatures() {
      return {
        // IIFE to check canvas support
        canvas: (() => {
          return this._criticalTests.canvasSupport();
        })(),
        // IIFE to check arraybuffer support
        arraybuffer: (() => {
          return this._criticalTests.arrayBufferSupport();
        })(),
        // IIFE to check dataurl support
        dataurl: (() => {
          return this._criticalTests.dataUrlSupport();
        })(),
        // IIFE to check objecturl support
        objecturl: (() => {
          return this._criticalTests.objectUrlSupport();
        })(),
        // IIFE to check rgba support
        rgba: (() => {
          return this._criticalTests.rgbaSupport();
        })(),
        // IIFE to check webaudio support
        webaudio: (() => {
          return this._warningTest.webAudioSupport();
        })(),
        // IIFE to check webgl support
        webgl: (() => {
          return this._warningTest.webglSupport();
        })(),
        // IIFE to check gamepadapi support
        gamepadapi: (() => {
          return !!navigator.getGamepads;
        })()
      };
    }
    test() {
      let failedCritical = false;
      for (const test2 in this._criticalTests) {
        if (!this._criticalTests[test2].call(this)) {
          this.failedTests.push(test2);
          Logger2.getInstance().error("Critical browser feature missing, Excalibur requires:", test2);
          failedCritical = true;
        }
      }
      if (failedCritical) {
        return false;
      }
      for (const warning2 in this._warningTest) {
        if (!this._warningTest[warning2]()) {
          Logger2.getInstance().warn("Warning browser feature missing, Excalibur will have reduced performance:", warning2);
        }
      }
      return true;
    }
  }
  var CollisionType;
  (function(CollisionType2) {
    CollisionType2["PreventCollision"] = "PreventCollision";
    CollisionType2["Passive"] = "Passive";
    CollisionType2["Active"] = "Active";
    CollisionType2["Fixed"] = "Fixed";
  })(CollisionType || (CollisionType = {}));
  const maxMessages = 5;
  const obsoleteMessage = {};
  const resetObsoleteCounter = () => {
    for (const message in obsoleteMessage) {
      obsoleteMessage[message] = 0;
    }
  };
  const logMessage = (message, options) => {
    const suppressObsoleteMessages = Flags.isEnabled("suppress-obsolete-message");
    if (obsoleteMessage[message] < maxMessages && !suppressObsoleteMessages) {
      Logger2.getInstance().warn(message);
      if (console.trace && options.showStackTrace) {
        console.trace();
      }
    }
    obsoleteMessage[message]++;
  };
  function obsolete(options) {
    options = {
      message: "This feature will be removed in future versions of Excalibur.",
      alternateMethod: null,
      showStackTrace: false,
      ...options
    };
    return function(target, property, descriptor) {
      if (descriptor && !(typeof descriptor.value === "function" || typeof descriptor.get === "function" || typeof descriptor.set === "function")) {
        throw new SyntaxError("Only classes/functions/getters/setters can be marked as obsolete");
      }
      const methodSignature = `${target.name || ""}${target.name && property ? "." : ""}${property ? property : ""}`;
      const message = `${methodSignature} is marked obsolete: ${options.message}` + (options.alternateMethod ? ` Use ${options.alternateMethod} instead` : "");
      if (!obsoleteMessage[message]) {
        obsoleteMessage[message] = 0;
      }
      const method = descriptor ? { ...descriptor } : target;
      if (!descriptor) {
        class DecoratedClass extends method {
          constructor(...args) {
            logMessage(message, options);
            super(...args);
          }
        }
        return DecoratedClass;
      }
      if (descriptor && descriptor.value) {
        method.value = function() {
          logMessage(message, options);
          return descriptor.value.apply(this, arguments);
        };
        return method;
      }
      if (descriptor && descriptor.get) {
        method.get = function() {
          logMessage(message, options);
          return descriptor.get.apply(this, arguments);
        };
      }
      if (descriptor && descriptor.set) {
        method.set = function() {
          logMessage(message, options);
          return descriptor.set.apply(this, arguments);
        };
      }
      return method;
    };
  }
  var __decorate = function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d2 = decorators[i2])
          r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  var CollisionResolutionStrategy;
  (function(CollisionResolutionStrategy2) {
    CollisionResolutionStrategy2["Arcade"] = "arcade";
    CollisionResolutionStrategy2["Realistic"] = "realistic";
  })(CollisionResolutionStrategy || (CollisionResolutionStrategy = {}));
  var BroadphaseStrategy;
  (function(BroadphaseStrategy2) {
    BroadphaseStrategy2[BroadphaseStrategy2["DynamicAABBTree"] = 0] = "DynamicAABBTree";
  })(BroadphaseStrategy || (BroadphaseStrategy = {}));
  var Integrator;
  (function(Integrator2) {
    Integrator2[Integrator2["Euler"] = 0] = "Euler";
  })(Integrator || (Integrator = {}));
  class Physics {
    static get gravity() {
      return Physics.acc;
    }
    static set gravity(v2) {
      Physics.acc = v2;
    }
    /**
     * Configures Excalibur to use "arcade" physics. Arcade physics which performs simple axis aligned arcade style physics.
     */
    static useArcadePhysics() {
      Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;
    }
    /**
     * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated
     * simulated physical interactions.
     */
    static useRealisticPhysics() {
      Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Realistic;
    }
    static get dynamicTreeVelocityMultiplyer() {
      return Physics.dynamicTreeVelocityMultiplier;
    }
    static set dynamicTreeVelocityMultiplyer(value) {
      Physics.dynamicTreeVelocityMultiplier = value;
    }
  }
  Physics.acc = new Vector(0, 0);
  Physics.enabled = true;
  Physics.broadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;
  Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;
  Physics.defaultMass = 10;
  Physics.integrator = Integrator.Euler;
  Physics.dynamicTreeVelocityMultiplier = 2;
  Physics.boundsPadding = 5;
  Physics.positionIterations = 3;
  Physics.velocityIterations = 8;
  Physics.slop = 1;
  Physics.steeringFactor = 0.2;
  Physics.warmStart = true;
  Physics.bodiesCanSleepByDefault = false;
  Physics.surfaceEpsilon = 0.1;
  Physics.sleepEpsilon = 0.07;
  Physics.wakeThreshold = Physics.sleepEpsilon * 3;
  Physics.sleepBias = 0.9;
  Physics.checkForFastBodies = true;
  Physics.disableMinimumSpeedForFastBody = false;
  __decorate([
    obsolete({
      message: "Alias for incorrect spelling used in older versions, will be removed in v0.25.0",
      alternateMethod: "dynamicTreeVelocityMultiplier"
    })
  ], Physics, "dynamicTreeVelocityMultiplyer", null);
  var CoordPlane;
  (function(CoordPlane2) {
    CoordPlane2["World"] = "world";
    CoordPlane2["Screen"] = "screen";
  })(CoordPlane || (CoordPlane = {}));
  class VectorView extends Vector {
    constructor(options) {
      super(0, 0);
      this._getX = options.getX;
      this._getY = options.getY;
      this._setX = options.setX;
      this._setY = options.setY;
    }
    get x() {
      return this._x = this._getX();
    }
    set x(val) {
      this._setX(val);
      this._x = val;
    }
    get y() {
      return this._y = this._getY();
    }
    set y(val) {
      this._setY(val);
      this._y = val;
    }
  }
  class WatchVector extends Vector {
    constructor(original, change) {
      super(original.x, original.y);
      this.original = original;
      this.change = change;
    }
    get x() {
      return this._x = this.original.x;
    }
    set x(newX) {
      this.change(newX, this._y);
      this._x = this.original.x = newX;
    }
    get y() {
      return this._y = this.original.y;
    }
    set y(newY) {
      this.change(this._x, newY);
      this._y = this.original.y = newY;
    }
  }
  class Transform {
    constructor() {
      this._parent = null;
      this._children = [];
      this._pos = vec(0, 0);
      this._rotation = 0;
      this._scale = vec(1, 1);
      this._isDirty = false;
      this._isInverseDirty = false;
      this._matrix = AffineMatrix.identity();
      this._inverse = AffineMatrix.identity();
    }
    get parent() {
      return this._parent;
    }
    set parent(transform) {
      if (this._parent) {
        const index = this._parent._children.indexOf(this);
        if (index > -1) {
          this._parent._children.splice(index, 1);
        }
      }
      this._parent = transform;
      if (this._parent) {
        this._parent._children.push(this);
      }
      this.flagDirty();
    }
    get children() {
      return this._children;
    }
    set pos(v2) {
      if (!v2.equals(this._pos)) {
        this._pos.x = v2.x;
        this._pos.y = v2.y;
        this.flagDirty();
      }
    }
    get pos() {
      return new WatchVector(this._pos, (x2, y2) => {
        if (x2 !== this._pos.x || y2 !== this._pos.y) {
          this.flagDirty();
        }
      });
    }
    set globalPos(v2) {
      let localPos = v2.clone();
      if (this.parent) {
        localPos = this.parent.inverse.multiply(v2);
      }
      if (!localPos.equals(this._pos)) {
        this._pos = localPos;
        this.flagDirty();
      }
    }
    get globalPos() {
      return new VectorView({
        getX: () => this.matrix.data[4],
        getY: () => this.matrix.data[5],
        setX: (x2) => {
          if (this.parent) {
            const { x: newX } = this.parent.inverse.multiply(vec(x2, this.pos.y));
            this.pos.x = newX;
          } else {
            this.pos.x = x2;
          }
          if (x2 !== this.matrix.data[4]) {
            this.flagDirty();
          }
        },
        setY: (y2) => {
          if (this.parent) {
            const { y: newY } = this.parent.inverse.multiply(vec(this.pos.x, y2));
            this.pos.y = newY;
          } else {
            this.pos.y = y2;
          }
          if (y2 !== this.matrix.data[5]) {
            this.flagDirty();
          }
        }
      });
    }
    set rotation(rotation) {
      const canonRotation = canonicalizeAngle(rotation);
      if (canonRotation !== this._rotation) {
        this.flagDirty();
      }
      this._rotation = canonRotation;
    }
    get rotation() {
      return this._rotation;
    }
    set globalRotation(rotation) {
      let inverseRotation = 0;
      if (this.parent) {
        inverseRotation = this.parent.globalRotation;
      }
      const canonRotation = canonicalizeAngle(rotation + inverseRotation);
      if (canonRotation !== this._rotation) {
        this.flagDirty();
      }
      this._rotation = canonRotation;
    }
    get globalRotation() {
      if (this.parent) {
        return this.matrix.getRotation();
      }
      return this.rotation;
    }
    set scale(v2) {
      if (!v2.equals(this._scale)) {
        this._scale.x = v2.x;
        this._scale.y = v2.y;
        this.flagDirty();
      }
    }
    get scale() {
      return new WatchVector(this._scale, (x2, y2) => {
        if (x2 !== this._scale.x || y2 !== this._scale.y) {
          this.flagDirty();
        }
      });
    }
    set globalScale(v2) {
      let inverseScale = vec(1, 1);
      if (this.parent) {
        inverseScale = this.parent.globalScale;
      }
      this.scale = v2.scale(vec(1 / inverseScale.x, 1 / inverseScale.y));
    }
    get globalScale() {
      return new VectorView({
        getX: () => this.parent ? this.matrix.getScaleX() : this.scale.x,
        getY: () => this.parent ? this.matrix.getScaleY() : this.scale.y,
        setX: (x2) => {
          if (this.parent) {
            const globalScaleX = this.parent.globalScale.x;
            this.scale.x = x2 / globalScaleX;
          } else {
            this.scale.x = x2;
          }
        },
        setY: (y2) => {
          if (this.parent) {
            const globalScaleY = this.parent.globalScale.y;
            this.scale.y = y2 / globalScaleY;
          } else {
            this.scale.y = y2;
          }
        }
      });
    }
    get matrix() {
      if (this._isDirty) {
        if (this.parent === null) {
          this._matrix = this._calculateMatrix();
        } else {
          this._matrix = this.parent.matrix.multiply(this._calculateMatrix());
        }
        this._isDirty = false;
      }
      return this._matrix;
    }
    get inverse() {
      if (this._isInverseDirty) {
        this._inverse = this.matrix.inverse();
        this._isInverseDirty = false;
      }
      return this._inverse;
    }
    _calculateMatrix() {
      const matrix = AffineMatrix.identity().translate(this.pos.x, this.pos.y).rotate(this.rotation).scale(this.scale.x, this.scale.y);
      return matrix;
    }
    flagDirty() {
      this._isDirty = true;
      this._isInverseDirty = true;
      for (let i2 = 0; i2 < this._children.length; i2++) {
        this._children[i2].flagDirty();
      }
    }
    apply(point2) {
      return this.matrix.multiply(point2);
    }
    applyInverse(point2) {
      return this.inverse.multiply(point2);
    }
    setTransform(pos, rotation, scale2) {
      this._pos.x = pos.x;
      this._pos.y = pos.y;
      this._rotation = canonicalizeAngle(rotation);
      this._scale.x = scale2.x;
      this._scale.y = scale2.y;
      this.flagDirty();
    }
    clone(dest) {
      const target = dest !== null && dest !== void 0 ? dest : new Transform();
      this._pos.clone(target._pos);
      target._rotation = this._rotation;
      this._scale.clone(target._scale);
      target.flagDirty();
      return target;
    }
  }
  function hasClone(x2) {
    return !!(x2 === null || x2 === void 0 ? void 0 : x2.clone);
  }
  class Component {
    constructor() {
      this.owner = null;
    }
    /**
     * Clones any properties on this component, if that property value has a `clone()` method it will be called
     */
    clone() {
      const newComponent = new this.constructor();
      for (const prop in this) {
        if (this.hasOwnProperty(prop)) {
          const val = this[prop];
          if (hasClone(val) && prop !== "owner" && prop !== "clone") {
            newComponent[prop] = val.clone();
          } else {
            newComponent[prop] = val;
          }
        }
      }
      return newComponent;
    }
  }
  class TagComponent extends Component {
    constructor(type, value) {
      super();
      this.type = type;
      this.value = value;
    }
  }
  class Observable {
    constructor() {
      this.observers = [];
      this.subscriptions = [];
    }
    /**
     * Register an observer to listen to this observable
     * @param observer
     */
    register(observer) {
      this.observers.push(observer);
    }
    /**
     * Register a callback to listen to this observable
     * @param func
     */
    subscribe(func) {
      this.subscriptions.push(func);
    }
    /**
     * Remove an observer from the observable
     * @param observer
     */
    unregister(observer) {
      const i2 = this.observers.indexOf(observer);
      if (i2 !== -1) {
        this.observers.splice(i2, 1);
      }
    }
    /**
     * Remove a callback that is listening to this observable
     * @param func
     */
    unsubscribe(func) {
      const i2 = this.subscriptions.indexOf(func);
      if (i2 !== -1) {
        this.subscriptions.splice(i2, 1);
      }
    }
    /**
     * Broadcasts a message to all observers and callbacks
     * @param message
     */
    notifyAll(message) {
      const observersLength = this.observers.length;
      for (let i2 = 0; i2 < observersLength; i2++) {
        this.observers[i2].notify(message);
      }
      const subscriptionsLength = this.subscriptions.length;
      for (let i2 = 0; i2 < subscriptionsLength; i2++) {
        this.subscriptions[i2](message);
      }
    }
    /**
     * Removes all observers and callbacks
     */
    clear() {
      this.observers.length = 0;
      this.subscriptions.length = 0;
    }
  }
  class TransformComponent extends Component {
    constructor() {
      super(...arguments);
      this.type = "ex.transform";
      this._transform = new Transform();
      this._addChildTransform = (child) => {
        const childTxComponent = child.get(TransformComponent);
        if (childTxComponent) {
          childTxComponent._transform.parent = this._transform;
        }
      };
      this.zIndexChanged$ = new Observable();
      this._z = 0;
      this.coordPlane = CoordPlane.World;
    }
    get() {
      return this._transform;
    }
    onAdd(owner) {
      for (const child of owner.children) {
        this._addChildTransform(child);
      }
      owner.childrenAdded$.subscribe((child) => this._addChildTransform(child));
      owner.childrenRemoved$.subscribe((child) => {
        const childTxComponent = child.get(TransformComponent);
        if (childTxComponent) {
          childTxComponent._transform.parent = null;
        }
      });
    }
    onRemove(_previousOwner) {
      this._transform.parent = null;
    }
    /**
     * The z-index ordering of the entity, a higher values are drawn on top of lower values.
     * For example z=99 would be drawn on top of z=0.
     */
    get z() {
      return this._z;
    }
    set z(val) {
      const oldz = this._z;
      this._z = val;
      if (oldz !== val) {
        this.zIndexChanged$.notifyAll(val);
      }
    }
    get pos() {
      return this._transform.pos;
    }
    set pos(v2) {
      this._transform.pos = v2;
    }
    get globalPos() {
      return this._transform.globalPos;
    }
    set globalPos(v2) {
      this._transform.globalPos = v2;
    }
    get rotation() {
      return this._transform.rotation;
    }
    set rotation(rotation) {
      this._transform.rotation = rotation;
    }
    get globalRotation() {
      return this._transform.globalRotation;
    }
    set globalRotation(rotation) {
      this._transform.globalRotation = rotation;
    }
    get scale() {
      return this._transform.scale;
    }
    set scale(v2) {
      this._transform.scale = v2;
    }
    get globalScale() {
      return this._transform.globalScale;
    }
    set globalScale(v2) {
      this._transform.globalScale = v2;
    }
    applyInverse(v2) {
      return this._transform.applyInverse(v2);
    }
    apply(v2) {
      return this._transform.apply(v2);
    }
    clone() {
      const component = new TransformComponent();
      component._transform = this._transform.clone();
      component._z = this._z;
      return component;
    }
  }
  class MotionComponent extends Component {
    constructor() {
      super(...arguments);
      this.type = "ex.motion";
      this.vel = Vector.Zero;
      this.acc = Vector.Zero;
      this.scaleFactor = Vector.Zero;
      this.angularVelocity = 0;
      this.torque = 0;
      this.inertia = 1;
    }
  }
  class CollisionGroup {
    /**
     * STOP!!** It is preferred that [[CollisionGroupManager.create]] is used to create collision groups
     *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.
     * @param name Name of the collision group
     * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`
     * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`
     */
    constructor(name, category, mask) {
      this._name = name;
      this._category = category;
      this._mask = mask;
    }
    /**
     * Get the name of the collision group
     */
    get name() {
      return this._name;
    }
    /**
     * Get the category of the collision group, a 32 bit number which should be a unique power of 2
     */
    get category() {
      return this._category;
    }
    /**
     * Get the mask for this collision group
     */
    get mask() {
      return this._mask;
    }
    /**
     * Evaluates whether 2 collision groups can collide
     * @param other  CollisionGroup
     */
    canCollide(other) {
      return (this.category & other.mask) !== 0 && (other.category & this.mask) !== 0;
    }
    /**
     * Inverts the collision group. For example, if before the group specified "players",
     * inverting would specify all groups except players
     * @returns CollisionGroup
     */
    invert() {
      return new CollisionGroup("~(" + this.name + ")", ~this.category, ~this.mask);
    }
    /**
     * Combine collision groups with each other. The new group includes all of the previous groups.
     *
     * @param collisionGroups
     */
    static combine(collisionGroups) {
      const combinedName = collisionGroups.map((c2) => c2.name).join("+");
      const combinedCategory = collisionGroups.reduce((current, g2) => g2.category | current, 0);
      const combinedMask = ~combinedCategory;
      return new CollisionGroup(combinedName, combinedCategory, combinedMask);
    }
    /**
     * Creates a collision group that collides with the listed groups
     * @param collisionGroups
     */
    static collidesWith(collisionGroups) {
      return CollisionGroup.combine(collisionGroups).invert();
    }
  }
  CollisionGroup.All = new CollisionGroup("Collide with all groups", -1, -1);
  class Pair {
    constructor(colliderA, colliderB) {
      this.colliderA = colliderA;
      this.colliderB = colliderB;
      this.id = null;
      this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
    }
    /**
     * Returns whether a it is allowed for 2 colliders in a Pair to collide
     * @param colliderA
     * @param colliderB
     */
    static canCollide(colliderA, colliderB) {
      var _a, _b;
      const bodyA = (_a = colliderA === null || colliderA === void 0 ? void 0 : colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
      const bodyB = (_b = colliderB === null || colliderB === void 0 ? void 0 : colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
      if (colliderA.id === colliderB.id) {
        return false;
      }
      if (colliderA.owner && colliderB.owner && colliderA.owner.id === colliderB.owner.id) {
        return false;
      }
      if (colliderA.localBounds.hasZeroDimensions() || colliderB.localBounds.hasZeroDimensions()) {
        return false;
      }
      if (!bodyA || !bodyB) {
        return false;
      }
      if (!bodyA.group.canCollide(bodyB.group)) {
        return false;
      }
      if (bodyA.collisionType === CollisionType.Fixed && bodyB.collisionType === CollisionType.Fixed) {
        return false;
      }
      if (bodyB.collisionType === CollisionType.PreventCollision || bodyA.collisionType === CollisionType.PreventCollision) {
        return false;
      }
      if (!bodyA.active || !bodyB.active) {
        return false;
      }
      return true;
    }
    /**
     * Returns whether or not it is possible for the pairs to collide
     */
    get canCollide() {
      const colliderA = this.colliderA;
      const colliderB = this.colliderB;
      return Pair.canCollide(colliderA, colliderB);
    }
    /**
     * Runs the collision intersection logic on the members of this pair
     */
    collide() {
      return this.colliderA.collide(this.colliderB);
    }
    /**
     * Check if the collider is part of the pair
     * @param collider
     */
    hasCollider(collider) {
      return collider === this.colliderA || collider === this.colliderB;
    }
    /**
     * Calculates the unique pair hash id for this collision pair (owning id)
     */
    static calculatePairHash(idA, idB) {
      if (idA.value < idB.value) {
        return `#${idA.value}+${idB.value}`;
      } else {
        return `#${idB.value}+${idA.value}`;
      }
    }
  }
  class Projection {
    constructor(min, max) {
      this.min = min;
      this.max = max;
    }
    overlaps(projection) {
      return this.max > projection.min && projection.max > this.min;
    }
    getOverlap(projection) {
      if (this.overlaps(projection)) {
        if (this.max > projection.max) {
          return projection.max - this.min;
        } else {
          return this.max - projection.min;
        }
      }
      return 0;
    }
  }
  class TreeNode {
    constructor(parent) {
      this.parent = parent;
      this.parent = parent || null;
      this.data = null;
      this.bounds = new BoundingBox();
      this.left = null;
      this.right = null;
      this.height = 0;
    }
    isLeaf() {
      return !this.left && !this.right;
    }
  }
  class DynamicTree {
    constructor(worldBounds = new BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)) {
      this.worldBounds = worldBounds;
      this.root = null;
      this.nodes = {};
    }
    /**
     * Inserts a node into the dynamic tree
     */
    _insert(leaf) {
      if (this.root === null) {
        this.root = leaf;
        this.root.parent = null;
        return;
      }
      const leafAABB = leaf.bounds;
      let currentRoot = this.root;
      while (!currentRoot.isLeaf()) {
        const left = currentRoot.left;
        const right = currentRoot.right;
        const area = currentRoot.bounds.getPerimeter();
        const combinedAABB = currentRoot.bounds.combine(leafAABB);
        const combinedArea = combinedAABB.getPerimeter();
        const cost = 2 * combinedArea;
        const inheritanceCost = 2 * (combinedArea - area);
        let leftCost = 0;
        const leftCombined = leafAABB.combine(left.bounds);
        let newArea;
        let oldArea;
        if (left.isLeaf()) {
          leftCost = leftCombined.getPerimeter() + inheritanceCost;
        } else {
          oldArea = left.bounds.getPerimeter();
          newArea = leftCombined.getPerimeter();
          leftCost = newArea - oldArea + inheritanceCost;
        }
        let rightCost = 0;
        const rightCombined = leafAABB.combine(right.bounds);
        if (right.isLeaf()) {
          rightCost = rightCombined.getPerimeter() + inheritanceCost;
        } else {
          oldArea = right.bounds.getPerimeter();
          newArea = rightCombined.getPerimeter();
          rightCost = newArea - oldArea + inheritanceCost;
        }
        if (cost < leftCost && cost < rightCost) {
          break;
        }
        if (leftCost < rightCost) {
          currentRoot = left;
        } else {
          currentRoot = right;
        }
      }
      const oldParent = currentRoot.parent;
      const newParent = new TreeNode(oldParent);
      newParent.bounds = leafAABB.combine(currentRoot.bounds);
      newParent.height = currentRoot.height + 1;
      if (oldParent !== null) {
        if (oldParent.left === currentRoot) {
          oldParent.left = newParent;
        } else {
          oldParent.right = newParent;
        }
        newParent.left = currentRoot;
        newParent.right = leaf;
        currentRoot.parent = newParent;
        leaf.parent = newParent;
      } else {
        newParent.left = currentRoot;
        newParent.right = leaf;
        currentRoot.parent = newParent;
        leaf.parent = newParent;
        this.root = newParent;
      }
      let currentNode = leaf.parent;
      while (currentNode) {
        currentNode = this._balance(currentNode);
        if (!currentNode.left) {
          throw new Error("Parent of current leaf cannot have a null left child" + currentNode);
        }
        if (!currentNode.right) {
          throw new Error("Parent of current leaf cannot have a null right child" + currentNode);
        }
        currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
        currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
        currentNode = currentNode.parent;
      }
    }
    /**
     * Removes a node from the dynamic tree
     */
    _remove(leaf) {
      if (leaf === this.root) {
        this.root = null;
        return;
      }
      const parent = leaf.parent;
      const grandParent = parent.parent;
      let sibling;
      if (parent.left === leaf) {
        sibling = parent.right;
      } else {
        sibling = parent.left;
      }
      if (grandParent) {
        if (grandParent.left === parent) {
          grandParent.left = sibling;
        } else {
          grandParent.right = sibling;
        }
        sibling.parent = grandParent;
        let currentNode = grandParent;
        while (currentNode) {
          currentNode = this._balance(currentNode);
          currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
          currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
          currentNode = currentNode.parent;
        }
      } else {
        this.root = sibling;
        sibling.parent = null;
      }
    }
    /**
     * Tracks a body in the dynamic tree
     */
    trackCollider(collider) {
      const node = new TreeNode();
      node.data = collider;
      node.bounds = collider.bounds;
      node.bounds.left -= 2;
      node.bounds.top -= 2;
      node.bounds.right += 2;
      node.bounds.bottom += 2;
      this.nodes[collider.id.value] = node;
      this._insert(node);
    }
    /**
     * Updates the dynamic tree given the current bounds of each body being tracked
     */
    updateCollider(collider) {
      var _a;
      const node = this.nodes[collider.id.value];
      if (!node) {
        return false;
      }
      const b2 = collider.bounds;
      if (!this.worldBounds.contains(b2)) {
        Logger2.getInstance().warn("Collider with id " + collider.id.value + " is outside the world bounds and will no longer be tracked for physics");
        this.untrackCollider(collider);
        return false;
      }
      if (node.bounds.contains(b2)) {
        return false;
      }
      this._remove(node);
      b2.left -= Physics.boundsPadding;
      b2.top -= Physics.boundsPadding;
      b2.right += Physics.boundsPadding;
      b2.bottom += Physics.boundsPadding;
      if (collider.owner) {
        const body = (_a = collider.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        if (body) {
          const multdx = body.vel.x * 32 / 1e3 * Physics.dynamicTreeVelocityMultiplier;
          const multdy = body.vel.y * 32 / 1e3 * Physics.dynamicTreeVelocityMultiplier;
          if (multdx < 0) {
            b2.left += multdx;
          } else {
            b2.right += multdx;
          }
          if (multdy < 0) {
            b2.top += multdy;
          } else {
            b2.bottom += multdy;
          }
        }
      }
      node.bounds = b2;
      this._insert(node);
      return true;
    }
    /**
     * Untracks a body from the dynamic tree
     */
    untrackCollider(collider) {
      const node = this.nodes[collider.id.value];
      if (!node) {
        return;
      }
      this._remove(node);
      this.nodes[collider.id.value] = null;
      delete this.nodes[collider.id.value];
    }
    /**
     * Balances the tree about a node
     */
    _balance(node) {
      if (node === null) {
        throw new Error("Cannot balance at null node");
      }
      if (node.isLeaf() || node.height < 2) {
        return node;
      }
      const left = node.left;
      const right = node.right;
      const a2 = node;
      const b2 = left;
      const c2 = right;
      const d2 = left.left;
      const e2 = left.right;
      const f2 = right.left;
      const g2 = right.right;
      const balance = c2.height - b2.height;
      if (balance > 1) {
        c2.left = a2;
        c2.parent = a2.parent;
        a2.parent = c2;
        if (c2.parent) {
          if (c2.parent.left === a2) {
            c2.parent.left = c2;
          } else {
            c2.parent.right = c2;
          }
        } else {
          this.root = c2;
        }
        if (f2.height > g2.height) {
          c2.right = f2;
          a2.right = g2;
          g2.parent = a2;
          a2.bounds = b2.bounds.combine(g2.bounds);
          c2.bounds = a2.bounds.combine(f2.bounds);
          a2.height = 1 + Math.max(b2.height, g2.height);
          c2.height = 1 + Math.max(a2.height, f2.height);
        } else {
          c2.right = g2;
          a2.right = f2;
          f2.parent = a2;
          a2.bounds = b2.bounds.combine(f2.bounds);
          c2.bounds = a2.bounds.combine(g2.bounds);
          a2.height = 1 + Math.max(b2.height, f2.height);
          c2.height = 1 + Math.max(a2.height, g2.height);
        }
        return c2;
      }
      if (balance < -1) {
        b2.left = a2;
        b2.parent = a2.parent;
        a2.parent = b2;
        if (b2.parent) {
          if (b2.parent.left === a2) {
            b2.parent.left = b2;
          } else {
            if (b2.parent.right !== a2) {
              throw "Error rotating Dynamic Tree";
            }
            b2.parent.right = b2;
          }
        } else {
          this.root = b2;
        }
        if (d2.height > e2.height) {
          b2.right = d2;
          a2.left = e2;
          e2.parent = a2;
          a2.bounds = c2.bounds.combine(e2.bounds);
          b2.bounds = a2.bounds.combine(d2.bounds);
          a2.height = 1 + Math.max(c2.height, e2.height);
          b2.height = 1 + Math.max(a2.height, d2.height);
        } else {
          b2.right = e2;
          a2.left = d2;
          d2.parent = a2;
          a2.bounds = c2.bounds.combine(d2.bounds);
          b2.bounds = a2.bounds.combine(e2.bounds);
          a2.height = 1 + Math.max(c2.height, d2.height);
          b2.height = 1 + Math.max(a2.height, e2.height);
        }
        return b2;
      }
      return node;
    }
    /**
     * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows
     */
    getHeight() {
      if (this.root === null) {
        return 0;
      }
      return this.root.height;
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.
     *
     * In the query callback, it will be passed a potential collider. Returning true from this callback indicates
     * that you are complete with your query and you do not want to continue. Returning false will continue searching
     * the tree until all possible colliders have been returned.
     */
    query(collider, callback) {
      const bounds = collider.bounds;
      const helper = (currentNode) => {
        if (currentNode && currentNode.bounds.overlaps(bounds)) {
          if (currentNode.isLeaf() && currentNode.data !== collider) {
            if (callback.call(collider, currentNode.data)) {
              return true;
            }
          } else {
            return helper(currentNode.left) || helper(currentNode.right);
          }
        }
        return false;
      };
      helper(this.root);
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely
     * long ray to test the tree specified by `max`.
     *
     * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this
     * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching
     * the tree until all possible bodies that would intersect with the ray have been returned.
     */
    rayCastQuery(ray, max = Infinity, callback) {
      const helper = (currentNode) => {
        if (currentNode && currentNode.bounds.rayCast(ray, max)) {
          if (currentNode.isLeaf()) {
            if (callback.call(ray, currentNode.data)) {
              return true;
            }
          } else {
            return helper(currentNode.left) || helper(currentNode.right);
          }
        }
        return false;
      };
      helper(this.root);
    }
    getNodes() {
      const helper = (currentNode) => {
        if (currentNode) {
          return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
        } else {
          return [];
        }
      };
      return helper(this.root);
    }
    debug(ex) {
      const helper = (currentNode) => {
        if (currentNode) {
          if (currentNode.isLeaf()) {
            currentNode.bounds.draw(ex, Color.Green);
          } else {
            currentNode.bounds.draw(ex, Color.White);
          }
          if (currentNode.left) {
            helper(currentNode.left);
          }
          if (currentNode.right) {
            helper(currentNode.right);
          }
        }
      };
      helper(this.root);
    }
  }
  class Ray {
    /**
     * @param pos The starting position for the ray
     * @param dir The vector indicating the direction of the ray
     */
    constructor(pos, dir) {
      this.pos = pos;
      this.dir = dir.normalize();
    }
    /**
     * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
     * This number indicates the mathematical intersection time.
     * @param line  The line to test
     */
    intersect(line2) {
      const numerator = line2.begin.sub(this.pos);
      if (this.dir.cross(line2.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
        return -1;
      }
      const divisor = this.dir.cross(line2.getSlope());
      if (divisor === 0) {
        return -1;
      }
      const t2 = numerator.cross(line2.getSlope()) / divisor;
      if (t2 >= 0) {
        const u2 = numerator.cross(this.dir) / divisor / line2.getLength();
        if (u2 >= 0 && u2 <= 1) {
          return t2;
        }
      }
      return -1;
    }
    intersectPoint(line2) {
      const time = this.intersect(line2);
      if (time < 0) {
        return null;
      }
      return this.getPoint(time);
    }
    /**
     * Returns the point of intersection given the intersection time
     */
    getPoint(time) {
      return this.pos.add(this.dir.scale(time));
    }
  }
  class DynamicTreeCollisionProcessor {
    constructor() {
      this._dynamicCollisionTree = new DynamicTree();
      this._pairs = /* @__PURE__ */ new Set();
      this._collisionPairCache = [];
      this._colliders = [];
    }
    getColliders() {
      return this._colliders;
    }
    rayCast(ray, options) {
      var _a, _b, _c;
      const results2 = [];
      const maxDistance = (_a = options === null || options === void 0 ? void 0 : options.maxDistance) !== null && _a !== void 0 ? _a : Infinity;
      const collisionGroup = (_b = options === null || options === void 0 ? void 0 : options.collisionGroup) !== null && _b !== void 0 ? _b : CollisionGroup.All;
      const searchAllColliders = (_c = options === null || options === void 0 ? void 0 : options.searchAllColliders) !== null && _c !== void 0 ? _c : false;
      this._dynamicCollisionTree.rayCastQuery(ray, maxDistance, (collider) => {
        var _a2;
        const owner = collider.owner;
        const maybeBody = owner.get(BodyComponent);
        if (collisionGroup.mask !== CollisionGroup.All.mask && ((_a2 = maybeBody === null || maybeBody === void 0 ? void 0 : maybeBody.group) === null || _a2 === void 0 ? void 0 : _a2.mask) !== collisionGroup.mask) {
          return false;
        }
        const hit = collider.rayCast(ray, maxDistance);
        if (hit) {
          results2.push({
            distance: hit.sub(ray.pos).distance(),
            point: hit,
            collider,
            body: maybeBody
          });
          if (!searchAllColliders) {
            return true;
          }
        }
        return false;
      });
      return results2;
    }
    /**
     * Tracks a physics body for collisions
     */
    track(target) {
      if (!target) {
        Logger2.getInstance().warn("Cannot track null collider");
        return;
      }
      if (target instanceof CompositeCollider) {
        const colliders = target.getColliders();
        for (const c2 of colliders) {
          c2.owner = target.owner;
          this._colliders.push(c2);
          this._dynamicCollisionTree.trackCollider(c2);
        }
      } else {
        this._colliders.push(target);
        this._dynamicCollisionTree.trackCollider(target);
      }
    }
    /**
     * Untracks a physics body
     */
    untrack(target) {
      if (!target) {
        Logger2.getInstance().warn("Cannot untrack a null collider");
        return;
      }
      if (target instanceof CompositeCollider) {
        const colliders = target.getColliders();
        for (const c2 of colliders) {
          const index = this._colliders.indexOf(c2);
          if (index !== -1) {
            this._colliders.splice(index, 1);
          }
          this._dynamicCollisionTree.untrackCollider(c2);
        }
      } else {
        const index = this._colliders.indexOf(target);
        if (index !== -1) {
          this._colliders.splice(index, 1);
        }
        this._dynamicCollisionTree.untrackCollider(target);
      }
    }
    _pairExists(colliderA, colliderB) {
      const hash = Pair.calculatePairHash(colliderA.id, colliderB.id);
      return this._pairs.has(hash);
    }
    /**
     * Detects potential collision pairs in a broadphase approach with the dynamic AABB tree strategy
     */
    broadphase(targets, delta, stats) {
      const seconds = delta / 1e3;
      const potentialColliders = targets.filter((other) => {
        var _a, _b;
        const body = (_a = other.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        return ((_b = other.owner) === null || _b === void 0 ? void 0 : _b.active) && body.collisionType !== CollisionType.PreventCollision;
      });
      this._collisionPairCache = [];
      this._pairs.clear();
      let collider;
      for (let j2 = 0, l2 = potentialColliders.length; j2 < l2; j2++) {
        collider = potentialColliders[j2];
        this._dynamicCollisionTree.query(collider, (other) => {
          if (!this._pairExists(collider, other) && Pair.canCollide(collider, other)) {
            const pair = new Pair(collider, other);
            this._pairs.add(pair.id);
            this._collisionPairCache.push(pair);
          }
          return false;
        });
      }
      if (stats) {
        stats.physics.pairs = this._collisionPairCache.length;
      }
      if (Physics.checkForFastBodies) {
        for (const collider2 of potentialColliders) {
          const body = collider2.owner.get(BodyComponent);
          if (body.collisionType !== CollisionType.Active) {
            continue;
          }
          const updateDistance = body.vel.size * seconds + // velocity term
          body.acc.size * 0.5 * seconds * seconds;
          const minDimension = Math.min(collider2.bounds.height, collider2.bounds.width);
          if (Physics.disableMinimumSpeedForFastBody || updateDistance > minDimension / 2) {
            if (stats) {
              stats.physics.fastBodies++;
            }
            const updateVec = body.globalPos.sub(body.oldPos);
            const centerPoint = collider2.center;
            const furthestPoint = collider2.getFurthestPoint(body.vel);
            const origin = furthestPoint.sub(updateVec);
            const ray = new Ray(origin, body.vel);
            ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics.surfaceEpsilon));
            let minCollider;
            let minTranslate = new Vector(Infinity, Infinity);
            this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics.surfaceEpsilon * 2, (other) => {
              if (!this._pairExists(collider2, other) && Pair.canCollide(collider2, other)) {
                const hitPoint = other.rayCast(ray, updateDistance + Physics.surfaceEpsilon * 10);
                if (hitPoint) {
                  const translate = hitPoint.sub(origin);
                  if (translate.size < minTranslate.size) {
                    minTranslate = translate;
                    minCollider = other;
                  }
                }
              }
              return false;
            });
            if (minCollider && Vector.isValid(minTranslate)) {
              const pair = new Pair(collider2, minCollider);
              if (!this._pairs.has(pair.id)) {
                this._pairs.add(pair.id);
                this._collisionPairCache.push(pair);
              }
              const shift = centerPoint.sub(furthestPoint);
              body.globalPos = origin.add(shift).add(minTranslate).add(ray.dir.scale(10 * Physics.surfaceEpsilon));
              collider2.update(body.transform.get());
              if (stats) {
                stats.physics.fastBodyCollisions++;
              }
            }
          }
        }
      }
      return this._collisionPairCache;
    }
    /**
     * Applies narrow phase on collision pairs to find actual area intersections
     * Adds actual colliding pairs to stats' Frame data
     */
    narrowphase(pairs, stats) {
      let contacts = [];
      for (let i2 = 0; i2 < pairs.length; i2++) {
        const newContacts = pairs[i2].collide();
        contacts = contacts.concat(newContacts);
        if (stats && newContacts.length > 0) {
          for (const c2 of newContacts) {
            stats.physics.contacts.set(c2.id, c2);
          }
        }
      }
      if (stats) {
        stats.physics.collisions += contacts.length;
      }
      return contacts;
    }
    /**
     * Update the dynamic tree positions
     */
    update(targets) {
      let updated = 0;
      const len = targets.length;
      for (let i2 = 0; i2 < len; i2++) {
        if (this._dynamicCollisionTree.updateCollider(targets[i2])) {
          updated++;
        }
      }
      return updated;
    }
    debug(ex) {
      this._dynamicCollisionTree.debug(ex);
    }
  }
  class Collider {
    constructor() {
      this.id = createId("collider", Collider._ID++);
      this.__compositeColliderId = null;
      this.events = new EventEmitter2();
    }
    /**
     * Returns a boolean indicating whether this body collided with
     * or was in stationary contact with
     * the body of the other [[Collider]]
     */
    touching(other) {
      const contact = this.collide(other);
      if (contact) {
        return true;
      }
      return false;
    }
  }
  Collider._ID = 0;
  class CompositeCollider extends Collider {
    constructor(colliders) {
      super();
      this._collisionProcessor = new DynamicTreeCollisionProcessor();
      this._dynamicAABBTree = new DynamicTree();
      this._colliders = [];
      for (const c2 of colliders) {
        this.addCollider(c2);
      }
    }
    clearColliders() {
      this._colliders = [];
    }
    addCollider(collider) {
      collider.events.pipe(this.events);
      collider.__compositeColliderId = this.id;
      this._colliders.push(collider);
      this._collisionProcessor.track(collider);
      this._dynamicAABBTree.trackCollider(collider);
    }
    removeCollider(collider) {
      collider.events.pipe(this.events);
      collider.__compositeColliderId = null;
      removeItemFromArray(collider, this._colliders);
      this._collisionProcessor.untrack(collider);
      this._dynamicAABBTree.untrackCollider(collider);
    }
    getColliders() {
      return this._colliders;
    }
    get worldPos() {
      var _a, _b;
      return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;
    }
    get center() {
      var _a, _b;
      return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;
    }
    get bounds() {
      var _a, _b;
      const colliders = this.getColliders();
      const results2 = colliders.reduce((acc, collider) => acc.combine(collider.bounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox().translate(this.worldPos));
      return results2;
    }
    get localBounds() {
      var _a, _b;
      const colliders = this.getColliders();
      const results2 = colliders.reduce((acc, collider) => acc.combine(collider.localBounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox());
      return results2;
    }
    get axes() {
      const colliders = this.getColliders();
      let axes = [];
      for (const collider of colliders) {
        axes = axes.concat(collider.axes);
      }
      return axes;
    }
    getFurthestPoint(direction) {
      const colliders = this.getColliders();
      const furthestPoints = [];
      for (const collider of colliders) {
        furthestPoints.push(collider.getFurthestPoint(direction));
      }
      let bestPoint = furthestPoints[0];
      let maxDistance = -Number.MAX_VALUE;
      for (const point2 of furthestPoints) {
        const distance2 = point2.dot(direction);
        if (distance2 > maxDistance) {
          bestPoint = point2;
          maxDistance = distance2;
        }
      }
      return bestPoint;
    }
    getInertia(mass) {
      const colliders = this.getColliders();
      let totalInertia = 0;
      for (const collider of colliders) {
        totalInertia += collider.getInertia(mass);
      }
      return totalInertia;
    }
    collide(other) {
      let otherColliders = [other];
      if (other instanceof CompositeCollider) {
        otherColliders = other.getColliders();
      }
      const pairs = [];
      for (const c2 of otherColliders) {
        this._dynamicAABBTree.query(c2, (potentialCollider) => {
          pairs.push(new Pair(c2, potentialCollider));
          return false;
        });
      }
      let contacts = [];
      for (const p2 of pairs) {
        contacts = contacts.concat(p2.collide());
      }
      return contacts;
    }
    getClosestLineBetween(other) {
      const colliders = this.getColliders();
      const lines = [];
      if (other instanceof CompositeCollider) {
        const otherColliders = other.getColliders();
        for (const colliderA of colliders) {
          for (const colliderB of otherColliders) {
            const maybeLine = colliderA.getClosestLineBetween(colliderB);
            if (maybeLine) {
              lines.push(maybeLine);
            }
          }
        }
      } else {
        for (const collider of colliders) {
          const maybeLine = other.getClosestLineBetween(collider);
          if (maybeLine) {
            lines.push(maybeLine);
          }
        }
      }
      if (lines.length) {
        let minLength = lines[0].getLength();
        let minLine = lines[0];
        for (const line2 of lines) {
          const length = line2.getLength();
          if (length < minLength) {
            minLength = length;
            minLine = line2;
          }
        }
        return minLine;
      }
      return null;
    }
    contains(point2) {
      const colliders = this.getColliders();
      for (const collider of colliders) {
        if (collider.contains(point2)) {
          return true;
        }
      }
      return false;
    }
    rayCast(ray, max) {
      const colliders = this.getColliders();
      const points = [];
      for (const collider of colliders) {
        const vec2 = collider.rayCast(ray, max);
        if (vec2) {
          points.push(vec2);
        }
      }
      if (points.length) {
        let minPoint = points[0];
        let minDistance = minPoint.dot(ray.dir);
        for (const point2 of points) {
          const distance2 = ray.dir.dot(point2);
          if (distance2 < minDistance) {
            minPoint = point2;
            minDistance = distance2;
          }
        }
        return minPoint;
      }
      return null;
    }
    project(axis) {
      const colliders = this.getColliders();
      const projs = [];
      for (const collider of colliders) {
        const proj = collider.project(axis);
        if (proj) {
          projs.push(proj);
        }
      }
      if (projs.length) {
        const newProjection = new Projection(projs[0].min, projs[0].max);
        for (const proj of projs) {
          newProjection.min = Math.min(proj.min, newProjection.min);
          newProjection.max = Math.max(proj.max, newProjection.max);
        }
        return newProjection;
      }
      return null;
    }
    update(transform) {
      if (transform) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
          collider.owner = this.owner;
          collider.update(transform);
        }
      }
    }
    debug(ex, color2) {
      const colliders = this.getColliders();
      for (const collider of colliders) {
        collider.debug(ex, color2);
      }
    }
    clone() {
      return new CompositeCollider(this._colliders.map((c2) => c2.clone()));
    }
  }
  class LineSegment {
    /**
     * @param begin  The starting point of the line segment
     * @param end  The ending point of the line segment
     */
    constructor(begin, end) {
      this.begin = begin;
      this.end = end;
    }
    /**
     * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.
     */
    get slope() {
      return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);
    }
    /**
     * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.
     */
    get intercept() {
      return this.begin.y - this.slope * this.begin.x;
    }
    /**
     * Gets the normal of the line
     */
    normal() {
      if (this._normal) {
        return this._normal;
      }
      return this._normal = this.end.sub(this.begin).normal();
    }
    dir() {
      if (this._dir) {
        return this._dir;
      }
      return this._dir = this.end.sub(this.begin);
    }
    getPoints() {
      return [this.begin, this.end];
    }
    /**
     * Returns the slope of the line in the form of a vector of length 1
     */
    getSlope() {
      if (this._slope) {
        return this._slope;
      }
      const begin = this.begin;
      const end = this.end;
      const distance2 = begin.distance(end);
      return this._slope = end.sub(begin).scale(1 / distance2);
    }
    /**
     * Returns the edge of the line as vector, the length of the vector is the length of the edge
     */
    getEdge() {
      const begin = this.begin;
      const end = this.end;
      return end.sub(begin);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
      if (this._length) {
        return this._length;
      }
      const begin = this.begin;
      const end = this.end;
      const distance2 = begin.distance(end);
      return this._length = distance2;
    }
    /**
     * Returns the midpoint of the edge
     */
    get midpoint() {
      return this.begin.add(this.end).scale(0.5);
    }
    /**
     * Flips the direction of the line segment
     */
    flip() {
      return new LineSegment(this.end, this.begin);
    }
    /**
     * Tests if a given point is below the line, points in the normal direction above the line are considered above.
     * @param point
     */
    below(point2) {
      const above2 = (this.end.x - this.begin.x) * (point2.y - this.begin.y) - (this.end.y - this.begin.y) * (point2.x - this.begin.x);
      return above2 >= 0;
    }
    /**
     * Returns the clip point
     * @param sideVector Vector that traces the line
     * @param length Length to clip along side
     */
    clip(sideVector, length) {
      let dir = sideVector;
      dir = dir.normalize();
      const near = dir.dot(this.begin) - length;
      const far = dir.dot(this.end) - length;
      const results2 = [];
      if (near <= 0) {
        results2.push(this.begin);
      }
      if (far <= 0) {
        results2.push(this.end);
      }
      if (near * far < 0) {
        const clipTime = near / (near - far);
        results2.push(this.begin.add(this.end.sub(this.begin).scale(clipTime)));
      }
      if (results2.length !== 2) {
        return null;
      }
      return new LineSegment(results2[0], results2[1]);
    }
    /**
     * Find the perpendicular distance from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * @param point
     */
    distanceToPoint(point2, signed = false) {
      const x0 = point2.x;
      const y0 = point2.y;
      const l2 = this.getLength();
      const dy = this.end.y - this.begin.y;
      const dx = this.end.x - this.begin.x;
      const distance2 = (dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l2;
      return signed ? distance2 : Math.abs(distance2);
    }
    /**
     * Find the perpendicular line from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * (a - p) - ((a - p) * n)n
     * a is a point on the line
     * p is the arbitrary point above the line
     * n is a unit vector in direction of the line
     * @param point
     */
    findVectorToPoint(point2) {
      const aMinusP = this.begin.sub(point2);
      const n2 = this.getSlope();
      return aMinusP.sub(n2.scale(aMinusP.dot(n2)));
    }
    /**
     * Finds a point on the line given only an X or a Y value. Given an X value, the function returns
     * a new point with the calculated Y value and vice-versa.
     *
     * @param x The known X value of the target point
     * @param y The known Y value of the target point
     * @returns A new point with the other calculated axis value
     */
    findPoint(x2 = null, y2 = null) {
      const m2 = this.slope;
      const b2 = this.intercept;
      if (x2 !== null) {
        return new Vector(x2, m2 * x2 + b2);
      } else if (y2 !== null) {
        return new Vector((y2 - b2) / m2, y2);
      } else {
        throw new Error("You must provide an X or a Y value");
      }
    }
    /**
     * @see http://stackoverflow.com/a/11908158/109458
     */
    hasPoint() {
      let currPoint;
      let threshold = 0;
      if (typeof arguments[0] === "number" && typeof arguments[1] === "number") {
        currPoint = new Vector(arguments[0], arguments[1]);
        threshold = arguments[2] || 0;
      } else if (arguments[0] instanceof Vector) {
        currPoint = arguments[0];
        threshold = arguments[1] || 0;
      } else {
        throw "Could not determine the arguments for Vector.hasPoint";
      }
      const dxc = currPoint.x - this.begin.x;
      const dyc = currPoint.y - this.begin.y;
      const dx1 = this.end.x - this.begin.x;
      const dy1 = this.end.y - this.begin.y;
      const cross = dxc * dy1 - dyc * dx1;
      if (Math.abs(cross) > threshold) {
        return false;
      }
      if (Math.abs(dx1) >= Math.abs(dy1)) {
        return dx1 > 0 ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;
      } else {
        return dy1 > 0 ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;
      }
    }
  }
  function ClosestLine(p0, u2, q0, v2) {
    const w0 = p0.sub(q0);
    const a2 = u2.dot(u2);
    const b2 = u2.dot(v2);
    const c2 = v2.dot(v2);
    const d2 = u2.dot(w0);
    const e2 = v2.dot(w0);
    const denom = a2 * c2 - b2 * b2;
    let sDenom = denom;
    let tDenom = denom;
    if (denom === 0 || denom <= 0.01) {
      const tClosestParallel = d2 / b2;
      return new LineSegment(p0, q0.add(v2.scale(tClosestParallel)));
    }
    let sClosest = b2 * e2 - c2 * d2;
    let tClosest = a2 * e2 - b2 * d2;
    if (sClosest < 0) {
      sClosest = 0;
      tClosest = e2;
      tDenom = c2;
    } else if (sClosest > sDenom) {
      sClosest = sDenom;
      tClosest = e2 + b2;
      tDenom = c2;
    }
    if (tClosest < 0) {
      tClosest = 0;
      if (-d2 < 0) {
        sClosest = 0;
      } else if (-d2 > a2) {
        sClosest = sDenom;
      } else {
        sClosest = -d2;
        sDenom = a2;
      }
    } else if (tClosest > tDenom) {
      tClosest = tDenom;
      if (-d2 + b2 < 0) {
        sClosest = 0;
      } else if (-d2 + b2 > a2) {
        sClosest = sDenom;
      } else {
        sClosest = -d2 + b2;
        sDenom = a2;
      }
    }
    sClosest = Math.abs(sClosest) < 1e-3 ? 0 : sClosest / sDenom;
    tClosest = Math.abs(tClosest) < 1e-3 ? 0 : tClosest / tDenom;
    return new LineSegment(p0.add(u2.scale(sClosest)), q0.add(v2.scale(tClosest)));
  }
  const ClosestLineJumpTable = {
    PolygonPolygonClosestLine(polygonA, polygonB) {
      const otherWorldPos = polygonB.worldPos;
      const otherDirection = otherWorldPos.sub(polygonA.worldPos);
      const thisDirection = otherDirection.negate();
      const rayTowardsOther = new Ray(polygonA.worldPos, otherDirection);
      const rayTowardsThis = new Ray(otherWorldPos, thisDirection);
      const thisPoint = polygonA.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
      const otherPoint = polygonB.rayCast(rayTowardsThis).add(rayTowardsThis.dir.scale(0.1));
      const thisFace = polygonA.getClosestFace(thisPoint);
      const otherFace = polygonB.getClosestFace(otherPoint);
      const p0 = thisFace.face.begin;
      const u2 = thisFace.face.getEdge();
      const q0 = otherFace.face.begin;
      const v2 = otherFace.face.getEdge();
      return ClosestLine(p0, u2, q0, v2);
    },
    PolygonEdgeClosestLine(polygon, edge) {
      const otherWorldPos = edge.worldPos;
      const otherDirection = otherWorldPos.sub(polygon.worldPos);
      const rayTowardsOther = new Ray(polygon.worldPos, otherDirection);
      const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
      const thisFace = polygon.getClosestFace(thisPoint);
      const p0 = thisFace.face.begin;
      const u2 = thisFace.face.getEdge();
      const edgeLine = edge.asLine();
      const edgeStart = edgeLine.begin;
      const edgeVector = edgeLine.getEdge();
      const q0 = edgeStart;
      const v2 = edgeVector;
      return ClosestLine(p0, u2, q0, v2);
    },
    PolygonCircleClosestLine(polygon, circle2) {
      const otherWorldPos = circle2.worldPos;
      const otherDirection = otherWorldPos.sub(polygon.worldPos);
      const rayTowardsOther = new Ray(polygon.worldPos, otherDirection.normalize());
      const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
      const thisFace = polygon.getClosestFace(thisPoint);
      const p0 = thisFace.face.begin;
      const u2 = thisFace.face.getEdge();
      let t2 = (u2.x * (otherWorldPos.x - p0.x) + u2.y * (otherWorldPos.y - p0.y)) / (u2.x * u2.x + u2.y * u2.y);
      if (t2 > 1) {
        t2 = 1;
      } else if (t2 < 0) {
        t2 = 0;
      }
      const d2 = Math.sqrt(Math.pow(p0.x + u2.x * t2 - otherWorldPos.x, 2) + Math.pow(p0.y + u2.y * t2 - otherWorldPos.y, 2)) - circle2.radius;
      const circlex = (p0.x + u2.x * t2 - otherWorldPos.x) * circle2.radius / (circle2.radius + d2);
      const circley = (p0.y + u2.y * t2 - otherWorldPos.y) * circle2.radius / (circle2.radius + d2);
      return new LineSegment(u2.scale(t2).add(p0), new Vector(otherWorldPos.x + circlex, otherWorldPos.y + circley));
    },
    CircleCircleClosestLine(circleA, circleB) {
      const otherWorldPos = circleB.worldPos;
      const otherDirection = otherWorldPos.sub(circleA.worldPos);
      const thisWorldPos = circleA.worldPos;
      const thisDirection = thisWorldPos.sub(circleB.worldPos);
      const rayTowardsOther = new Ray(circleA.worldPos, otherDirection);
      const rayTowardsThis = new Ray(circleB.worldPos, thisDirection);
      const thisPoint = circleA.rayCast(rayTowardsOther);
      const otherPoint = circleB.rayCast(rayTowardsThis);
      return new LineSegment(thisPoint, otherPoint);
    },
    CircleEdgeClosestLine(circle2, edge) {
      const circleWorlPos = circle2.worldPos;
      const edgeLine = edge.asLine();
      const edgeStart = edgeLine.begin;
      const edgeVector = edgeLine.getEdge();
      const p0 = edgeStart;
      const u2 = edgeVector;
      let t2 = (u2.x * (circleWorlPos.x - p0.x) + u2.y * (circleWorlPos.y - p0.y)) / (u2.x * u2.x + u2.y * u2.y);
      if (t2 > 1) {
        t2 = 1;
      } else if (t2 < 0) {
        t2 = 0;
      }
      const d2 = Math.sqrt(Math.pow(p0.x + u2.x * t2 - circleWorlPos.x, 2) + Math.pow(p0.y + u2.y * t2 - circleWorlPos.y, 2)) - circle2.radius;
      const circlex = (p0.x + u2.x * t2 - circleWorlPos.x) * circle2.radius / (circle2.radius + d2);
      const circley = (p0.y + u2.y * t2 - circleWorlPos.y) * circle2.radius / (circle2.radius + d2);
      return new LineSegment(u2.scale(t2).add(p0), new Vector(circleWorlPos.x + circlex, circleWorlPos.y + circley));
    },
    EdgeEdgeClosestLine(edgeA, edgeB) {
      const edgeLineA = edgeA.asLine();
      const edgeStartA = edgeLineA.begin;
      const edgeVectorA = edgeLineA.getEdge();
      const p0 = edgeStartA;
      const u2 = edgeVectorA;
      const edgeLineB = edgeB.asLine();
      const edgeStartB = edgeLineB.begin;
      const edgeVectorB = edgeLineB.getEdge();
      const q0 = edgeStartB;
      const v2 = edgeVectorB;
      return ClosestLine(p0, u2, q0, v2);
    }
  };
  class CircleCollider extends Collider {
    get worldPos() {
      return this._globalMatrix.getPosition();
    }
    /**
     * Get the radius of the circle
     */
    get radius() {
      var _a;
      const tx = this._transform;
      const scale2 = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;
      return this._naturalRadius * Math.min(scale2.x, scale2.y);
    }
    /**
     * Set the radius of the circle
     */
    set radius(val) {
      var _a;
      const tx = this._transform;
      const scale2 = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;
      this._naturalRadius = val / Math.min(scale2.x, scale2.y);
    }
    constructor(options) {
      super();
      this.offset = Vector.Zero;
      this._globalMatrix = AffineMatrix.identity();
      this.offset = options.offset || Vector.Zero;
      this.radius = options.radius || 0;
      this._globalMatrix.translate(this.offset.x, this.offset.y);
    }
    /**
     * Returns a clone of this shape, not associated with any collider
     */
    clone() {
      return new CircleCollider({
        offset: this.offset.clone(),
        radius: this.radius
      });
    }
    /**
     * Get the center of the collider in world coordinates
     */
    get center() {
      return this._globalMatrix.getPosition();
    }
    /**
     * Tests if a point is contained in this collider
     */
    contains(point2) {
      var _a, _b;
      const pos = (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : this.offset;
      const distance2 = pos.distance(point2);
      if (distance2 <= this.radius) {
        return true;
      }
      return false;
    }
    /**
     * Casts a ray at the Circle collider and returns the nearest point of collision
     * @param ray
     */
    rayCast(ray, max = Infinity) {
      const c2 = this.center;
      const dir = ray.dir;
      const orig = ray.pos;
      const discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c2)), 2) - Math.pow(orig.sub(c2).distance(), 2) + Math.pow(this.radius, 2));
      if (discriminant < 0) {
        return null;
      } else {
        let toi = 0;
        if (discriminant === 0) {
          toi = -dir.dot(orig.sub(c2));
          if (toi > 0 && toi < max) {
            return ray.getPoint(toi);
          }
          return null;
        } else {
          const toi1 = -dir.dot(orig.sub(c2)) + discriminant;
          const toi2 = -dir.dot(orig.sub(c2)) - discriminant;
          const positiveToi = [];
          if (toi1 >= 0) {
            positiveToi.push(toi1);
          }
          if (toi2 >= 0) {
            positiveToi.push(toi2);
          }
          const mintoi = Math.min(...positiveToi);
          if (mintoi <= max) {
            return ray.getPoint(mintoi);
          }
          return null;
        }
      }
    }
    getClosestLineBetween(shape) {
      if (shape instanceof CircleCollider) {
        return ClosestLineJumpTable.CircleCircleClosestLine(this, shape);
      } else if (shape instanceof PolygonCollider) {
        return ClosestLineJumpTable.PolygonCircleClosestLine(shape, this).flip();
      } else if (shape instanceof EdgeCollider) {
        return ClosestLineJumpTable.CircleEdgeClosestLine(this, shape).flip();
      } else {
        throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
      }
    }
    /**
     * @inheritdoc
     */
    collide(collider) {
      if (collider instanceof CircleCollider) {
        return CollisionJumpTable.CollideCircleCircle(this, collider);
      } else if (collider instanceof PolygonCollider) {
        return CollisionJumpTable.CollideCirclePolygon(this, collider);
      } else if (collider instanceof EdgeCollider) {
        return CollisionJumpTable.CollideCircleEdge(this, collider);
      } else {
        throw new Error(`Circle could not collide with unknown CollisionShape ${typeof collider}`);
      }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
      return this.center.add(direction.normalize().scale(this.radius));
    }
    /**
     * Find the local point on the shape in the direction specified
     * @param direction
     */
    getFurthestLocalPoint(direction) {
      const dir = direction.normalize();
      return dir.scale(this.radius);
    }
    /**
     * Get the axis aligned bounding box for the circle collider in world coordinates
     */
    get bounds() {
      var _a, _b, _c;
      const tx = this._transform;
      const scale2 = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;
      const rotation = (_b = tx === null || tx === void 0 ? void 0 : tx.globalRotation) !== null && _b !== void 0 ? _b : 0;
      const pos = (_c = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _c !== void 0 ? _c : Vector.Zero;
      return new BoundingBox(this.offset.x - this._naturalRadius, this.offset.y - this._naturalRadius, this.offset.x + this._naturalRadius, this.offset.y + this._naturalRadius).rotate(rotation).scale(scale2).translate(pos);
    }
    /**
     * Get the axis aligned bounding box for the circle collider in local coordinates
     */
    get localBounds() {
      return new BoundingBox(this.offset.x - this._naturalRadius, this.offset.y - this._naturalRadius, this.offset.x + this._naturalRadius, this.offset.y + this._naturalRadius);
    }
    /**
     * Get axis not implemented on circles, since there are infinite axis in a circle
     */
    get axes() {
      return [];
    }
    /**
     * Returns the moment of inertia of a circle given it's mass
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
      return mass * this.radius * this.radius / 2;
    }
    /* istanbul ignore next */
    update(transform) {
      var _a;
      this._transform = transform;
      const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;
      globalMat.clone(this._globalMatrix);
      this._globalMatrix.translate(this.offset.x, this.offset.y);
    }
    /**
     * Project the circle along a specified axis
     */
    project(axis) {
      const scalars = [];
      const point2 = this.center;
      const dotProduct = point2.dot(axis);
      scalars.push(dotProduct);
      scalars.push(dotProduct + this.radius);
      scalars.push(dotProduct - this.radius);
      return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    debug(ex, color2) {
      var _a, _b, _c, _d;
      const tx = this._transform;
      const scale2 = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;
      const rotation = (_b = tx === null || tx === void 0 ? void 0 : tx.globalRotation) !== null && _b !== void 0 ? _b : 0;
      const pos = (_c = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _c !== void 0 ? _c : Vector.Zero;
      ex.save();
      ex.translate(pos.x, pos.y);
      ex.rotate(rotation);
      ex.scale(scale2.x, scale2.y);
      ex.drawCircle((_d = this.offset) !== null && _d !== void 0 ? _d : Vector.Zero, this._naturalRadius, Color.Transparent, color2, 2);
      ex.restore();
    }
  }
  class CollisionContact {
    constructor(colliderA, colliderB, mtv, normal, tangent, points, localPoints, info) {
      var _a, _b;
      this._canceled = false;
      this.colliderA = colliderA;
      this.colliderB = colliderB;
      this.mtv = mtv;
      this.normal = normal;
      this.tangent = tangent;
      this.points = points;
      this.localPoints = localPoints;
      this.info = info;
      this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
      if (colliderA.__compositeColliderId || colliderB.__compositeColliderId) {
        this.id += "|" + Pair.calculatePairHash((_a = colliderA.__compositeColliderId) !== null && _a !== void 0 ? _a : colliderA.id, (_b = colliderB.__compositeColliderId) !== null && _b !== void 0 ? _b : colliderB.id);
      }
    }
    /**
     * Match contact awake state, except if body's are Fixed
     */
    matchAwake() {
      const bodyA = this.colliderA.owner.get(BodyComponent);
      const bodyB = this.colliderB.owner.get(BodyComponent);
      if (bodyA && bodyB) {
        if (bodyA.sleeping !== bodyB.sleeping) {
          if (bodyA.sleeping && bodyA.collisionType !== CollisionType.Fixed && bodyB.sleepMotion >= Physics.wakeThreshold) {
            bodyA.setSleeping(false);
          }
          if (bodyB.sleeping && bodyB.collisionType !== CollisionType.Fixed && bodyA.sleepMotion >= Physics.wakeThreshold) {
            bodyB.setSleeping(false);
          }
        }
      }
    }
    isCanceled() {
      return this._canceled;
    }
    cancel() {
      this._canceled = true;
    }
  }
  class SeparatingAxis {
    static findPolygonPolygonSeparation(polyA, polyB) {
      let bestSeparation = -Number.MAX_VALUE;
      let bestSide = null;
      let bestAxis = null;
      let bestSideIndex = -1;
      let bestOtherPoint = null;
      const sides = polyA.getSides();
      const localSides = polyA.getLocalSides();
      for (let i2 = 0; i2 < sides.length; i2++) {
        const side = sides[i2];
        const axis = side.normal();
        const vertB = polyB.getFurthestPoint(axis.negate());
        const vertSeparation = side.distanceToPoint(vertB, true);
        if (vertSeparation > bestSeparation) {
          bestSeparation = vertSeparation;
          bestSide = side;
          bestAxis = axis;
          bestSideIndex = i2;
          bestOtherPoint = vertB;
        }
      }
      return {
        collider: polyA,
        separation: bestAxis ? bestSeparation : 99,
        axis: bestAxis,
        side: bestSide,
        localSide: localSides[bestSideIndex],
        sideId: bestSideIndex,
        point: bestOtherPoint,
        localPoint: bestAxis ? polyB.getFurthestLocalPoint(bestAxis.negate()) : null
      };
    }
    static findCirclePolygonSeparation(circle2, polygon) {
      const axes = polygon.axes;
      const pc2 = polygon.center;
      const polyDir = pc2.sub(circle2.worldPos);
      const closestPointOnPoly = polygon.getFurthestPoint(polyDir.negate());
      axes.push(closestPointOnPoly.sub(circle2.worldPos).normalize());
      let minOverlap = Number.MAX_VALUE;
      let minAxis = null;
      let minIndex = -1;
      for (let i2 = 0; i2 < axes.length; i2++) {
        const proj1 = polygon.project(axes[i2]);
        const proj2 = circle2.project(axes[i2]);
        const overlap = proj1.getOverlap(proj2);
        if (overlap <= 0) {
          return null;
        } else {
          if (overlap < minOverlap) {
            minOverlap = overlap;
            minAxis = axes[i2];
            minIndex = i2;
          }
        }
      }
      if (minIndex < 0) {
        return null;
      }
      return minAxis.normalize().scale(minOverlap);
    }
  }
  const CollisionJumpTable = {
    CollideCircleCircle(circleA, circleB) {
      const circleAPos = circleA.worldPos;
      const circleBPos = circleB.worldPos;
      const combinedRadius = circleA.radius + circleB.radius;
      const distance2 = circleAPos.distance(circleBPos);
      if (distance2 > combinedRadius) {
        return [];
      }
      const separation = combinedRadius - distance2;
      const normal = circleBPos.sub(circleAPos).normalize();
      const tangent = normal.perpendicular();
      const mvt = normal.scale(separation);
      const point2 = circleA.getFurthestPoint(normal);
      const local = circleA.getFurthestLocalPoint(normal);
      const info = {
        collider: circleA,
        separation,
        axis: normal,
        point: point2
      };
      return [new CollisionContact(circleA, circleB, mvt, normal, tangent, [point2], [local], info)];
    },
    CollideCirclePolygon(circle2, polygon) {
      var _a, _b;
      let minAxis = SeparatingAxis.findCirclePolygonSeparation(circle2, polygon);
      if (!minAxis) {
        return [];
      }
      const samedir = minAxis.dot(polygon.center.sub(circle2.center));
      minAxis = samedir < 0 ? minAxis.negate() : minAxis;
      const point2 = circle2.getFurthestPoint(minAxis);
      const xf2 = (_b = (_a = circle2.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
      const local = xf2.applyInverse(point2);
      const normal = minAxis.normalize();
      const info = {
        collider: circle2,
        separation: -minAxis.size,
        axis: normal,
        point: point2,
        localPoint: local,
        side: polygon.findSide(normal.negate()),
        localSide: polygon.findLocalSide(normal.negate())
      };
      return [new CollisionContact(circle2, polygon, minAxis, normal, normal.perpendicular(), [point2], [local], info)];
    },
    CollideCircleEdge(circle2, edge) {
      const cc2 = circle2.center;
      const edgeWorld = edge.asLine();
      const e2 = edgeWorld.end.sub(edgeWorld.begin);
      const u2 = e2.dot(edgeWorld.end.sub(cc2));
      const v2 = e2.dot(cc2.sub(edgeWorld.begin));
      const side = edge.asLine();
      const localSide = edge.asLocalLine();
      if (v2 <= 0) {
        const da2 = edgeWorld.begin.sub(cc2);
        const dda = da2.dot(da2);
        if (dda > circle2.radius * circle2.radius) {
          return [];
        }
        const normal2 = da2.normalize();
        const separation2 = circle2.radius - Math.sqrt(dda);
        const info2 = {
          collider: circle2,
          separation: separation2,
          axis: normal2,
          point: side.begin,
          side,
          localSide
        };
        return [
          new CollisionContact(circle2, edge, normal2.scale(separation2), normal2, normal2.perpendicular(), [side.begin], [localSide.begin], info2)
        ];
      }
      if (u2 <= 0) {
        const db2 = edgeWorld.end.sub(cc2);
        const ddb = db2.dot(db2);
        if (ddb > circle2.radius * circle2.radius) {
          return [];
        }
        const normal2 = db2.normalize();
        const separation2 = circle2.radius - Math.sqrt(ddb);
        const info2 = {
          collider: circle2,
          separation: separation2,
          axis: normal2,
          point: side.end,
          side,
          localSide
        };
        return [
          new CollisionContact(circle2, edge, normal2.scale(separation2), normal2, normal2.perpendicular(), [side.end], [localSide.end], info2)
        ];
      }
      const den = e2.dot(e2);
      const pointOnEdge = edgeWorld.begin.scale(u2).add(edgeWorld.end.scale(v2)).scale(1 / den);
      const d2 = cc2.sub(pointOnEdge);
      const dd2 = d2.dot(d2);
      if (dd2 > circle2.radius * circle2.radius) {
        return [];
      }
      let normal = e2.perpendicular();
      if (normal.dot(cc2.sub(edgeWorld.begin)) < 0) {
        normal.x = -normal.x;
        normal.y = -normal.y;
      }
      normal = normal.normalize();
      const separation = circle2.radius - Math.sqrt(dd2);
      const mvt = normal.scale(separation);
      const info = {
        collider: circle2,
        separation,
        axis: normal,
        point: pointOnEdge,
        side,
        localSide
      };
      return [
        new CollisionContact(circle2, edge, mvt, normal.negate(), normal.negate().perpendicular(), [pointOnEdge], [pointOnEdge.sub(edge.worldPos)], info)
      ];
    },
    CollideEdgeEdge() {
      return [];
    },
    CollidePolygonEdge(polygon, edge) {
      var _a;
      const pc2 = polygon.center;
      const ec2 = edge.center;
      const dir = ec2.sub(pc2).normalize();
      const linePoly = new PolygonCollider({
        points: [edge.begin, edge.end, edge.end.add(dir.scale(100)), edge.begin.add(dir.scale(100))],
        offset: edge.offset
      });
      linePoly.owner = edge.owner;
      const tx = (_a = edge.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
      if (tx) {
        linePoly.update(edge.owner.get(TransformComponent).get());
      }
      const contact = this.CollidePolygonPolygon(polygon, linePoly);
      if (contact.length) {
        contact[0].colliderB = edge;
        contact[0].id = Pair.calculatePairHash(polygon.id, edge.id);
      }
      return contact;
    },
    CollidePolygonPolygon(polyA, polyB) {
      var _a, _b, _c, _d;
      const separationA = SeparatingAxis.findPolygonPolygonSeparation(polyA, polyB);
      if (separationA.separation > 0) {
        return [];
      }
      const separationB = SeparatingAxis.findPolygonPolygonSeparation(polyB, polyA);
      if (separationB.separation > 0) {
        return [];
      }
      const separation = separationA.separation > separationB.separation ? separationA : separationB;
      const other = separation.collider === polyA ? polyB : polyA;
      const incident = other.findSide(separation.axis.negate());
      const reference = separation.side;
      const refDir = reference.dir().normalize();
      const clipRight = incident.clip(refDir.negate(), -refDir.dot(reference.begin));
      let clipLeft = null;
      if (clipRight) {
        clipLeft = clipRight.clip(refDir, refDir.dot(reference.end));
      }
      if (clipLeft) {
        const points = clipLeft.getPoints().filter((p2) => {
          return reference.below(p2);
        });
        let normal = separation.axis;
        let tangent = normal.perpendicular();
        if (polyB.center.sub(polyA.center).dot(normal) < 0) {
          normal = normal.negate();
          tangent = normal.perpendicular();
        }
        let localPoints = [];
        if (separation.collider === polyA) {
          const xf2 = (_b = (_a = polyB.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
          localPoints = points.map((p2) => xf2.applyInverse(p2));
        } else {
          const xf2 = (_d = (_c = polyA.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();
          localPoints = points.map((p2) => xf2.applyInverse(p2));
        }
        return [new CollisionContact(polyA, polyB, normal.scale(-separation.separation), normal, tangent, points, localPoints, separation)];
      }
      return [];
    },
    FindContactSeparation(contact, localPoint) {
      var _a, _b, _c, _d;
      const shapeA = contact.colliderA;
      const txA = (_b = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
      const shapeB = contact.colliderB;
      const txB = (_d = (_c = contact.colliderB.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();
      if (shapeA instanceof CircleCollider && shapeB instanceof CircleCollider) {
        const combinedRadius = shapeA.radius + shapeB.radius;
        const distance2 = txA.pos.distance(txB.pos);
        const separation = combinedRadius - distance2;
        return -separation;
      }
      if (shapeA instanceof PolygonCollider && shapeB instanceof PolygonCollider) {
        if (contact.info.localSide) {
          let side;
          let worldPoint;
          if (contact.info.collider === shapeA) {
            side = new LineSegment(txA.apply(contact.info.localSide.begin), txA.apply(contact.info.localSide.end));
            worldPoint = txB.apply(localPoint);
          } else {
            side = new LineSegment(txB.apply(contact.info.localSide.begin), txB.apply(contact.info.localSide.end));
            worldPoint = txA.apply(localPoint);
          }
          return side.distanceToPoint(worldPoint, true);
        }
      }
      if (shapeA instanceof PolygonCollider && shapeB instanceof CircleCollider || shapeB instanceof PolygonCollider && shapeA instanceof CircleCollider) {
        const worldPoint = txA.apply(localPoint);
        if (contact.info.side) {
          return contact.info.side.distanceToPoint(worldPoint, true);
        }
      }
      if (shapeA instanceof EdgeCollider && shapeB instanceof PolygonCollider || shapeB instanceof EdgeCollider && shapeA instanceof PolygonCollider) {
        let worldPoint;
        if (contact.info.collider === shapeA) {
          worldPoint = txB.apply(localPoint);
        } else {
          worldPoint = txA.apply(localPoint);
        }
        if (contact.info.side) {
          return contact.info.side.distanceToPoint(worldPoint, true);
        }
      }
      if (shapeA instanceof CircleCollider && shapeB instanceof EdgeCollider || shapeB instanceof CircleCollider && shapeA instanceof EdgeCollider) {
        const worldPoint = txB.apply(localPoint);
        let circlePoint;
        if (shapeA instanceof CircleCollider) {
          circlePoint = shapeA.getFurthestPoint(contact.normal);
        }
        const dist = worldPoint.distance(circlePoint);
        if (contact.info.side) {
          return dist > 0 ? -dist : 0;
        }
      }
      return 0;
    }
  };
  class EdgeCollider extends Collider {
    constructor(options) {
      var _a;
      super();
      this._globalMatrix = AffineMatrix.identity();
      this.begin = options.begin || Vector.Zero;
      this.end = options.end || Vector.Zero;
      this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
    }
    /**
     * Returns a clone of this Edge, not associated with any collider
     */
    clone() {
      return new EdgeCollider({
        begin: this.begin.clone(),
        end: this.end.clone()
      });
    }
    get worldPos() {
      var _a;
      const tx = this._transform;
      return (_a = tx === null || tx === void 0 ? void 0 : tx.globalPos.add(this.offset)) !== null && _a !== void 0 ? _a : this.offset;
    }
    /**
     * Get the center of the collision area in world coordinates
     */
    get center() {
      const begin = this._getTransformedBegin();
      const end = this._getTransformedEnd();
      const pos = begin.average(end);
      return pos;
    }
    _getTransformedBegin() {
      return this._globalMatrix.multiply(this.begin);
    }
    _getTransformedEnd() {
      return this._globalMatrix.multiply(this.end);
    }
    /**
     * Returns the slope of the line in the form of a vector
     */
    getSlope() {
      const begin = this._getTransformedBegin();
      const end = this._getTransformedEnd();
      const distance2 = begin.distance(end);
      return end.sub(begin).scale(1 / distance2);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
      const begin = this._getTransformedBegin();
      const end = this._getTransformedEnd();
      const distance2 = begin.distance(end);
      return distance2;
    }
    /**
     * Tests if a point is contained in this collision area
     */
    contains() {
      return false;
    }
    /**
     * @inheritdoc
     */
    rayCast(ray, max = Infinity) {
      const numerator = this._getTransformedBegin().sub(ray.pos);
      if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {
        return null;
      }
      const divisor = ray.dir.cross(this.getSlope());
      if (divisor === 0) {
        return null;
      }
      const t2 = numerator.cross(this.getSlope()) / divisor;
      if (t2 >= 0 && t2 <= max) {
        const u2 = numerator.cross(ray.dir) / divisor / this.getLength();
        if (u2 >= 0 && u2 <= 1) {
          return ray.getPoint(t2);
        }
      }
      return null;
    }
    /**
     * Returns the closes line between this and another collider, from this -> collider
     * @param shape
     */
    getClosestLineBetween(shape) {
      if (shape instanceof CircleCollider) {
        return ClosestLineJumpTable.CircleEdgeClosestLine(shape, this);
      } else if (shape instanceof PolygonCollider) {
        return ClosestLineJumpTable.PolygonEdgeClosestLine(shape, this).flip();
      } else if (shape instanceof EdgeCollider) {
        return ClosestLineJumpTable.EdgeEdgeClosestLine(this, shape);
      } else {
        throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
      }
    }
    /**
     * @inheritdoc
     */
    collide(shape) {
      if (shape instanceof CircleCollider) {
        return CollisionJumpTable.CollideCircleEdge(shape, this);
      } else if (shape instanceof PolygonCollider) {
        return CollisionJumpTable.CollidePolygonEdge(shape, this);
      } else if (shape instanceof EdgeCollider) {
        return CollisionJumpTable.CollideEdgeEdge();
      } else {
        throw new Error(`Edge could not collide with unknown CollisionShape ${typeof shape}`);
      }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
      const transformedBegin = this._getTransformedBegin();
      const transformedEnd = this._getTransformedEnd();
      if (direction.dot(transformedBegin) > 0) {
        return transformedBegin;
      } else {
        return transformedEnd;
      }
    }
    _boundsFromBeginEnd(begin, end, padding = 10) {
      return new BoundingBox(Math.min(begin.x, end.x) - padding, Math.min(begin.y, end.y) - padding, Math.max(begin.x, end.x) + padding, Math.max(begin.y, end.y) + padding);
    }
    /**
     * Get the axis aligned bounding box for the edge collider in world space
     */
    get bounds() {
      const transformedBegin = this._getTransformedBegin();
      const transformedEnd = this._getTransformedEnd();
      return this._boundsFromBeginEnd(transformedBegin, transformedEnd);
    }
    /**
     * Get the axis aligned bounding box for the edge collider in local space
     */
    get localBounds() {
      return this._boundsFromBeginEnd(this.begin, this.end);
    }
    /**
     * Returns this edge represented as a line in world coordinates
     */
    asLine() {
      return new LineSegment(this._getTransformedBegin(), this._getTransformedEnd());
    }
    /**
     * Return this edge as a line in local line coordinates (relative to the position)
     */
    asLocalLine() {
      return new LineSegment(this.begin, this.end);
    }
    /**
     * Get the axis associated with the edge
     */
    get axes() {
      const e2 = this._getTransformedEnd().sub(this._getTransformedBegin());
      const edgeNormal = e2.normal();
      const axes = [];
      axes.push(edgeNormal);
      axes.push(edgeNormal.negate());
      axes.push(edgeNormal.normal());
      axes.push(edgeNormal.normal().negate());
      return axes;
    }
    /**
     * Get the moment of inertia for an edge
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
      const length = this.end.sub(this.begin).distance() / 2;
      return mass * length * length;
    }
    /**
     * @inheritdoc
     */
    update(transform) {
      var _a;
      this._transform = transform;
      const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;
      globalMat.clone(this._globalMatrix);
      this._globalMatrix.translate(this.offset.x, this.offset.y);
    }
    /**
     * Project the edge along a specified axis
     */
    project(axis) {
      const scalars = [];
      const points = [this._getTransformedBegin(), this._getTransformedEnd()];
      const len = points.length;
      for (let i2 = 0; i2 < len; i2++) {
        scalars.push(points[i2].dot(axis));
      }
      return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    debug(ex, color2) {
      const begin = this._getTransformedBegin();
      const end = this._getTransformedEnd();
      ex.drawLine(begin, end, color2, 2);
      ex.drawCircle(begin, 2, color2);
      ex.drawCircle(end, 2, color2);
    }
  }
  class PolygonCollider extends Collider {
    /**
     * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.
     * Excalibur stores these in counter-clockwise order
     */
    set points(points) {
      this._localBoundsDirty = true;
      this._localSidesDirty = true;
      this._sidesDirty = true;
      this._points = points;
    }
    /**
     * Points in the polygon in order around the perimeter in local coordinates. These are relative from the body transform position.
     * Excalibur stores these in counter-clockwise order
     */
    get points() {
      return this._points;
    }
    constructor(options) {
      var _a, _b;
      super();
      this._logger = Logger2.getInstance();
      this._transformedPoints = [];
      this._sides = [];
      this._localSides = [];
      this._globalMatrix = AffineMatrix.identity();
      this._transformedPointsDirty = true;
      this._sidesDirty = true;
      this._localSidesDirty = true;
      this._localBoundsDirty = true;
      this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
      this._globalMatrix.translate(this.offset.x, this.offset.y);
      this.points = (_b = options.points) !== null && _b !== void 0 ? _b : [];
      const counterClockwise = this._isCounterClockwiseWinding(this.points);
      if (!counterClockwise) {
        this.points.reverse();
      }
      if (!this.isConvex()) {
        this._logger.warn("Excalibur only supports convex polygon colliders and will not behave properly.Call PolygonCollider.triangulate() to build a new collider composed of smaller convex triangles");
      }
      this._calculateTransformation();
    }
    _isCounterClockwiseWinding(points) {
      let sum = 0;
      for (let i2 = 0; i2 < points.length; i2++) {
        sum += (points[(i2 + 1) % points.length].x - points[i2].x) * (points[(i2 + 1) % points.length].y + points[i2].y);
      }
      return sum < 0;
    }
    /**
     * Returns if the polygon collider is convex, Excalibur does not handle non-convex collision shapes.
     * Call [[Polygon.triangulate]] to generate a [[CompositeCollider]] from this non-convex shape
     */
    isConvex() {
      if (this.points.length < 3) {
        return false;
      }
      let oldPoint = this.points[this.points.length - 2];
      let newPoint = this.points[this.points.length - 1];
      let direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);
      let oldDirection = 0;
      let orientation = 0;
      let angleSum = 0;
      for (const [i2, point2] of this.points.entries()) {
        oldPoint = newPoint;
        oldDirection = direction;
        newPoint = point2;
        direction = Math.atan2(newPoint.y - oldPoint.y, newPoint.x - oldPoint.x);
        if (oldPoint.equals(newPoint)) {
          return false;
        }
        let angle = direction - oldDirection;
        if (angle <= -Math.PI) {
          angle += Math.PI * 2;
        } else if (angle > Math.PI) {
          angle -= Math.PI * 2;
        }
        if (i2 === 0) {
          if (angle === 0) {
            return false;
          }
          orientation = angle > 0 ? 1 : -1;
        } else {
          if (orientation * angle <= 0) {
            return false;
          }
        }
        angleSum += angle;
      }
      return Math.abs(Math.round(angleSum / (Math.PI * 2))) === 1;
    }
    /**
     * Tessellates the polygon into a triangle fan as a [[CompositeCollider]] of triangle polygons
     */
    tessellate() {
      const polygons = [];
      for (let i2 = 1; i2 < this.points.length - 2; i2++) {
        polygons.push([this.points[0], this.points[i2 + 1], this.points[i2 + 2]]);
      }
      polygons.push([this.points[0], this.points[1], this.points[2]]);
      return new CompositeCollider(polygons.map((points) => Shape.Polygon(points)));
    }
    /**
     * Triangulate the polygon collider using the "Ear Clipping" algorithm.
     * Returns a new [[CompositeCollider]] made up of smaller triangles.
     */
    triangulate() {
      if (this.points.length < 3) {
        throw Error("Invalid polygon");
      }
      function getItem(index, list) {
        if (index >= list.length) {
          return list[index % list.length];
        } else if (index < 0) {
          return list[index % list.length + list.length];
        } else {
          return list[index];
        }
      }
      function isPointInTriangle(point2, a2, b2, c2) {
        const ab2 = b2.sub(a2);
        const bc2 = c2.sub(b2);
        const ca2 = a2.sub(c2);
        const ap = point2.sub(a2);
        const bp = point2.sub(b2);
        const cp = point2.sub(c2);
        const cross1 = ab2.cross(ap);
        const cross2 = bc2.cross(bp);
        const cross3 = ca2.cross(cp);
        if (cross1 > 0 || cross2 > 0 || cross3 > 0) {
          return false;
        }
        return true;
      }
      const triangles = [];
      const vertices = [...this.points];
      const indices = range(0, this.points.length - 1);
      while (indices.length > 3) {
        for (let i2 = 0; i2 < indices.length; i2++) {
          const a2 = indices[i2];
          const b2 = getItem(i2 - 1, indices);
          const c2 = getItem(i2 + 1, indices);
          const va2 = vertices[a2];
          const vb2 = vertices[b2];
          const vc2 = vertices[c2];
          const leftArm = vb2.sub(va2);
          const rightArm = vc2.sub(va2);
          const isConvex = rightArm.cross(leftArm) > 0;
          if (!isConvex) {
            continue;
          }
          let isEar = true;
          for (let j2 = 0; j2 < indices.length; j2++) {
            const vertIndex = indices[j2];
            if (vertIndex === a2 || vertIndex === b2 || vertIndex === c2) {
              continue;
            }
            const point2 = vertices[vertIndex];
            if (isPointInTriangle(point2, vb2, va2, vc2)) {
              isEar = false;
              break;
            }
          }
          if (isEar) {
            triangles.push([vb2, va2, vc2]);
            indices.splice(i2, 1);
            break;
          }
        }
      }
      triangles.push([vertices[indices[0]], vertices[indices[1]], vertices[indices[2]]]);
      return new CompositeCollider(triangles.map((points) => Shape.Polygon(points)));
    }
    /**
     * Returns a clone of this ConvexPolygon, not associated with any collider
     */
    clone() {
      return new PolygonCollider({
        offset: this.offset.clone(),
        points: this.points.map((p2) => p2.clone())
      });
    }
    /**
     * Returns the world position of the collider, which is the current body transform plus any defined offset
     */
    get worldPos() {
      if (this._transform) {
        return this._transform.pos.add(this.offset);
      }
      return this.offset;
    }
    /**
     * Get the center of the collider in world coordinates
     */
    get center() {
      return this.bounds.center;
    }
    /**
     * Calculates the underlying transformation from the body relative space to world space
     */
    _calculateTransformation() {
      const points = this.points;
      const len = points.length;
      this._transformedPoints.length = 0;
      for (let i2 = 0; i2 < len; i2++) {
        this._transformedPoints[i2] = this._globalMatrix.multiply(points[i2].clone());
      }
    }
    /**
     * Gets the points that make up the polygon in world space, from actor relative space (if specified)
     */
    getTransformedPoints() {
      if (this._transformedPointsDirty) {
        this._calculateTransformation();
        this._transformedPointsDirty = false;
      }
      return this._transformedPoints;
    }
    /**
     * Gets the sides of the polygon in world space
     */
    getSides() {
      if (this._sidesDirty) {
        const lines = [];
        const points = this.getTransformedPoints();
        const len = points.length;
        for (let i2 = 0; i2 < len; i2++) {
          lines.push(new LineSegment(points[i2], points[(i2 + 1) % len]));
        }
        this._sides = lines;
        this._sidesDirty = false;
      }
      return this._sides;
    }
    /**
     * Returns the local coordinate space sides
     */
    getLocalSides() {
      if (this._localSidesDirty) {
        const lines = [];
        const points = this.points;
        const len = points.length;
        for (let i2 = 0; i2 < len; i2++) {
          lines.push(new LineSegment(points[i2], points[(i2 + 1) % len]));
        }
        this._localSides = lines;
        this._localSidesDirty = false;
      }
      return this._localSides;
    }
    /**
     * Given a direction vector find the world space side that is most in that direction
     * @param direction
     */
    findSide(direction) {
      const sides = this.getSides();
      let bestSide = sides[0];
      let maxDistance = -Number.MAX_VALUE;
      for (let side = 0; side < sides.length; side++) {
        const currentSide = sides[side];
        const sideNormal = currentSide.normal();
        const mostDirection = sideNormal.dot(direction);
        if (mostDirection > maxDistance) {
          bestSide = currentSide;
          maxDistance = mostDirection;
        }
      }
      return bestSide;
    }
    /**
     * Given a direction vector find the local space side that is most in that direction
     * @param direction
     */
    findLocalSide(direction) {
      const sides = this.getLocalSides();
      let bestSide = sides[0];
      let maxDistance = -Number.MAX_VALUE;
      for (let side = 0; side < sides.length; side++) {
        const currentSide = sides[side];
        const sideNormal = currentSide.normal();
        const mostDirection = sideNormal.dot(direction);
        if (mostDirection > maxDistance) {
          bestSide = currentSide;
          maxDistance = mostDirection;
        }
      }
      return bestSide;
    }
    /**
     * Get the axis associated with the convex polygon
     */
    get axes() {
      const axes = [];
      const sides = this.getSides();
      for (let i2 = 0; i2 < sides.length; i2++) {
        axes.push(sides[i2].normal());
      }
      return axes;
    }
    /**
     * Updates the transform for the collision geometry
     *
     * Collision geometry (points/bounds) will not change until this is called.
     * @param transform
     */
    update(transform) {
      var _a;
      if (transform) {
        this._transform = transform;
        this._transformedPointsDirty = true;
        this._sidesDirty = true;
        const globalMat = (_a = transform.matrix) !== null && _a !== void 0 ? _a : this._globalMatrix;
        globalMat.clone(this._globalMatrix);
        this._globalMatrix.translate(this.offset.x, this.offset.y);
      }
    }
    /**
     * Tests if a point is contained in this collider in world space
     */
    contains(point2) {
      const testRay = new Ray(point2, new Vector(1, 0));
      const intersectCount = this.getSides().reduce(function(accum, side) {
        if (testRay.intersect(side) >= 0) {
          return accum + 1;
        }
        return accum;
      }, 0);
      if (intersectCount % 2 === 0) {
        return false;
      }
      return true;
    }
    getClosestLineBetween(collider) {
      if (collider instanceof CircleCollider) {
        return ClosestLineJumpTable.PolygonCircleClosestLine(this, collider);
      } else if (collider instanceof PolygonCollider) {
        return ClosestLineJumpTable.PolygonPolygonClosestLine(this, collider);
      } else if (collider instanceof EdgeCollider) {
        return ClosestLineJumpTable.PolygonEdgeClosestLine(this, collider);
      } else {
        throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
      }
    }
    /**
     * Returns a collision contact if the 2 colliders collide, otherwise collide will
     * return null.
     * @param collider
     */
    collide(collider) {
      if (collider instanceof CircleCollider) {
        return CollisionJumpTable.CollideCirclePolygon(collider, this);
      } else if (collider instanceof PolygonCollider) {
        return CollisionJumpTable.CollidePolygonPolygon(this, collider);
      } else if (collider instanceof EdgeCollider) {
        return CollisionJumpTable.CollidePolygonEdge(this, collider);
      } else {
        throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
      }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
      const pts = this.getTransformedPoints();
      let furthestPoint = null;
      let maxDistance = -Number.MAX_VALUE;
      for (let i2 = 0; i2 < pts.length; i2++) {
        const distance2 = direction.dot(pts[i2]);
        if (distance2 > maxDistance) {
          maxDistance = distance2;
          furthestPoint = pts[i2];
        }
      }
      return furthestPoint;
    }
    /**
     * Find the local point on the collider furthest in the direction specified
     * @param direction
     */
    getFurthestLocalPoint(direction) {
      const pts = this.points;
      let furthestPoint = pts[0];
      let maxDistance = -Number.MAX_VALUE;
      for (let i2 = 0; i2 < pts.length; i2++) {
        const distance2 = direction.dot(pts[i2]);
        if (distance2 > maxDistance) {
          maxDistance = distance2;
          furthestPoint = pts[i2];
        }
      }
      return furthestPoint;
    }
    /**
     * Finds the closes face to the point using perpendicular distance
     * @param point point to test against polygon
     */
    getClosestFace(point2) {
      const sides = this.getSides();
      let min = Number.POSITIVE_INFINITY;
      let faceIndex = -1;
      let distance2 = -1;
      for (let i2 = 0; i2 < sides.length; i2++) {
        const dist = sides[i2].distanceToPoint(point2);
        if (dist < min) {
          min = dist;
          faceIndex = i2;
          distance2 = dist;
        }
      }
      if (faceIndex !== -1) {
        return {
          distance: sides[faceIndex].normal().scale(distance2),
          face: sides[faceIndex]
        };
      }
      return null;
    }
    /**
     * Get the axis aligned bounding box for the polygon collider in world coordinates
     */
    get bounds() {
      return this.localBounds.transform(this._globalMatrix);
    }
    /**
     * Get the axis aligned bounding box for the polygon collider in local coordinates
     */
    get localBounds() {
      if (this._localBoundsDirty) {
        this._localBounds = BoundingBox.fromPoints(this.points);
        this._localBoundsDirty = false;
      }
      return this._localBounds;
    }
    /**
     * Get the moment of inertia for an arbitrary polygon
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
      if (this._cachedMass === mass && this._cachedInertia) {
        return this._cachedInertia;
      }
      let numerator = 0;
      let denominator = 0;
      const points = this.points;
      for (let i2 = 0; i2 < points.length; i2++) {
        const iplusone = (i2 + 1) % points.length;
        const crossTerm = points[iplusone].cross(points[i2]);
        numerator += crossTerm * (points[i2].dot(points[i2]) + points[i2].dot(points[iplusone]) + points[iplusone].dot(points[iplusone]));
        denominator += crossTerm;
      }
      this._cachedMass = mass;
      return this._cachedInertia = mass / 6 * (numerator / denominator);
    }
    /**
     * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.
     */
    rayCast(ray, max = Infinity) {
      const sides = this.getSides();
      const len = sides.length;
      let minContactTime = Number.MAX_VALUE;
      let contactIndex = -1;
      for (let i2 = 0; i2 < len; i2++) {
        const contactTime = ray.intersect(sides[i2]);
        if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {
          minContactTime = contactTime;
          contactIndex = i2;
        }
      }
      if (contactIndex >= 0) {
        return ray.getPoint(minContactTime);
      }
      return null;
    }
    /**
     * Project the edges of the polygon along a specified axis
     */
    project(axis) {
      const points = this.getTransformedPoints();
      const len = points.length;
      let min = Number.MAX_VALUE;
      let max = -Number.MAX_VALUE;
      for (let i2 = 0; i2 < len; i2++) {
        const scalar = points[i2].dot(axis);
        min = Math.min(min, scalar);
        max = Math.max(max, scalar);
      }
      return new Projection(min, max);
    }
    debug(ex, color2) {
      const firstPoint = this.getTransformedPoints()[0];
      const points = [firstPoint, ...this.getTransformedPoints(), firstPoint];
      for (let i2 = 0; i2 < points.length - 1; i2++) {
        ex.drawLine(points[i2], points[i2 + 1], color2, 2);
        ex.drawCircle(points[i2], 2, color2);
        ex.drawCircle(points[i2 + 1], 2, color2);
      }
    }
  }
  class Shape {
    /**
     * Creates a box collider, under the hood defines a [[PolygonCollider]] collider
     * @param width Width of the box
     * @param height Height of the box
     * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Box(width, height, anchor = Vector.Half, offset = Vector.Zero) {
      return new PolygonCollider({
        points: new BoundingBox(-width * anchor.x, -height * anchor.y, width - width * anchor.x, height - height * anchor.y).getPoints(),
        offset
      });
    }
    /**
     * Creates a new [[PolygonCollider|arbitrary polygon]] collider
     *
     * PolygonColliders are useful for creating convex polygon shapes
     * @param points Points specified in counter clockwise
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Polygon(points, offset = Vector.Zero) {
      return new PolygonCollider({
        points,
        offset
      });
    }
    /**
     * Creates a new [[CircleCollider|circle]] collider
     *
     * Circle colliders are useful for balls, or to make collisions more forgiving on sharp edges
     * @param radius Radius of the circle collider
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Circle(radius, offset = Vector.Zero) {
      return new CircleCollider({
        radius,
        offset
      });
    }
    /**
     * Creates a new [[EdgeCollider|edge]] collider
     *
     * Edge colliders are useful for  floors, walls, and other barriers
     * @param begin Beginning of the edge in local coordinates to the collider
     * @param end Ending of the edge in local coordinates to the collider
     */
    static Edge(begin, end) {
      return new EdgeCollider({
        begin,
        end
      });
    }
    /**
     * Creates a new capsule shaped [[CompositeCollider]] using 2 circles and a box
     *
     * Capsule colliders are useful for platformers with incline or jagged floors to have a smooth
     * player experience.
     *
     * @param width
     * @param height
     * @param offset Optional offset
     */
    static Capsule(width, height, offset = Vector.Zero) {
      const logger = Logger2.getInstance();
      if (width === height) {
        logger.warn("A capsule collider with equal width and height is a circle, consider using a ex.Shape.Circle or ex.CircleCollider");
      }
      const vertical = height >= width;
      if (vertical) {
        const capsule = new CompositeCollider([
          Shape.Circle(width / 2, vec(0, -height / 2 + width / 2).add(offset)),
          Shape.Box(width, height - width, Vector.Half, offset),
          Shape.Circle(width / 2, vec(0, height / 2 - width / 2).add(offset))
        ]);
        return capsule;
      } else {
        const capsule = new CompositeCollider([
          Shape.Circle(height / 2, vec(-width / 2 + height / 2, 0).add(offset)),
          Shape.Box(width - height, height, Vector.Half, offset),
          Shape.Circle(height / 2, vec(width / 2 - height / 2, 0).add(offset))
        ]);
        return capsule;
      }
    }
  }
  class ColliderComponent extends Component {
    constructor(collider) {
      super();
      this.type = "ex.collider";
      this.events = new EventEmitter2();
      this.$colliderAdded = new Observable();
      this.$colliderRemoved = new Observable();
      this.set(collider);
    }
    /**
     * Get the current collider geometry
     */
    get() {
      return this._collider;
    }
    /**
     * Set the collider geometry
     * @param collider
     * @returns the collider you set
     */
    set(collider) {
      this.clear();
      if (collider) {
        this._collider = collider;
        this._collider.owner = this.owner;
        collider.events.pipe(this.events);
        this.$colliderAdded.notifyAll(collider);
        this.update();
      }
      return collider;
    }
    /**
     * Remove collider geometry from collider component
     */
    clear() {
      if (this._collider) {
        this._collider.events.unpipe(this.events);
        this.$colliderRemoved.notifyAll(this._collider);
        this._collider.owner = null;
        this._collider = null;
      }
    }
    clone() {
      const clone = new ColliderComponent(this._collider.clone());
      return clone;
    }
    /**
     * Return world space bounds
     */
    get bounds() {
      var _a, _b;
      return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox();
    }
    /**
     * Return local space bounds
     */
    get localBounds() {
      var _a, _b;
      return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox();
    }
    /**
     * Update the collider's transformed geometry
     */
    update() {
      var _a;
      const tx = (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
      if (this._collider) {
        this._collider.owner = this.owner;
        if (tx) {
          this._collider.update(tx.get());
        }
      }
    }
    /**
     * Collide component with another
     * @param other
     */
    collide(other) {
      let colliderA = this._collider;
      let colliderB = other._collider;
      if (!colliderA || !colliderB) {
        return [];
      }
      let flipped = false;
      if (colliderB instanceof CompositeCollider) {
        colliderA = colliderB;
        colliderB = this._collider;
        flipped = true;
      }
      if (this._collider) {
        const contacts = colliderA.collide(colliderB);
        if (contacts) {
          if (flipped) {
            contacts.forEach((contact) => {
              contact.mtv = contact.mtv.negate();
              contact.normal = contact.normal.negate();
              contact.tangent = contact.normal.perpendicular();
              contact.colliderA = this._collider;
              contact.colliderB = other._collider;
            });
          }
          return contacts;
        }
        return [];
      }
      return [];
    }
    onAdd(entity) {
      if (this._collider) {
        this.update();
      }
      this.events.on("precollision", (evt) => {
        const precollision = evt;
        entity.events.emit("precollision", new PreCollisionEvent(precollision.target.owner, precollision.other.owner, precollision.side, precollision.intersection));
      });
      this.events.on("postcollision", (evt) => {
        const postcollision = evt;
        entity.events.emit("postcollision", new PostCollisionEvent(postcollision.target.owner, postcollision.other.owner, postcollision.side, postcollision.intersection));
      });
      this.events.on("collisionstart", (evt) => {
        const start = evt;
        entity.events.emit("collisionstart", new CollisionStartEvent(start.target.owner, start.other.owner, start.contact));
      });
      this.events.on("collisionend", (evt) => {
        const end = evt;
        entity.events.emit("collisionend", new CollisionEndEvent(end.target.owner, end.other.owner));
      });
    }
    onRemove() {
      this.events.clear();
      this.$colliderRemoved.notifyAll(this._collider);
    }
    /**
     * Sets up a box geometry based on the current bounds of the associated actor of this physics body.
     *
     * If no width/height are specified the body will attempt to use the associated actor's width/height.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useBoxCollider(width, height, anchor = Vector.Half, center = Vector.Zero) {
      const collider = Shape.Box(width, height, anchor, center);
      return this.set(collider);
    }
    /**
     * Sets up a [[PolygonCollider|polygon]] collision geometry based on a list of of points relative
     *  to the anchor of the associated actor
     * of this physics body.
     *
     * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    usePolygonCollider(points, center = Vector.Zero) {
      const poly = Shape.Polygon(points, center);
      return this.set(poly);
    }
    /**
     * Sets up a [[Circle|circle collision geometry]] as the only collider with a specified radius in pixels.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useCircleCollider(radius, center = Vector.Zero) {
      const collider = Shape.Circle(radius, center);
      return this.set(collider);
    }
    /**
     * Sets up an [[Edge|edge collision geometry]] with a start point and an end point relative to the anchor of the associated actor
     * of this physics body.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useEdgeCollider(begin, end) {
      const collider = Shape.Edge(begin, end);
      return this.set(collider);
    }
    /**
     * Setups up a [[CompositeCollider]] which can define any arbitrary set of excalibur colliders
     * @param colliders
     */
    useCompositeCollider(colliders) {
      return this.set(new CompositeCollider(colliders));
    }
  }
  var DegreeOfFreedom;
  (function(DegreeOfFreedom2) {
    DegreeOfFreedom2["Rotation"] = "rotation";
    DegreeOfFreedom2["X"] = "x";
    DegreeOfFreedom2["Y"] = "y";
  })(DegreeOfFreedom || (DegreeOfFreedom = {}));
  class BodyComponent extends Component {
    constructor(options) {
      var _a, _b, _c;
      super();
      this.type = "ex.body";
      this.dependencies = [TransformComponent, MotionComponent];
      this.id = createId("body", BodyComponent._ID++);
      this.events = new EventEmitter2();
      this._oldTransform = new Transform();
      this.__oldTransformCaptured = false;
      this.enableFixedUpdateInterpolate = true;
      this.collisionType = CollisionType.PreventCollision;
      this.group = CollisionGroup.All;
      this._mass = Physics.defaultMass;
      this.sleepMotion = Physics.sleepEpsilon * 5;
      this.canSleep = Physics.bodiesCanSleepByDefault;
      this._sleeping = false;
      this.bounciness = 0.2;
      this.friction = 0.99;
      this.useGravity = true;
      this.limitDegreeOfFreedom = [];
      this.oldVel = new Vector(0, 0);
      this.oldAcc = Vector.Zero;
      if (options) {
        this.collisionType = (_a = options.type) !== null && _a !== void 0 ? _a : this.collisionType;
        this.group = (_b = options.group) !== null && _b !== void 0 ? _b : this.group;
        this.useGravity = (_c = options.useGravity) !== null && _c !== void 0 ? _c : this.useGravity;
      }
    }
    get matrix() {
      return this.transform.get().matrix;
    }
    get mass() {
      return this._mass;
    }
    set mass(newMass) {
      this._mass = newMass;
      this._cachedInertia = void 0;
      this._cachedInverseInertia = void 0;
    }
    /**
     * The inverse mass (1/mass) of the body. If [[CollisionType.Fixed]] this is 0, meaning "infinite" mass
     */
    get inverseMass() {
      return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.mass;
    }
    /**
     * Whether this body is sleeping or not
     */
    get sleeping() {
      return this._sleeping;
    }
    /**
     * Set the sleep state of the body
     * @param sleeping
     */
    setSleeping(sleeping) {
      this._sleeping = sleeping;
      if (!sleeping) {
        this.sleepMotion = Physics.sleepEpsilon * 5;
      } else {
        this.vel = Vector.Zero;
        this.acc = Vector.Zero;
        this.angularVelocity = 0;
        this.sleepMotion = 0;
      }
    }
    /**
     * Update body's [[BodyComponent.sleepMotion]] for the purpose of sleeping
     */
    updateMotion() {
      if (this._sleeping) {
        this.setSleeping(true);
      }
      const currentMotion = this.vel.size * this.vel.size + Math.abs(this.angularVelocity * this.angularVelocity);
      const bias = Physics.sleepBias;
      this.sleepMotion = bias * this.sleepMotion + (1 - bias) * currentMotion;
      this.sleepMotion = clamp2(this.sleepMotion, 0, 10 * Physics.sleepEpsilon);
      if (this.canSleep && this.sleepMotion < Physics.sleepEpsilon) {
        this.setSleeping(true);
      }
    }
    /**
     * Get the moment of inertia from the [[ColliderComponent]]
     */
    get inertia() {
      if (this._cachedInertia) {
        return this._cachedInertia;
      }
      const collider = this.owner.get(ColliderComponent);
      if (collider) {
        collider.$colliderAdded.subscribe(() => {
          this._cachedInertia = null;
        });
        collider.$colliderRemoved.subscribe(() => {
          this._cachedInertia = null;
        });
        const maybeCollider = collider.get();
        if (maybeCollider) {
          return this._cachedInertia = maybeCollider.getInertia(this.mass);
        }
      }
      return 0;
    }
    /**
     * Get the inverse moment of inertial from the [[ColliderComponent]]. If [[CollisionType.Fixed]] this is 0, meaning "infinite" mass
     */
    get inverseInertia() {
      if (this._cachedInverseInertia) {
        return this._cachedInverseInertia;
      }
      return this._cachedInverseInertia = this.collisionType === CollisionType.Fixed ? 0 : 1 / this.inertia;
    }
    /**
     * Returns if the owner is active
     */
    get active() {
      var _a;
      return !!((_a = this.owner) === null || _a === void 0 ? void 0 : _a.active);
    }
    /**
     * @deprecated Use globalP0s
     */
    get center() {
      return this.globalPos;
    }
    get transform() {
      var _a;
      return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
    }
    get motion() {
      var _a;
      return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(MotionComponent);
    }
    get pos() {
      return this.transform.pos;
    }
    set pos(val) {
      this.transform.pos = val;
    }
    /**
     * The (x, y) position of the actor this will be in the middle of the actor if the
     * [[Actor.anchor]] is set to (0.5, 0.5) which is default.
     * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).
     */
    get globalPos() {
      return this.transform.globalPos;
    }
    set globalPos(val) {
      this.transform.globalPos = val;
    }
    /**
     * The position of the actor last frame (x, y) in pixels
     */
    get oldPos() {
      return this._oldTransform.pos;
    }
    /**
     * The current velocity vector (vx, vy) of the actor in pixels/second
     */
    get vel() {
      return this.motion.vel;
    }
    set vel(val) {
      this.motion.vel = val;
    }
    /**
     * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may
     * be useful to simulate a gravitational effect.
     */
    get acc() {
      return this.motion.acc;
    }
    set acc(val) {
      this.motion.acc = val;
    }
    /**
     * The current torque applied to the actor
     */
    get torque() {
      return this.motion.torque;
    }
    set torque(val) {
      this.motion.torque = val;
    }
    /**
     * Gets/sets the rotation of the body from the last frame.
     */
    get oldRotation() {
      return this._oldTransform.rotation;
    }
    /**
     * The rotation of the body in radians
     */
    get rotation() {
      return this.transform.globalRotation;
    }
    set rotation(val) {
      this.transform.globalRotation = val;
    }
    /**
     * The scale vector of the actor
     */
    get scale() {
      return this.transform.globalScale;
    }
    set scale(val) {
      this.transform.globalScale = val;
    }
    /**
     * The scale of the actor last frame
     */
    get oldScale() {
      return this._oldTransform.scale;
    }
    /**
     * The scale rate of change of the actor in scale/second
     */
    get scaleFactor() {
      return this.motion.scaleFactor;
    }
    set scaleFactor(scaleFactor) {
      this.motion.scaleFactor = scaleFactor;
    }
    /**
     * Get the angular velocity in radians/second
     */
    get angularVelocity() {
      return this.motion.angularVelocity;
    }
    /**
     * Set the angular velocity in radians/second
     */
    set angularVelocity(value) {
      this.motion.angularVelocity = value;
    }
    /**
     * Apply a specific impulse to the body
     * @param point
     * @param impulse
     */
    applyImpulse(point2, impulse) {
      if (this.collisionType !== CollisionType.Active) {
        return;
      }
      const finalImpulse = impulse.scale(this.inverseMass);
      if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
        finalImpulse.x = 0;
      }
      if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
        finalImpulse.y = 0;
      }
      this.vel.addEqual(finalImpulse);
      if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
        const distanceFromCenter = point2.sub(this.globalPos);
        this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
      }
    }
    /**
     * Apply only linear impulse to the body
     * @param impulse
     */
    applyLinearImpulse(impulse) {
      if (this.collisionType !== CollisionType.Active) {
        return;
      }
      const finalImpulse = impulse.scale(this.inverseMass);
      if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
        finalImpulse.x = 0;
      }
      if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
        finalImpulse.y = 0;
      }
      this.vel = this.vel.add(finalImpulse);
    }
    /**
     * Apply only angular impulse to the body
     * @param point
     * @param impulse
     */
    applyAngularImpulse(point2, impulse) {
      if (this.collisionType !== CollisionType.Active) {
        return;
      }
      if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
        const distanceFromCenter = point2.sub(this.globalPos);
        this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
      }
    }
    /**
     * Sets the old versions of pos, vel, acc, and scale.
     */
    captureOldTransform() {
      this.__oldTransformCaptured = true;
      this.transform.get().clone(this._oldTransform);
      this.oldVel.setTo(this.vel.x, this.vel.y);
      this.oldAcc.setTo(this.acc.x, this.acc.y);
    }
    clone() {
      const component = super.clone();
      return component;
    }
  }
  BodyComponent._ID = 0;
  class AddedComponent {
    constructor(data) {
      this.data = data;
      this.type = "Component Added";
    }
  }
  function isAddedComponent(x2) {
    return !!x2 && x2.type === "Component Added";
  }
  class RemovedComponent {
    constructor(data) {
      this.data = data;
      this.type = "Component Removed";
    }
  }
  function isRemovedComponent(x2) {
    return !!x2 && x2.type === "Component Removed";
  }
  const EntityEvents = {
    Initialize: "initialize",
    PreUpdate: "preupdate",
    PostUpdate: "postupdate"
  };
  class Entity {
    constructor(components, name) {
      this.events = new EventEmitter2();
      this.id = Entity._ID++;
      this.scene = null;
      this._name = "anonymous";
      this.active = true;
      this._componentsToRemove = [];
      this._componentTypeToInstance = /* @__PURE__ */ new Map();
      this._componentStringToInstance = /* @__PURE__ */ new Map();
      this._tagsMemo = [];
      this._typesMemo = [];
      this.componentAdded$ = new Observable();
      this.componentRemoved$ = new Observable();
      this._parent = null;
      this.childrenAdded$ = new Observable();
      this.childrenRemoved$ = new Observable();
      this._children = [];
      this._isInitialized = false;
      this._setName(name);
      if (components) {
        for (const component of components) {
          this.addComponent(component);
        }
      }
    }
    _setName(name) {
      if (name) {
        this._name = name;
      }
    }
    get name() {
      return this._name;
    }
    /**
     * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.
     * If parented it will be removed from the parent when killed.
     */
    kill() {
      if (this.active) {
        this.active = false;
        this.unparent();
      }
    }
    isKilled() {
      return !this.active;
    }
    /**
     * Specifically get the tags on the entity from [[TagComponent]]
     */
    get tags() {
      return this._tagsMemo;
    }
    /**
     * Check if a tag exists on the entity
     * @param tag name to check for
     */
    hasTag(tag) {
      return this.tags.includes(tag);
    }
    /**
     * Adds a tag to an entity
     * @param tag
     * @returns Entity
     */
    addTag(tag) {
      return this.addComponent(new TagComponent(tag));
    }
    /**
     * Removes a tag on the entity
     *
     * Removals are deferred until the end of update
     * @param tag
     * @param force Remove component immediately, no deferred
     */
    removeTag(tag, force = false) {
      return this.removeComponent(tag, force);
    }
    /**
     * The types of the components on the Entity
     */
    get types() {
      return this._typesMemo;
    }
    _rebuildMemos() {
      this._tagsMemo = Array.from(this._componentStringToInstance.values()).filter((c2) => c2 instanceof TagComponent).map((c2) => c2.type);
      this._typesMemo = Array.from(this._componentStringToInstance.keys());
    }
    getComponents() {
      return Array.from(this._componentStringToInstance.values());
    }
    _notifyAddComponent(component) {
      this._rebuildMemos();
      const added = new AddedComponent({
        component,
        entity: this
      });
      this.componentAdded$.notifyAll(added);
    }
    _notifyRemoveComponent(component) {
      const removed = new RemovedComponent({
        component,
        entity: this
      });
      this.componentRemoved$.notifyAll(removed);
      this._rebuildMemos();
    }
    get parent() {
      return this._parent;
    }
    /**
     * Get the direct children of this entity
     */
    get children() {
      return this._children;
    }
    /**
     * Unparents this entity, if there is a parent. Otherwise it does nothing.
     */
    unparent() {
      if (this._parent) {
        this._parent.removeChild(this);
        this._parent = null;
      }
    }
    /**
     * Adds an entity to be a child of this entity
     * @param entity
     */
    addChild(entity) {
      if (entity.parent === null) {
        if (this.getAncestors().includes(entity)) {
          throw new Error("Cycle detected, cannot add entity");
        }
        this._children.push(entity);
        entity._parent = this;
        this.childrenAdded$.notifyAll(entity);
      } else {
        throw new Error("Entity already has a parent, cannot add without unparenting");
      }
      return this;
    }
    /**
     * Remove an entity from children if it exists
     * @param entity
     */
    removeChild(entity) {
      if (entity.parent === this) {
        removeItemFromArray(entity, this._children);
        entity._parent = null;
        this.childrenRemoved$.notifyAll(entity);
      }
      return this;
    }
    /**
     * Removes all children from this entity
     */
    removeAllChildren() {
      for (let i2 = this.children.length - 1; i2 >= 0; i2--) {
        this.removeChild(this.children[i2]);
      }
      return this;
    }
    /**
     * Returns a list of parent entities starting with the topmost parent. Includes the current entity.
     */
    getAncestors() {
      const result = [this];
      let current = this.parent;
      while (current) {
        result.push(current);
        current = current.parent;
      }
      return result.reverse();
    }
    /**
     * Returns a list of all the entities that descend from this entity. Includes the current entity.
     */
    getDescendants() {
      let result = [this];
      let queue = [this];
      while (queue.length > 0) {
        const curr = queue.pop();
        queue = queue.concat(curr.children);
        result = result.concat(curr.children);
      }
      return result;
    }
    /**
     * Creates a deep copy of the entity and a copy of all its components
     */
    clone() {
      const newEntity = new Entity();
      for (const c2 of this.types) {
        newEntity.addComponent(this.get(c2).clone());
      }
      for (const child of this.children) {
        newEntity.addChild(child.clone());
      }
      return newEntity;
    }
    /**
     * Adds a copy of all the components from another template entity as a "prefab"
     * @param templateEntity Entity to use as a template
     * @param force Force component replacement if it already exists on the target entity
     */
    addTemplate(templateEntity, force = false) {
      for (const c2 of templateEntity.getComponents()) {
        this.addComponent(c2.clone(), force);
      }
      for (const child of templateEntity.children) {
        this.addChild(child.clone().addTemplate(child));
      }
      return this;
    }
    /**
     * Adds a component to the entity
     * @param component Component or Entity to add copy of components from
     * @param force Optionally overwrite any existing components of the same type
     */
    addComponent(component, force = false) {
      if (this.has(component.type)) {
        if (force) {
          this.removeComponent(component, true);
        } else {
          return this;
        }
      }
      if (component.dependencies && component.dependencies.length) {
        for (const ctor of component.dependencies) {
          this.addComponent(new ctor());
        }
      }
      component.owner = this;
      const constuctorType = component.constructor;
      this._componentTypeToInstance.set(constuctorType, component);
      this._componentStringToInstance.set(component.type, component);
      if (component.onAdd) {
        component.onAdd(this);
      }
      this._notifyAddComponent(component);
      return this;
    }
    /**
     * Removes a component from the entity, by default removals are deferred to the end of entity update to avoid consistency issues
     *
     * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately
     * @param componentOrType
     * @param force
     */
    removeComponent(componentOrType, force = false) {
      if (force) {
        if (typeof componentOrType === "string") {
          this._removeComponentByType(componentOrType);
        } else if (componentOrType instanceof Component) {
          this._removeComponentByType(componentOrType.type);
        }
      } else {
        this._componentsToRemove.push(componentOrType);
      }
      return this;
    }
    clearComponents() {
      const components = this.getComponents();
      for (const c2 of components) {
        this.removeComponent(c2);
      }
    }
    _removeComponentByType(type) {
      if (this.has(type)) {
        const component = this.get(type);
        component.owner = null;
        if (component.onRemove) {
          component.onRemove(this);
        }
        const ctor = component.constructor;
        this._componentTypeToInstance.delete(ctor);
        this._componentStringToInstance.delete(component.type);
        this._notifyRemoveComponent(component);
      }
    }
    /**
     * @hidden
     * @internal
     */
    processComponentRemoval() {
      for (const componentOrType of this._componentsToRemove) {
        const type = typeof componentOrType === "string" ? componentOrType : componentOrType.type;
        this._removeComponentByType(type);
      }
      this._componentsToRemove.length = 0;
    }
    has(type) {
      if (typeof type === "string") {
        return this._componentStringToInstance.has(type);
      } else {
        return this._componentTypeToInstance.has(type);
      }
    }
    get(type) {
      if (typeof type === "string") {
        return this._componentStringToInstance.get(type);
      } else {
        return this._componentTypeToInstance.get(type);
      }
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
      return this._isInitialized;
    }
    /**
     * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * @internal
     */
    _initialize(engine) {
      if (!this.isInitialized) {
        this.onInitialize(engine);
        this.events.emit("initialize", new InitializeEvent(engine, this));
        this._isInitialized = true;
      }
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
      this.events.emit("preupdate", new PreUpdateEvent(engine, delta, this));
      this.onPreUpdate(engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
      this.events.emit("postupdate", new PostUpdateEvent(engine, delta, this));
      this.onPostUpdate(engine, delta);
    }
    /**
     * `onInitialize` is called before the first update of the entity. This method is meant to be
     * overridden.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(_engine) {
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an entity is updated.
     */
    onPreUpdate(_engine, _delta) {
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an entity is updated.
     */
    onPostUpdate(_engine, _delta) {
    }
    /**
     *
     * Entity update lifecycle, called internally
     *
     * @internal
     * @param engine
     * @param delta
     */
    update(engine, delta) {
      this._initialize(engine);
      this._preupdate(engine, delta);
      for (const child of this.children) {
        child.update(engine, delta);
      }
      this._postupdate(engine, delta);
    }
    emit(eventName, event) {
      this.events.emit(eventName, event);
    }
    on(eventName, handler) {
      return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
      return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
      this.events.off(eventName, handler);
    }
  }
  Entity._ID = 0;
  function hasGraphicsTick(graphic) {
    return !!graphic.tick;
  }
  class GraphicsLayer {
    constructor(_options, _graphics) {
      this._options = _options;
      this._graphics = _graphics;
      this.graphics = [];
    }
    get name() {
      return this._options.name;
    }
    hide(nameOrGraphic) {
      if (!nameOrGraphic) {
        this.graphics.length = 0;
      } else {
        let gfx = null;
        if (nameOrGraphic instanceof Graphic) {
          gfx = nameOrGraphic;
        } else {
          gfx = this._graphics.getGraphic(nameOrGraphic);
        }
        this.graphics = this.graphics.filter((g2) => g2.graphic !== gfx);
        this._graphics.recalculateBounds();
      }
    }
    /**
     * Show a graphic by name or instance at an offset, graphics are shown in the order in which `show()` is called.
     *
     * If `show()` is called multiple times for the same graphic it will be shown multiple times.
     * @param nameOrGraphic
     * @param options
     */
    show(nameOrGraphic, options) {
      options = { ...options };
      let gfx;
      if (nameOrGraphic instanceof Graphic) {
        gfx = this._graphics.copyGraphics ? nameOrGraphic.clone() : nameOrGraphic;
      } else {
        gfx = this._graphics.getGraphic(nameOrGraphic);
        if (!gfx) {
          Logger2.getInstance().error(`No such graphic added to component named ${nameOrGraphic}. These named graphics are available: `, this._graphics.getNames());
        }
      }
      if (gfx) {
        this.graphics.push({ graphic: gfx, options });
        this._graphics.recalculateBounds();
        return gfx;
      } else {
        return null;
      }
    }
    /**
     * Use a specific graphic, swap out any current graphics being shown
     * @param nameOrGraphic
     * @param options
     */
    use(nameOrGraphic, options) {
      options = { ...options };
      this.hide();
      return this.show(nameOrGraphic, options);
    }
    /**
     * Current order of the layer, higher numbers are on top, lower numbers are on the bottom.
     *
     * For example a layer with `order = -1` would be under a layer of `order = 1`
     */
    get order() {
      return this._options.order;
    }
    /**
     * Set the order of the layer, higher numbers are on top, lower numbers are on the bottom.
     *
     * For example a layer with `order = -1` would be under a layer of `order = 1`
     */
    set order(order) {
      this._options.order = order;
    }
    /**
     * Get or set the pixel offset from the layer anchor for all graphics in the layer
     */
    get offset() {
      var _a;
      return (_a = this._options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
    }
    set offset(value) {
      this._options.offset = value;
    }
    get currentKeys() {
      var _a;
      return (_a = this.name) !== null && _a !== void 0 ? _a : "anonymous";
    }
    clone(graphicsComponent) {
      const layer = new GraphicsLayer({ ...this._options }, graphicsComponent);
      layer.graphics = [...this.graphics.map((g2) => ({ graphic: g2.graphic.clone(), options: { ...g2.options } }))];
      return layer;
    }
  }
  class GraphicsLayers {
    constructor(_component) {
      this._component = _component;
      this._layers = [];
      this._layerMap = {};
      this.default = new GraphicsLayer({ name: "default", order: 0 }, _component);
      this._maybeAddLayer(this.default);
    }
    create(options) {
      const layer = new GraphicsLayer(options, this._component);
      return this._maybeAddLayer(layer);
    }
    get(name) {
      if (name) {
        return this._getLayer(name);
      }
      return this._layers;
    }
    currentKeys() {
      const graphicsLayerKeys = [];
      for (const layer of this._layers) {
        graphicsLayerKeys.push(layer.currentKeys);
      }
      return graphicsLayerKeys;
    }
    has(name) {
      return name in this._layerMap;
    }
    _maybeAddLayer(layer) {
      if (this._layerMap[layer.name]) {
        return this._layerMap[layer.name];
      }
      this._layerMap[layer.name] = layer;
      this._layers.push(layer);
      this._layers.sort((a2, b2) => a2.order - b2.order);
      return layer;
    }
    _getLayer(name) {
      return this._layerMap[name];
    }
    clone(graphicsComponent) {
      const layers = new GraphicsLayers(graphicsComponent);
      layers._layerMap = {};
      layers._layers = [];
      layers.default = this.default.clone(graphicsComponent);
      layers._maybeAddLayer(layers.default);
      const clonedLayers = this._layers.filter((l2) => l2.name !== "default").map((l2) => l2.clone(graphicsComponent));
      clonedLayers.forEach((layer) => layers._maybeAddLayer(layer));
      return layers;
    }
  }
  class GraphicsComponent extends Component {
    getGraphic(name) {
      return this._graphics[name];
    }
    /**
     * Get registered graphics names
     */
    getNames() {
      return Object.keys(this._graphics);
    }
    constructor(options) {
      super();
      this.type = "ex.graphics";
      this._graphics = {};
      this.visible = true;
      this.opacity = 1;
      this.offset = Vector.Zero;
      this.anchor = Vector.Half;
      this.flipHorizontal = false;
      this.flipVertical = false;
      this.copyGraphics = false;
      this._localBounds = null;
      options = {
        visible: this.visible,
        ...options
      };
      const { current, anchor, opacity, visible, graphics, offset, copyGraphics, onPreDraw, onPostDraw } = options;
      this._graphics = graphics || {};
      this.offset = offset !== null && offset !== void 0 ? offset : this.offset;
      this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;
      this.anchor = anchor !== null && anchor !== void 0 ? anchor : this.anchor;
      this.copyGraphics = copyGraphics !== null && copyGraphics !== void 0 ? copyGraphics : this.copyGraphics;
      this.onPreDraw = onPreDraw !== null && onPreDraw !== void 0 ? onPreDraw : this.onPreDraw;
      this.onPostDraw = onPostDraw !== null && onPostDraw !== void 0 ? onPostDraw : this.onPostDraw;
      this.visible = !!visible;
      this.layers = new GraphicsLayers(this);
      if (current && this._graphics[current]) {
        this.show(this._graphics[current]);
      }
    }
    /**
     * Returns the currently displayed graphics and their offsets, empty array if hidden
     */
    get current() {
      return this.layers.default.graphics;
    }
    /**
     * Returns all graphics associated with this component
     */
    get graphics() {
      return this._graphics;
    }
    add(nameOrGraphic, graphic) {
      let name = "default";
      let graphicToSet = null;
      if (typeof nameOrGraphic === "string") {
        name = nameOrGraphic;
        graphicToSet = graphic;
      } else {
        graphicToSet = nameOrGraphic;
      }
      this._graphics[name] = this.copyGraphics ? graphicToSet.clone() : graphicToSet;
      if (name === "default") {
        this.show("default");
      }
      return graphicToSet;
    }
    /**
     * Show a graphic by name on the **default** layer, returns the new [[Graphic]]
     */
    show(nameOrGraphic, options) {
      const result = this.layers.default.show(nameOrGraphic, options);
      this.recalculateBounds();
      return result;
    }
    /**
     * Use a graphic only, swap out any graphics on the **default** layer, returns the new [[Graphic]]
     * @param nameOrGraphic
     * @param options
     */
    use(nameOrGraphic, options) {
      const result = this.layers.default.use(nameOrGraphic, options);
      this.recalculateBounds();
      return result;
    }
    hide(nameOrGraphic) {
      this.layers.default.hide(nameOrGraphic);
    }
    set localBounds(bounds) {
      this._localBounds = bounds;
    }
    recalculateBounds() {
      let bb2 = new BoundingBox();
      for (const layer of this.layers.get()) {
        for (const { graphic, options } of layer.graphics) {
          let anchor = this.anchor;
          let offset = this.offset;
          if (options === null || options === void 0 ? void 0 : options.anchor) {
            anchor = options.anchor;
          }
          if (options === null || options === void 0 ? void 0 : options.offset) {
            offset = options.offset;
          }
          const bounds = graphic.localBounds;
          const offsetX = -bounds.width * anchor.x + offset.x;
          const offsetY = -bounds.height * anchor.y + offset.y;
          bb2 = graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(vec(offsetX + layer.offset.x, offsetY + layer.offset.y)).combine(bb2);
        }
      }
      this._localBounds = bb2;
    }
    get localBounds() {
      if (!this._localBounds || this._localBounds.hasZeroDimensions()) {
        this.recalculateBounds();
      }
      return this._localBounds;
    }
    /**
     * Update underlying graphics if necesary, called internally
     * @param elapsed
     * @internal
     */
    update(elapsed, idempotencyToken = 0) {
      for (const layer of this.layers.get()) {
        for (const { graphic } of layer.graphics) {
          if (hasGraphicsTick(graphic)) {
            graphic === null || graphic === void 0 ? void 0 : graphic.tick(elapsed, idempotencyToken);
          }
        }
      }
    }
    clone() {
      const graphics = new GraphicsComponent();
      graphics._graphics = { ...this._graphics };
      graphics.offset = this.offset.clone();
      graphics.opacity = this.opacity;
      graphics.anchor = this.anchor.clone();
      graphics.copyGraphics = this.copyGraphics;
      graphics.onPreDraw = this.onPreDraw;
      graphics.onPostDraw = this.onPostDraw;
      graphics.visible = this.visible;
      graphics.layers = this.layers.clone(graphics);
      return graphics;
    }
  }
  class Rectangle extends Raster {
    constructor(options) {
      super(options);
      this.width = options.width;
      this.height = options.height;
      this.rasterize();
    }
    clone() {
      return new Rectangle({
        width: this.width,
        height: this.height,
        ...this.cloneGraphicOptions(),
        ...this.cloneRasterOptions()
      });
    }
    execute(ctx) {
      if (this.color) {
        ctx.fillRect(0, 0, this.width, this.height);
      }
      if (this.strokeColor) {
        ctx.strokeRect(0, 0, this.width, this.height);
      }
    }
  }
  class Circle extends Raster {
    get radius() {
      return this._radius;
    }
    set radius(value) {
      this._radius = value;
      this.width = this._radius * 2;
      this.height = this._radius * 2;
      this.flagDirty();
    }
    constructor(options) {
      var _a, _b, _c;
      super(options);
      this._radius = 0;
      const lineWidth = (_a = options.lineWidth) !== null && _a !== void 0 ? _a : options.strokeColor ? 1 : 0;
      this.padding = (_b = options.padding) !== null && _b !== void 0 ? _b : 2 + lineWidth / 2;
      this.radius = options.radius;
      this.filtering = (_c = options.filtering) !== null && _c !== void 0 ? _c : ImageFiltering.Blended;
      this.rasterize();
    }
    clone() {
      return new Circle({
        radius: this.radius,
        ...this.cloneGraphicOptions(),
        ...this.cloneRasterOptions()
      });
    }
    execute(ctx) {
      if (this.radius > 0) {
        ctx.beginPath();
        ctx.arc(this.radius, this.radius, this.radius, 0, Math.PI * 2);
        if (this.color) {
          ctx.fill();
        }
        if (this.strokeColor) {
          ctx.stroke();
        }
      }
    }
  }
  class PointerComponent extends Component {
    constructor() {
      super(...arguments);
      this.type = "ex.pointer";
      this.useColliderShape = true;
      this.useGraphicsBounds = false;
    }
  }
  class EasingFunctions {
    static CreateReversibleEasingFunction(easing) {
      return (time, start, end, duration) => {
        if (end < start) {
          return start - (easing(time, end, start, duration) - end);
        } else {
          return easing(time, start, end, duration);
        }
      };
    }
    static CreateVectorEasingFunction(easing) {
      return (time, start, end, duration) => {
        return new Vector(easing(time, start.x, end.x, duration), easing(time, start.y, end.y, duration));
      };
    }
  }
  EasingFunctions.Linear = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    return endValue * currentTime / duration + startValue;
  });
  EasingFunctions.EaseInQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime + startValue;
  });
  EasingFunctions.EaseOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return -endValue * currentTime * (currentTime - 2) + startValue;
  });
  EasingFunctions.EaseInOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
      return endValue / 2 * currentTime * currentTime + startValue;
    }
    currentTime--;
    return -endValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
  });
  EasingFunctions.EaseInCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime * currentTime + startValue;
  });
  EasingFunctions.EaseOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    currentTime--;
    return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
  });
  EasingFunctions.EaseInOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
      return endValue / 2 * currentTime * currentTime * currentTime + startValue;
    }
    currentTime -= 2;
    return endValue / 2 * (currentTime * currentTime * currentTime + 2) + startValue;
  });
  class ActionQueue {
    constructor(entity) {
      this._actions = [];
      this._completedActions = [];
      this._entity = entity;
    }
    /**
     * Add an action to the sequence
     * @param action
     */
    add(action) {
      this._actions.push(action);
    }
    /**
     * Remove an action by reference from the sequence
     * @param action
     */
    remove(action) {
      const index = this._actions.indexOf(action);
      this._actions.splice(index, 1);
    }
    /**
     * Removes all actions from this sequence
     */
    clearActions() {
      this._actions.length = 0;
      this._completedActions.length = 0;
      if (this._currentAction) {
        this._currentAction.stop();
      }
    }
    /**
     *
     * @returns The total list of actions in this sequence complete or not
     */
    getActions() {
      return this._actions.concat(this._completedActions);
    }
    /**
     *
     * @returns `true` if there are more actions to process in the sequence
     */
    hasNext() {
      return this._actions.length > 0;
    }
    /**
     * @returns `true` if the current sequence of actions is done
     */
    isComplete() {
      return this._actions.length === 0;
    }
    /**
     * Resets the sequence of actions, this is used to restart a sequence from the beginning
     */
    reset() {
      this._actions = this.getActions();
      const len = this._actions.length;
      for (let i2 = 0; i2 < len; i2++) {
        this._actions[i2].reset();
      }
      this._completedActions = [];
    }
    /**
     * Update the queue which updates actions and handles completing actions
     * @param elapsedMs
     */
    update(elapsedMs) {
      if (this._actions.length > 0) {
        this._currentAction = this._actions[0];
        this._currentAction.update(elapsedMs);
        if (this._currentAction.isComplete(this._entity)) {
          this._completedActions.push(this._actions.shift());
        }
      }
    }
  }
  class Repeat {
    constructor(entity, repeatBuilder, repeat) {
      this._stopped = false;
      this._repeatBuilder = repeatBuilder;
      this._repeatContext = new ActionContext(entity);
      this._actionQueue = this._repeatContext.getQueue();
      this._repeat = repeat;
      this._originalRepeat = repeat;
      this._repeatBuilder(this._repeatContext);
      this._repeat--;
    }
    update(delta) {
      if (this._actionQueue.isComplete()) {
        this._actionQueue.clearActions();
        this._repeatBuilder(this._repeatContext);
        this._repeat--;
      }
      this._actionQueue.update(delta);
    }
    isComplete() {
      return this._stopped || this._repeat <= 0 && this._actionQueue.isComplete();
    }
    stop() {
      this._stopped = true;
    }
    reset() {
      this._repeat = this._originalRepeat;
    }
  }
  class RepeatForever {
    constructor(entity, repeatBuilder) {
      this._stopped = false;
      this._repeatBuilder = repeatBuilder;
      this._repeatContext = new ActionContext(entity);
      this._actionQueue = this._repeatContext.getQueue();
      this._repeatBuilder(this._repeatContext);
    }
    update(delta) {
      if (this._stopped) {
        return;
      }
      if (this._actionQueue.isComplete()) {
        this._actionQueue.clearActions();
        this._repeatBuilder(this._repeatContext);
      }
      this._actionQueue.update(delta);
    }
    isComplete() {
      return this._stopped;
    }
    stop() {
      this._stopped = true;
      this._actionQueue.clearActions();
    }
    reset() {
      return;
    }
  }
  class MoveBy {
    constructor(entity, offsetX, offsetY, speed) {
      this._started = false;
      this._stopped = false;
      this._entity = entity;
      this._tx = entity.get(TransformComponent);
      this._motion = entity.get(MotionComponent);
      this._speed = speed;
      this._offset = new Vector(offsetX, offsetY);
      if (speed <= 0) {
        Logger2.getInstance().error("Attempted to moveBy with speed less than or equal to zero : " + speed);
        throw new Error("Speed must be greater than 0 pixels per second");
      }
    }
    update(_delta) {
      if (!this._started) {
        this._started = true;
        this._start = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._end = this._start.add(this._offset);
        this._distance = this._offset.size;
        this._dir = this._end.sub(this._start).normalize();
      }
      if (this.isComplete(this._entity)) {
        this._tx.pos = vec(this._end.x, this._end.y);
        this._motion.vel = vec(0, 0);
      } else {
        this._motion.vel = this._dir.scale(this._speed);
      }
    }
    isComplete(entity) {
      const tx = entity.get(TransformComponent);
      return this._stopped || tx.pos.distance(this._start) >= this._distance;
    }
    stop() {
      this._motion.vel = vec(0, 0);
      this._stopped = true;
    }
    reset() {
      this._started = false;
      this._stopped = false;
    }
  }
  class MoveTo {
    constructor(entity, destx, desty, speed) {
      this.entity = entity;
      this._started = false;
      this._stopped = false;
      this._tx = entity.get(TransformComponent);
      this._motion = entity.get(MotionComponent);
      this._end = new Vector(destx, desty);
      this._speed = speed;
    }
    update(_delta) {
      if (!this._started) {
        this._started = true;
        this._start = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._distance = this._start.distance(this._end);
        this._dir = this._end.sub(this._start).normalize();
      }
      const m2 = this._dir.scale(this._speed);
      this._motion.vel = vec(m2.x, m2.y);
      if (this.isComplete(this.entity)) {
        this._tx.pos = vec(this._end.x, this._end.y);
        this._motion.vel = vec(0, 0);
      }
    }
    isComplete(entity) {
      const tx = entity.get(TransformComponent);
      return this._stopped || new Vector(tx.pos.x, tx.pos.y).distance(this._start) >= this._distance;
    }
    stop() {
      this._motion.vel = vec(0, 0);
      this._stopped = true;
    }
    reset() {
      this._started = false;
      this._stopped = false;
    }
  }
  var RotationType;
  (function(RotationType2) {
    RotationType2[RotationType2["ShortestPath"] = 0] = "ShortestPath";
    RotationType2[RotationType2["LongestPath"] = 1] = "LongestPath";
    RotationType2[RotationType2["Clockwise"] = 2] = "Clockwise";
    RotationType2[RotationType2["CounterClockwise"] = 3] = "CounterClockwise";
  })(RotationType || (RotationType = {}));
  class RotateTo {
    constructor(entity, angleRadians, speed, rotationType) {
      this._started = false;
      this._stopped = false;
      this._tx = entity.get(TransformComponent);
      this._motion = entity.get(MotionComponent);
      this._end = angleRadians;
      this._speed = speed;
      this._rotationType = rotationType || RotationType.ShortestPath;
    }
    update(_delta) {
      if (!this._started) {
        this._started = true;
        this._start = this._tx.rotation;
        this._currentNonCannonAngle = this._tx.rotation;
        const distance1 = Math.abs(this._end - this._start);
        const distance2 = TwoPI - distance1;
        if (distance1 > distance2) {
          this._shortDistance = distance2;
          this._longDistance = distance1;
        } else {
          this._shortDistance = distance1;
          this._longDistance = distance2;
        }
        this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;
        switch (this._rotationType) {
          case RotationType.ShortestPath:
            this._distance = this._shortDistance;
            if (this._shortestPathIsPositive) {
              this._direction = 1;
            } else {
              this._direction = -1;
            }
            break;
          case RotationType.LongestPath:
            this._distance = this._longDistance;
            if (this._shortestPathIsPositive) {
              this._direction = -1;
            } else {
              this._direction = 1;
            }
            break;
          case RotationType.Clockwise:
            this._direction = 1;
            if (this._shortestPathIsPositive) {
              this._distance = this._shortDistance;
            } else {
              this._distance = this._longDistance;
            }
            break;
          case RotationType.CounterClockwise:
            this._direction = -1;
            if (!this._shortestPathIsPositive) {
              this._distance = this._shortDistance;
            } else {
              this._distance = this._longDistance;
            }
            break;
        }
      }
      this._motion.angularVelocity = this._direction * this._speed;
      this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1e3);
      if (this.isComplete()) {
        this._tx.rotation = this._end;
        this._motion.angularVelocity = 0;
        this._stopped = true;
      }
    }
    isComplete() {
      const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);
      return this._stopped || distanceTraveled >= Math.abs(this._distance);
    }
    stop() {
      this._motion.angularVelocity = 0;
      this._stopped = true;
    }
    reset() {
      this._started = false;
      this._stopped = false;
    }
  }
  class RotateBy {
    constructor(entity, angleRadiansOffset, speed, rotationType) {
      this._started = false;
      this._stopped = false;
      this._tx = entity.get(TransformComponent);
      this._motion = entity.get(MotionComponent);
      this._speed = speed;
      this._offset = angleRadiansOffset;
      this._rotationType = rotationType || RotationType.ShortestPath;
    }
    update(_delta) {
      if (!this._started) {
        this._started = true;
        this._start = this._tx.rotation;
        this._currentNonCannonAngle = this._tx.rotation;
        this._end = this._start + this._offset;
        const distance1 = Math.abs(this._end - this._start);
        const distance2 = TwoPI - distance1;
        if (distance1 > distance2) {
          this._shortDistance = distance2;
          this._longDistance = distance1;
        } else {
          this._shortDistance = distance1;
          this._longDistance = distance2;
        }
        this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;
        switch (this._rotationType) {
          case RotationType.ShortestPath:
            this._distance = this._shortDistance;
            if (this._shortestPathIsPositive) {
              this._direction = 1;
            } else {
              this._direction = -1;
            }
            break;
          case RotationType.LongestPath:
            this._distance = this._longDistance;
            if (this._shortestPathIsPositive) {
              this._direction = -1;
            } else {
              this._direction = 1;
            }
            break;
          case RotationType.Clockwise:
            this._direction = 1;
            if (this._shortDistance >= 0) {
              this._distance = this._shortDistance;
            } else {
              this._distance = this._longDistance;
            }
            break;
          case RotationType.CounterClockwise:
            this._direction = -1;
            if (this._shortDistance <= 0) {
              this._distance = this._shortDistance;
            } else {
              this._distance = this._longDistance;
            }
            break;
        }
      }
      this._motion.angularVelocity = this._direction * this._speed;
      this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1e3);
      if (this.isComplete()) {
        this._tx.rotation = this._end;
        this._motion.angularVelocity = 0;
        this._stopped = true;
      }
    }
    isComplete() {
      const distanceTraveled = Math.abs(this._currentNonCannonAngle - this._start);
      return this._stopped || distanceTraveled >= Math.abs(this._distance);
    }
    stop() {
      this._motion.angularVelocity = 0;
      this._stopped = true;
    }
    reset() {
      this._started = false;
      this._stopped = false;
      this._start = void 0;
      this._currentNonCannonAngle = void 0;
      this._distance = void 0;
    }
  }
  class ScaleTo {
    constructor(entity, scaleX, scaleY, speedX, speedY) {
      this._started = false;
      this._stopped = false;
      this._tx = entity.get(TransformComponent);
      this._motion = entity.get(MotionComponent);
      this._endX = scaleX;
      this._endY = scaleY;
      this._speedX = speedX;
      this._speedY = speedY;
    }
    update(_delta) {
      if (!this._started) {
        this._started = true;
        this._startX = this._tx.scale.x;
        this._startY = this._tx.scale.y;
        this._distanceX = Math.abs(this._endX - this._startX);
        this._distanceY = Math.abs(this._endY - this._startY);
      }
      if (!(Math.abs(this._tx.scale.x - this._startX) >= this._distanceX)) {
        const directionX = this._endY < this._startY ? -1 : 1;
        this._motion.scaleFactor.x = this._speedX * directionX;
      } else {
        this._motion.scaleFactor.x = 0;
      }
      if (!(Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)) {
        const directionY = this._endY < this._startY ? -1 : 1;
        this._motion.scaleFactor.y = this._speedY * directionY;
      } else {
        this._motion.scaleFactor.y = 0;
      }
      if (this.isComplete()) {
        this._tx.scale = vec(this._endX, this._endY);
        this._motion.scaleFactor.x = 0;
        this._motion.scaleFactor.y = 0;
      }
    }
    isComplete() {
      return this._stopped || Math.abs(this._tx.scale.x - this._startX) >= this._distanceX - 0.01 && Math.abs(this._tx.scale.y - this._startY) >= this._distanceY - 0.01;
    }
    stop() {
      this._motion.scaleFactor.x = 0;
      this._motion.scaleFactor.y = 0;
      this._stopped = true;
    }
    reset() {
      this._started = false;
      this._stopped = false;
    }
  }
  class ScaleBy {
    constructor(entity, scaleOffsetX, scaleOffsetY, speed) {
      this._started = false;
      this._stopped = false;
      this._tx = entity.get(TransformComponent);
      this._motion = entity.get(MotionComponent);
      this._offset = new Vector(scaleOffsetX, scaleOffsetY);
      this._speedX = this._speedY = speed;
    }
    update(_delta) {
      if (!this._started) {
        this._started = true;
        this._startScale = this._tx.scale.clone();
        this._endScale = this._startScale.add(this._offset);
        this._distanceX = Math.abs(this._endScale.x - this._startScale.x);
        this._distanceY = Math.abs(this._endScale.y - this._startScale.y);
        this._directionX = this._endScale.x < this._startScale.x ? -1 : 1;
        this._directionY = this._endScale.y < this._startScale.y ? -1 : 1;
      }
      this._motion.scaleFactor.x = this._speedX * this._directionX;
      this._motion.scaleFactor.y = this._speedY * this._directionY;
      if (this.isComplete()) {
        this._tx.scale = this._endScale;
        this._motion.scaleFactor.x = 0;
        this._motion.scaleFactor.y = 0;
      }
    }
    isComplete() {
      return this._stopped || Math.abs(this._tx.scale.x - this._startScale.x) >= this._distanceX - 0.01 && Math.abs(this._tx.scale.y - this._startScale.y) >= this._distanceY - 0.01;
    }
    stop() {
      this._motion.scaleFactor.x = 0;
      this._motion.scaleFactor.y = 0;
      this._stopped = true;
    }
    reset() {
      this._started = false;
      this._stopped = false;
    }
  }
  class CallMethod {
    constructor(method) {
      this._method = null;
      this._hasBeenCalled = false;
      this._method = method;
    }
    update(_delta) {
      this._method();
      this._hasBeenCalled = true;
    }
    isComplete() {
      return this._hasBeenCalled;
    }
    reset() {
      this._hasBeenCalled = false;
    }
    stop() {
      this._hasBeenCalled = true;
    }
  }
  class EaseTo {
    constructor(entity, x2, y2, duration, easingFcn) {
      this.easingFcn = easingFcn;
      this._currentLerpTime = 0;
      this._lerpDuration = 1 * 1e3;
      this._lerpStart = new Vector(0, 0);
      this._lerpEnd = new Vector(0, 0);
      this._initialized = false;
      this._stopped = false;
      this._tx = entity.get(TransformComponent);
      this._motion = entity.get(MotionComponent);
      this._lerpDuration = duration;
      this._lerpEnd = new Vector(x2, y2);
    }
    _initialize() {
      this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);
      this._currentLerpTime = 0;
    }
    update(delta) {
      if (!this._initialized) {
        this._initialize();
        this._initialized = true;
      }
      this._currentLerpTime += delta;
      let newX = this._tx.pos.x;
      let newY = this._tx.pos.y;
      if (this._currentLerpTime < this._lerpDuration) {
        if (this._lerpEnd.x < this._lerpStart.x) {
          newX = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
        } else {
          newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
        }
        if (this._lerpEnd.y < this._lerpStart.y) {
          newY = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
        } else {
          newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
        }
        this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1e3), (newY - this._tx.pos.y) / (delta / 1e3));
      } else {
        this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);
        this._motion.vel = Vector.Zero;
      }
    }
    isComplete() {
      return this._stopped || this._currentLerpTime >= this._lerpDuration;
    }
    reset() {
      this._initialized = false;
      this._stopped = false;
      this._currentLerpTime = 0;
    }
    stop() {
      this._motion.vel = vec(0, 0);
      this._stopped = true;
    }
  }
  class EaseBy {
    constructor(entity, offsetX, offsetY, duration, easingFcn) {
      this.easingFcn = easingFcn;
      this._currentLerpTime = 0;
      this._lerpDuration = 1 * 1e3;
      this._lerpStart = new Vector(0, 0);
      this._lerpEnd = new Vector(0, 0);
      this._initialized = false;
      this._stopped = false;
      this._tx = entity.get(TransformComponent);
      this._motion = entity.get(MotionComponent);
      this._lerpDuration = duration;
      this._offset = new Vector(offsetX, offsetY);
    }
    _initialize() {
      this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);
      this._currentLerpTime = 0;
      this._lerpEnd = this._lerpStart.add(this._offset);
    }
    update(delta) {
      if (!this._initialized) {
        this._initialize();
        this._initialized = true;
      }
      this._currentLerpTime += delta;
      let newX = this._tx.pos.x;
      let newY = this._tx.pos.y;
      if (this._currentLerpTime < this._lerpDuration) {
        if (this._lerpEnd.x < this._lerpStart.x) {
          newX = this._lerpStart.x - (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
        } else {
          newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
        }
        if (this._lerpEnd.y < this._lerpStart.y) {
          newY = this._lerpStart.y - (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
        } else {
          newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
        }
        this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1e3), (newY - this._tx.pos.y) / (delta / 1e3));
      } else {
        this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);
        this._motion.vel = Vector.Zero;
      }
    }
    isComplete() {
      return this._stopped || this._currentLerpTime >= this._lerpDuration;
    }
    reset() {
      this._initialized = false;
      this._stopped = false;
      this._currentLerpTime = 0;
    }
    stop() {
      this._motion.vel = vec(0, 0);
      this._stopped = true;
    }
  }
  class Blink {
    constructor(entity, timeVisible, timeNotVisible, numBlinks = 1) {
      this._timeVisible = 0;
      this._timeNotVisible = 0;
      this._elapsedTime = 0;
      this._totalTime = 0;
      this._stopped = false;
      this._started = false;
      this._graphics = entity.get(GraphicsComponent);
      this._timeVisible = timeVisible;
      this._timeNotVisible = timeNotVisible;
      this._duration = (timeVisible + timeNotVisible) * numBlinks;
    }
    update(delta) {
      if (!this._started) {
        this._started = true;
        this._elapsedTime = 0;
        this._totalTime = 0;
      }
      if (!this._graphics) {
        return;
      }
      this._elapsedTime += delta;
      this._totalTime += delta;
      if (this._graphics.visible && this._elapsedTime >= this._timeVisible) {
        this._graphics.visible = false;
        this._elapsedTime = 0;
      }
      if (!this._graphics.visible && this._elapsedTime >= this._timeNotVisible) {
        this._graphics.visible = true;
        this._elapsedTime = 0;
      }
      if (this.isComplete()) {
        this._graphics.visible = true;
      }
    }
    isComplete() {
      return this._stopped || this._totalTime >= this._duration;
    }
    stop() {
      if (this._graphics) {
        this._graphics.visible = true;
      }
      this._stopped = true;
    }
    reset() {
      this._started = false;
      this._stopped = false;
      this._elapsedTime = 0;
      this._totalTime = 0;
    }
  }
  class Fade {
    constructor(entity, endOpacity, speed) {
      this._multiplier = 1;
      this._started = false;
      this._stopped = false;
      this._graphics = entity.get(GraphicsComponent);
      this._endOpacity = endOpacity;
      this._speed = this._ogspeed = speed;
    }
    update(delta) {
      if (!this._graphics) {
        return;
      }
      if (!this._started) {
        this._started = true;
        this._speed = this._ogspeed;
        if (this._endOpacity < this._graphics.opacity) {
          this._multiplier = -1;
        } else {
          this._multiplier = 1;
        }
      }
      if (this._speed > 0) {
        this._graphics.opacity += this._multiplier * (Math.abs(this._graphics.opacity - this._endOpacity) * delta) / this._speed;
      }
      this._speed -= delta;
      if (this.isComplete()) {
        this._graphics.opacity = this._endOpacity;
      }
      Logger2.getInstance().debug("[Action fade] Actor opacity:", this._graphics.opacity);
    }
    isComplete() {
      return this._stopped || Math.abs(this._graphics.opacity - this._endOpacity) < 0.05;
    }
    stop() {
      this._stopped = true;
    }
    reset() {
      this._started = false;
      this._stopped = false;
    }
  }
  class Delay {
    constructor(delay3) {
      this._elapsedTime = 0;
      this._started = false;
      this._stopped = false;
      this._delay = delay3;
    }
    update(delta) {
      if (!this._started) {
        this._started = true;
      }
      this._elapsedTime += delta;
    }
    isComplete() {
      return this._stopped || this._elapsedTime >= this._delay;
    }
    stop() {
      this._stopped = true;
    }
    reset() {
      this._elapsedTime = 0;
      this._started = false;
      this._stopped = false;
    }
  }
  class Die {
    constructor(entity) {
      this._stopped = false;
      this._entity = entity;
    }
    update(_delta) {
      this._entity.get(ActionsComponent).clearActions();
      this._entity.kill();
      this._stopped = true;
    }
    isComplete() {
      return this._stopped;
    }
    stop() {
      return;
    }
    reset() {
      return;
    }
  }
  class Follow {
    constructor(entity, entityToFollow, followDistance) {
      this._started = false;
      this._stopped = false;
      this._tx = entity.get(TransformComponent);
      this._motion = entity.get(MotionComponent);
      this._followTx = entityToFollow.get(TransformComponent);
      this._followMotion = entityToFollow.get(MotionComponent);
      this._current = new Vector(this._tx.pos.x, this._tx.pos.y);
      this._end = new Vector(this._followTx.pos.x, this._followTx.pos.y);
      this._maximumDistance = followDistance !== void 0 ? followDistance : this._current.distance(this._end);
      this._speed = 0;
    }
    update(_delta) {
      if (!this._started) {
        this._started = true;
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
      }
      const actorToFollowSpeed = Math.sqrt(Math.pow(this._followMotion.vel.x, 2) + Math.pow(this._followMotion.vel.y, 2));
      if (actorToFollowSpeed !== 0) {
        this._speed = actorToFollowSpeed;
      }
      this._current = vec(this._tx.pos.x, this._tx.pos.y);
      this._end = vec(this._followTx.pos.x, this._followTx.pos.y);
      this._distanceBetween = this._current.distance(this._end);
      this._dir = this._end.sub(this._current).normalize();
      if (this._distanceBetween >= this._maximumDistance) {
        const m2 = this._dir.scale(this._speed);
        this._motion.vel = vec(m2.x, m2.y);
      } else {
        this._motion.vel = vec(0, 0);
      }
      if (this.isComplete()) {
        this._tx.pos = vec(this._end.x, this._end.y);
        this._motion.vel = vec(0, 0);
      }
    }
    stop() {
      this._motion.vel = vec(0, 0);
      this._stopped = true;
    }
    isComplete() {
      return this._stopped;
    }
    reset() {
      this._started = false;
      this._stopped = false;
    }
  }
  class Meet {
    constructor(actor, actorToMeet, speed) {
      this._started = false;
      this._stopped = false;
      this._speedWasSpecified = false;
      this._tx = actor.get(TransformComponent);
      this._motion = actor.get(MotionComponent);
      this._meetTx = actorToMeet.get(TransformComponent);
      this._meetMotion = actorToMeet.get(MotionComponent);
      this._current = new Vector(this._tx.pos.x, this._tx.pos.y);
      this._end = new Vector(this._meetTx.pos.x, this._meetTx.pos.y);
      this._speed = speed || 0;
      if (speed !== void 0) {
        this._speedWasSpecified = true;
      }
    }
    update(_delta) {
      if (!this._started) {
        this._started = true;
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
      }
      const actorToMeetSpeed = Math.sqrt(Math.pow(this._meetMotion.vel.x, 2) + Math.pow(this._meetMotion.vel.y, 2));
      if (actorToMeetSpeed !== 0 && !this._speedWasSpecified) {
        this._speed = actorToMeetSpeed;
      }
      this._current = vec(this._tx.pos.x, this._tx.pos.y);
      this._end = vec(this._meetTx.pos.x, this._meetTx.pos.y);
      this._distanceBetween = this._current.distance(this._end);
      this._dir = this._end.sub(this._current).normalize();
      const m2 = this._dir.scale(this._speed);
      this._motion.vel = vec(m2.x, m2.y);
      if (this.isComplete()) {
        this._tx.pos = vec(this._end.x, this._end.y);
        this._motion.vel = vec(0, 0);
      }
    }
    isComplete() {
      return this._stopped || this._distanceBetween <= 1;
    }
    stop() {
      this._motion.vel = vec(0, 0);
      this._stopped = true;
    }
    reset() {
      this._started = false;
      this._stopped = false;
      this._distanceBetween = void 0;
    }
  }
  class ActionContext {
    constructor(entity) {
      this._entity = entity;
      this._queue = new ActionQueue(entity);
    }
    getQueue() {
      return this._queue;
    }
    update(elapsedMs) {
      this._queue.update(elapsedMs);
    }
    /**
     * Clears all queued actions from the Actor
     */
    clearActions() {
      this._queue.clearActions();
    }
    runAction(action) {
      action.reset();
      this._queue.add(action);
      return this;
    }
    easeTo(...args) {
      var _a, _b;
      let x2 = 0;
      let y2 = 0;
      let duration = 0;
      let easingFcn = EasingFunctions.Linear;
      if (args[0] instanceof Vector) {
        x2 = args[0].x;
        y2 = args[0].y;
        duration = args[1];
        easingFcn = (_a = args[2]) !== null && _a !== void 0 ? _a : easingFcn;
      } else {
        x2 = args[0];
        y2 = args[1];
        duration = args[2];
        easingFcn = (_b = args[3]) !== null && _b !== void 0 ? _b : easingFcn;
      }
      this._queue.add(new EaseTo(this._entity, x2, y2, duration, easingFcn));
      return this;
    }
    easeBy(...args) {
      var _a, _b;
      let offsetX = 0;
      let offsetY = 0;
      let duration = 0;
      let easingFcn = EasingFunctions.Linear;
      if (args[0] instanceof Vector) {
        offsetX = args[0].x;
        offsetY = args[0].y;
        duration = args[1];
        easingFcn = (_a = args[2]) !== null && _a !== void 0 ? _a : easingFcn;
      } else {
        offsetX = args[0];
        offsetY = args[1];
        duration = args[2];
        easingFcn = (_b = args[3]) !== null && _b !== void 0 ? _b : easingFcn;
      }
      this._queue.add(new EaseBy(this._entity, offsetX, offsetY, duration, easingFcn));
      return this;
    }
    moveTo(xOrPos, yOrSpeed, speedOrUndefined) {
      let x2 = 0;
      let y2 = 0;
      let speed = 0;
      if (xOrPos instanceof Vector) {
        x2 = xOrPos.x;
        y2 = xOrPos.y;
        speed = yOrSpeed;
      } else {
        x2 = xOrPos;
        y2 = yOrSpeed;
        speed = speedOrUndefined;
      }
      this._queue.add(new MoveTo(this._entity, x2, y2, speed));
      return this;
    }
    moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {
      let xOffset = 0;
      let yOffset = 0;
      let speed = 0;
      if (xOffsetOrVector instanceof Vector) {
        xOffset = xOffsetOrVector.x;
        yOffset = xOffsetOrVector.y;
        speed = yOffsetOrSpeed;
      } else {
        xOffset = xOffsetOrVector;
        yOffset = yOffsetOrSpeed;
        speed = speedOrUndefined;
      }
      this._queue.add(new MoveBy(this._entity, xOffset, yOffset, speed));
      return this;
    }
    /**
     * This method will rotate an actor to the specified angle at the speed
     * specified (in radians per second) and return back the actor. This
     * method is part of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadians  The angle to rotate to in radians
     * @param speed         The angular velocity of the rotation specified in radians per second
     * @param rotationType  The [[RotationType]] to use for this rotation
     */
    rotateTo(angleRadians, speed, rotationType) {
      this._queue.add(new RotateTo(this._entity, angleRadians, speed, rotationType));
      return this;
    }
    /**
     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed
     * in radians/sec and return back the actor. This method is part
     * of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation
     * @param speed          The speed in radians/sec the actor should rotate at
     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path
     */
    rotateBy(angleRadiansOffset, speed, rotationType) {
      this._queue.add(new RotateBy(this._entity, angleRadiansOffset, speed, rotationType));
      return this;
    }
    scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
      let sizeX = 1;
      let sizeY = 1;
      let speedX = 0;
      let speedY = 0;
      if (sizeXOrVector instanceof Vector && sizeYOrSpeed instanceof Vector) {
        sizeX = sizeXOrVector.x;
        sizeY = sizeXOrVector.y;
        speedX = sizeYOrSpeed.x;
        speedY = sizeYOrSpeed.y;
      }
      if (typeof sizeXOrVector === "number" && typeof sizeYOrSpeed === "number") {
        sizeX = sizeXOrVector;
        sizeY = sizeYOrSpeed;
        speedX = speedXOrUndefined;
        speedY = speedYOrUndefined;
      }
      this._queue.add(new ScaleTo(this._entity, sizeX, sizeY, speedX, speedY));
      return this;
    }
    scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {
      let sizeOffsetX = 1;
      let sizeOffsetY = 1;
      if (sizeOffsetXOrVector instanceof Vector) {
        sizeOffsetX = sizeOffsetXOrVector.x;
        sizeOffsetY = sizeOffsetXOrVector.y;
        speed = sizeOffsetYOrSpeed;
      }
      if (typeof sizeOffsetXOrVector === "number" && typeof sizeOffsetYOrSpeed === "number") {
        sizeOffsetX = sizeOffsetXOrVector;
        sizeOffsetY = sizeOffsetYOrSpeed;
      }
      this._queue.add(new ScaleBy(this._entity, sizeOffsetX, sizeOffsetY, speed));
      return this;
    }
    /**
     * This method will cause an actor to blink (become visible and not
     * visible). Optionally, you may specify the number of blinks. Specify the amount of time
     * the actor should be visible per blink, and the amount of time not visible.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param timeVisible     The amount of time to stay visible per blink in milliseconds
     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
     * @param numBlinks       The number of times to blink
     */
    blink(timeVisible, timeNotVisible, numBlinks = 1) {
      this._queue.add(new Blink(this._entity, timeVisible, timeNotVisible, numBlinks));
      return this;
    }
    /**
     * This method will cause an actor's opacity to change from its current value
     * to the provided value by a specified time (in milliseconds). This method is
     * part of the actor 'Action' fluent API allowing action chaining.
     * @param opacity  The ending opacity
     * @param time     The time it should take to fade the actor (in milliseconds)
     */
    fade(opacity, time) {
      this._queue.add(new Fade(this._entity, opacity, time));
      return this;
    }
    /**
     * This method will delay the next action from executing for a certain
     * amount of time (in milliseconds). This method is part of the actor
     * 'Action' fluent API allowing action chaining.
     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
     */
    delay(time) {
      this._queue.add(new Delay(time));
      return this;
    }
    /**
     * This method will add an action to the queue that will remove the actor from the
     * scene once it has completed its previous  Any actions on the
     * action queue after this action will not be executed.
     */
    die() {
      this._queue.add(new Die(this._entity));
      return this;
    }
    /**
     * This method allows you to call an arbitrary method as the next action in the
     * action queue. This is useful if you want to execute code in after a specific
     * action, i.e An actor arrives at a destination after traversing a path
     */
    callMethod(method) {
      this._queue.add(new CallMethod(method));
      return this;
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
     * will repeat forever
     */
    repeat(repeatBuilder, times) {
      if (!times) {
        this.repeatForever(repeatBuilder);
        return this;
      }
      this._queue.add(new Repeat(this._entity, repeatBuilder, times));
      return this;
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     */
    repeatForever(repeatBuilder) {
      this._queue.add(new RepeatForever(this._entity, repeatBuilder));
      return this;
    }
    /**
     * This method will cause the entity to follow another at a specified distance
     * @param entity           The entity to follow
     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
     */
    follow(entity, followDistance) {
      if (followDistance === void 0) {
        this._queue.add(new Follow(this._entity, entity));
      } else {
        this._queue.add(new Follow(this._entity, entity, followDistance));
      }
      return this;
    }
    /**
     * This method will cause the entity to move towards another until they
     * collide "meet" at a specified speed.
     * @param entity  The entity to meet
     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
     */
    meet(entity, speed) {
      if (speed === void 0) {
        this._queue.add(new Meet(this._entity, entity));
      } else {
        this._queue.add(new Meet(this._entity, entity, speed));
      }
      return this;
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     */
    toPromise() {
      const temp = new Promise((resolve) => {
        this._queue.add(new CallMethod(() => {
          resolve();
        }));
      });
      return temp;
    }
  }
  class ActionsComponent extends Component {
    constructor() {
      super(...arguments);
      this.type = "ex.actions";
      this.dependencies = [TransformComponent, MotionComponent];
    }
    onAdd(entity) {
      this._ctx = new ActionContext(entity);
    }
    onRemove() {
      this._ctx = null;
    }
    /**
     * Returns the internal action queue
     * @returns action queue
     */
    getQueue() {
      var _a;
      return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.getQueue();
    }
    runAction(action) {
      var _a;
      return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.runAction(action);
    }
    /**
     * Updates the internal action context, performing action and moving through the internal queue
     * @param elapsedMs
     */
    update(elapsedMs) {
      var _a;
      return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.update(elapsedMs);
    }
    /**
     * Clears all queued actions from the Actor
     */
    clearActions() {
      var _a;
      (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.clearActions();
    }
    easeTo(...args) {
      return this._ctx.easeTo.apply(this._ctx, args);
    }
    easeBy(...args) {
      return this._ctx.easeBy.apply(this._ctx, args);
    }
    moveTo(xOrPos, yOrSpeed, speedOrUndefined) {
      return this._ctx.moveTo.apply(this._ctx, [xOrPos, yOrSpeed, speedOrUndefined]);
    }
    moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {
      return this._ctx.moveBy.apply(this._ctx, [xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined]);
    }
    /**
     * This method will rotate an actor to the specified angle at the speed
     * specified (in radians per second) and return back the actor. This
     * method is part of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadians  The angle to rotate to in radians
     * @param speed         The angular velocity of the rotation specified in radians per second
     * @param rotationType  The [[RotationType]] to use for this rotation
     */
    rotateTo(angleRadians, speed, rotationType) {
      return this._ctx.rotateTo(angleRadians, speed, rotationType);
    }
    /**
     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed
     * in radians/sec and return back the actor. This method is part
     * of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation
     * @param speed          The speed in radians/sec the actor should rotate at
     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path
     */
    rotateBy(angleRadiansOffset, speed, rotationType) {
      return this._ctx.rotateBy(angleRadiansOffset, speed, rotationType);
    }
    scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
      return this._ctx.scaleTo.apply(this._ctx, [sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined]);
    }
    scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {
      return this._ctx.scaleBy.apply(this._ctx, [sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed]);
    }
    /**
     * This method will cause an actor to blink (become visible and not
     * visible). Optionally, you may specify the number of blinks. Specify the amount of time
     * the actor should be visible per blink, and the amount of time not visible.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param timeVisible     The amount of time to stay visible per blink in milliseconds
     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
     * @param numBlinks       The number of times to blink
     */
    blink(timeVisible, timeNotVisible, numBlinks) {
      return this._ctx.blink(timeVisible, timeNotVisible, numBlinks);
    }
    /**
     * This method will cause an actor's opacity to change from its current value
     * to the provided value by a specified time (in milliseconds). This method is
     * part of the actor 'Action' fluent API allowing action chaining.
     * @param opacity  The ending opacity
     * @param time     The time it should take to fade the actor (in milliseconds)
     */
    fade(opacity, time) {
      return this._ctx.fade(opacity, time);
    }
    /**
     * This method will delay the next action from executing for a certain
     * amount of time (in milliseconds). This method is part of the actor
     * 'Action' fluent API allowing action chaining.
     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
     */
    delay(time) {
      return this._ctx.delay(time);
    }
    /**
     * This method will add an action to the queue that will remove the actor from the
     * scene once it has completed its previous  Any actions on the
     * action queue after this action will not be executed.
     */
    die() {
      return this._ctx.die();
    }
    /**
     * This method allows you to call an arbitrary method as the next action in the
     * action queue. This is useful if you want to execute code in after a specific
     * action, i.e An actor arrives at a destination after traversing a path
     */
    callMethod(method) {
      return this._ctx.callMethod(method);
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
     * will repeat forever
     */
    repeat(repeatBuilder, times) {
      return this._ctx.repeat(repeatBuilder, times);
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     */
    repeatForever(repeatBuilder) {
      return this._ctx.repeatForever(repeatBuilder);
    }
    /**
     * This method will cause the entity to follow another at a specified distance
     * @param entity           The entity to follow
     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
     */
    follow(entity, followDistance) {
      return this._ctx.follow(entity, followDistance);
    }
    /**
     * This method will cause the entity to move towards another until they
     * collide "meet" at a specified speed.
     * @param entity  The entity to meet
     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
     */
    meet(entity, speed) {
      return this._ctx.meet(entity, speed);
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     */
    toPromise() {
      return this._ctx.toPromise();
    }
  }
  var FontUnit;
  (function(FontUnit2) {
    FontUnit2["Em"] = "em";
    FontUnit2["Rem"] = "rem";
    FontUnit2["Px"] = "px";
    FontUnit2["Pt"] = "pt";
    FontUnit2["Percent"] = "%";
  })(FontUnit || (FontUnit = {}));
  var TextAlign;
  (function(TextAlign2) {
    TextAlign2["Left"] = "left";
    TextAlign2["Right"] = "right";
    TextAlign2["Center"] = "center";
    TextAlign2["Start"] = "start";
    TextAlign2["End"] = "end";
  })(TextAlign || (TextAlign = {}));
  var BaseAlign;
  (function(BaseAlign2) {
    BaseAlign2["Top"] = "top";
    BaseAlign2["Hanging"] = "hanging";
    BaseAlign2["Middle"] = "middle";
    BaseAlign2["Alphabetic"] = "alphabetic";
    BaseAlign2["Ideographic"] = "ideographic";
    BaseAlign2["Bottom"] = "bottom";
  })(BaseAlign || (BaseAlign = {}));
  var FontStyle;
  (function(FontStyle2) {
    FontStyle2["Normal"] = "normal";
    FontStyle2["Italic"] = "italic";
    FontStyle2["Oblique"] = "oblique";
  })(FontStyle || (FontStyle = {}));
  var Direction;
  (function(Direction2) {
    Direction2["LeftToRight"] = "ltr";
    Direction2["RightToLeft"] = "rtl";
  })(Direction || (Direction = {}));
  class FontTextInstance {
    constructor(font, text, color2, maxWidth) {
      this.font = font;
      this.text = text;
      this.color = color2;
      this.maxWidth = maxWidth;
      this._textFragments = [];
      this.disposed = false;
      this._dirty = true;
      this.canvas = document.createElement("canvas");
      this.ctx = this.canvas.getContext("2d");
      this.dimensions = this.measureText(text);
      this._setDimension(this.dimensions, this.ctx);
      this._lastHashCode = this.getHashCode();
    }
    measureText(text, maxWidth) {
      if (this.disposed) {
        throw Error("Accessing disposed text instance! " + this.text);
      }
      let lines = null;
      if (maxWidth != null) {
        lines = this._getLinesFromText(text, maxWidth);
      } else {
        lines = text.split("\n");
      }
      const maxWidthLine = lines.reduce((a2, b2) => {
        return a2.length > b2.length ? a2 : b2;
      });
      this._applyFont(this.ctx);
      const metrics = this.ctx.measureText(maxWidthLine);
      let textHeight = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);
      const lineAdjustedHeight = textHeight * lines.length;
      textHeight = lineAdjustedHeight;
      const bottomBounds = lineAdjustedHeight - Math.abs(metrics.actualBoundingBoxAscent);
      const x2 = 0;
      const y2 = 0;
      const measurement = new BoundingBox({
        left: x2 - Math.abs(metrics.actualBoundingBoxLeft) - this.font.padding,
        top: y2 - Math.abs(metrics.actualBoundingBoxAscent) - this.font.padding,
        bottom: y2 + bottomBounds + this.font.padding,
        right: x2 + Math.abs(metrics.actualBoundingBoxRight) + this.font.padding
      });
      return measurement;
    }
    _setDimension(textBounds, bitmap) {
      bitmap.canvas.width = (textBounds.width + this.font.padding * 2) * 2 * this.font.quality;
      bitmap.canvas.height = (textBounds.height + this.font.padding * 2) * 2 * this.font.quality;
    }
    static getHashCode(font, text, color2) {
      var _a;
      const hash = text + "__hashcode__" + font.fontString + font.showDebug + font.textAlign + font.baseAlign + font.direction + JSON.stringify(font.shadow) + (font.padding.toString() + font.smoothing.toString() + font.lineWidth.toString() + font.lineDash.toString() + ((_a = font.strokeColor) === null || _a === void 0 ? void 0 : _a.toString()) + (color2 ? color2.toString() : font.color.toString()));
      return hash;
    }
    getHashCode(includeColor = true) {
      return FontTextInstance.getHashCode(this.font, this.text, includeColor ? this.color : void 0);
    }
    _applyRasterProperties(ctx) {
      var _a, _b;
      ctx.translate(this.font.padding, this.font.padding);
      ctx.imageSmoothingEnabled = this.font.smoothing;
      ctx.lineWidth = this.font.lineWidth;
      ctx.setLineDash((_a = this.font.lineDash) !== null && _a !== void 0 ? _a : ctx.getLineDash());
      ctx.strokeStyle = (_b = this.font.strokeColor) === null || _b === void 0 ? void 0 : _b.toString();
      ctx.fillStyle = this.color.toString();
    }
    _applyFont(ctx) {
      ctx.resetTransform();
      ctx.translate(this.font.padding + ctx.canvas.width / 2, this.font.padding + ctx.canvas.height / 2);
      ctx.scale(this.font.quality, this.font.quality);
      ctx.textAlign = this.font.textAlign;
      ctx.textBaseline = this.font.baseAlign;
      ctx.font = this.font.fontString;
      ctx.direction = this.font.direction;
      if (this.font.shadow) {
        ctx.shadowColor = this.font.shadow.color.toString();
        ctx.shadowBlur = this.font.shadow.blur;
        ctx.shadowOffsetX = this.font.shadow.offset.x;
        ctx.shadowOffsetY = this.font.shadow.offset.y;
      }
    }
    _drawText(ctx, lines, lineHeight) {
      this._applyRasterProperties(ctx);
      this._applyFont(ctx);
      for (let i2 = 0; i2 < lines.length; i2++) {
        const line2 = lines[i2];
        if (this.color) {
          ctx.fillText(line2, 0, i2 * lineHeight);
        }
        if (this.font.strokeColor) {
          ctx.strokeText(line2, 0, i2 * lineHeight);
        }
      }
      if (this.font.showDebug) {
        line(ctx, Color.Green, -ctx.canvas.width / 2, 0, ctx.canvas.width / 2, 0, 2);
        line(ctx, Color.Red, 0, -ctx.canvas.height / 2, 0, ctx.canvas.height / 2, 2);
      }
    }
    _splitTextBitmap(bitmap) {
      const textImages = [];
      let currentX = 0;
      let currentY = 0;
      const width = Math.min(4096, bitmap.canvas.width);
      const height = Math.min(4096, bitmap.canvas.height);
      while (currentX < bitmap.canvas.width) {
        while (currentY < bitmap.canvas.height) {
          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(bitmap.canvas, currentX, currentY, width, height, 0, 0, width, height);
          textImages.push({ x: currentX, y: currentY, canvas });
          currentY += height;
        }
        currentX += width;
        currentY = 0;
      }
      return textImages;
    }
    flagDirty() {
      this._dirty = true;
    }
    render(ex, x2, y2, maxWidth) {
      if (this.disposed) {
        throw Error("Accessing disposed text instance! " + this.text);
      }
      this._ex = ex;
      const hashCode = this.getHashCode();
      if (this._lastHashCode !== hashCode) {
        this._dirty = true;
      }
      if (this._dirty) {
        this.dimensions = this.measureText(this.text, maxWidth);
        this._setDimension(this.dimensions, this.ctx);
        const lines = this._getLinesFromText(this.text, maxWidth);
        const lineHeight = this.dimensions.height / lines.length;
        this._drawText(this.ctx, lines, lineHeight);
        if (ex instanceof ExcaliburGraphicsContextWebGL) {
          for (const frag of this._textFragments) {
            ex.textureLoader.delete(frag.canvas);
          }
        }
        this._textFragments = this._splitTextBitmap(this.ctx);
        if (ex instanceof ExcaliburGraphicsContextWebGL) {
          for (const frag of this._textFragments) {
            ex.textureLoader.load(frag.canvas, this.font.filtering, true);
          }
        }
        this._lastHashCode = hashCode;
        this._dirty = false;
      }
      for (const frag of this._textFragments) {
        ex.drawImage(frag.canvas, 0, 0, frag.canvas.width, frag.canvas.height, frag.x / this.font.quality + x2 - this.ctx.canvas.width / this.font.quality / 2, frag.y / this.font.quality + y2 - this.ctx.canvas.height / this.font.quality / 2, frag.canvas.width / this.font.quality, frag.canvas.height / this.font.quality);
      }
    }
    dispose() {
      this.disposed = true;
      this.dimensions = void 0;
      this.canvas = void 0;
      this.ctx = void 0;
      if (this._ex instanceof ExcaliburGraphicsContextWebGL) {
        for (const frag of this._textFragments) {
          this._ex.textureLoader.delete(frag.canvas);
        }
      }
      this._textFragments.length = 0;
    }
    _getLinesFromText(text, maxWidth) {
      if (this._chachedText === text && this._cachedRenderWidth === maxWidth) {
        return this._chachedLines;
      }
      const lines = text.split("\n");
      if (maxWidth == null) {
        return lines;
      }
      for (let i2 = 0; i2 < lines.length; i2++) {
        let line2 = lines[i2];
        let newLine = "";
        if (this.measureText(line2).width > maxWidth) {
          while (this.measureText(line2).width > maxWidth) {
            newLine = line2[line2.length - 1] + newLine;
            line2 = line2.slice(0, -1);
          }
          lines[i2] = line2;
          lines[i2 + 1] = newLine;
        }
      }
      this._chachedText = text;
      this._chachedLines = lines;
      this._cachedRenderWidth = maxWidth;
      return lines;
    }
  }
  class FontCache {
    static measureText(text, font, maxWidth) {
      const hash = FontTextInstance.getHashCode(font, text);
      if (FontCache._MEASURE_CACHE.has(hash)) {
        return FontCache._MEASURE_CACHE.get(hash);
      }
      FontCache._LOGGER.debug("Font text measurement cache miss");
      const measurement = font.measureTextWithoutCache(text, maxWidth);
      FontCache._MEASURE_CACHE.set(hash, measurement);
      return measurement;
    }
    static getTextInstance(text, font, color2) {
      const hash = FontTextInstance.getHashCode(font, text, color2);
      let textInstance = FontCache._TEXT_CACHE.get(hash);
      if (!textInstance) {
        textInstance = new FontTextInstance(font, text, color2);
        FontCache._TEXT_CACHE.set(hash, textInstance);
        FontCache._LOGGER.debug("Font text instance cache miss");
      }
      FontCache._TEXT_USAGE.set(textInstance, performance.now());
      return textInstance;
    }
    static checkAndClearCache() {
      const deferred = [];
      const currentHashCodes = /* @__PURE__ */ new Set();
      for (const [textInstance, time] of FontCache._TEXT_USAGE.entries()) {
        if (time + 100 < performance.now()) {
          FontCache._LOGGER.debug(`Text cache entry timed out ${textInstance.text}`);
          deferred.push(textInstance);
          textInstance.dispose();
        } else {
          const hash = textInstance.getHashCode(false);
          currentHashCodes.add(hash);
        }
      }
      deferred.forEach((t2) => {
        FontCache._TEXT_USAGE.delete(t2);
      });
      this._TEXT_CACHE.clear();
      for (const [textInstance] of this._TEXT_USAGE.entries()) {
        this._TEXT_CACHE.set(textInstance.getHashCode(), textInstance);
      }
      const newTextMeasurementCache = /* @__PURE__ */ new Map();
      for (const current of currentHashCodes) {
        if (FontCache._MEASURE_CACHE.has(current)) {
          newTextMeasurementCache.set(current, FontCache._MEASURE_CACHE.get(current));
        }
      }
      this._MEASURE_CACHE.clear();
      this._MEASURE_CACHE = newTextMeasurementCache;
    }
    static get cacheSize() {
      return FontCache._TEXT_USAGE.size;
    }
    /**
     * Force clear all cached text bitmaps
     */
    static clearCache() {
      for (const [textInstance] of FontCache._TEXT_USAGE.entries()) {
        textInstance.dispose();
      }
      FontCache._TEXT_USAGE.clear();
      FontCache._TEXT_CACHE.clear();
      FontCache._MEASURE_CACHE.clear();
    }
  }
  FontCache._LOGGER = Logger2.getInstance();
  FontCache._TEXT_USAGE = /* @__PURE__ */ new Map();
  FontCache._TEXT_CACHE = /* @__PURE__ */ new Map();
  FontCache._MEASURE_CACHE = /* @__PURE__ */ new Map();
  class Font extends Graphic {
    constructor(options = {}) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t2, _u;
      super(options);
      this.filtering = ImageFiltering.Blended;
      this.quality = 2;
      this.padding = 2;
      this.smoothing = false;
      this.lineWidth = 1;
      this.lineDash = [];
      this.color = Color.Black;
      this.family = "sans-serif";
      this.style = FontStyle.Normal;
      this.bold = false;
      this.unit = FontUnit.Px;
      this.textAlign = TextAlign.Left;
      this.baseAlign = BaseAlign.Alphabetic;
      this.direction = Direction.LeftToRight;
      this.size = 10;
      this.shadow = null;
      this._textBounds = new BoundingBox();
      this._textMeasurement = new FontTextInstance(this, "", Color.Black);
      this.smoothing = (_a = options === null || options === void 0 ? void 0 : options.smoothing) !== null && _a !== void 0 ? _a : this.smoothing;
      this.padding = (_b = options === null || options === void 0 ? void 0 : options.padding) !== null && _b !== void 0 ? _b : this.padding;
      this.color = (_c = options === null || options === void 0 ? void 0 : options.color) !== null && _c !== void 0 ? _c : this.color;
      this.strokeColor = (_d = options === null || options === void 0 ? void 0 : options.strokeColor) !== null && _d !== void 0 ? _d : this.strokeColor;
      this.lineDash = (_e = options === null || options === void 0 ? void 0 : options.lineDash) !== null && _e !== void 0 ? _e : this.lineDash;
      this.lineWidth = (_f = options === null || options === void 0 ? void 0 : options.lineWidth) !== null && _f !== void 0 ? _f : this.lineWidth;
      this.filtering = (_g = options === null || options === void 0 ? void 0 : options.filtering) !== null && _g !== void 0 ? _g : this.filtering;
      this.family = (_h = options === null || options === void 0 ? void 0 : options.family) !== null && _h !== void 0 ? _h : this.family;
      this.style = (_j = options === null || options === void 0 ? void 0 : options.style) !== null && _j !== void 0 ? _j : this.style;
      this.bold = (_k = options === null || options === void 0 ? void 0 : options.bold) !== null && _k !== void 0 ? _k : this.bold;
      this.size = (_l = options === null || options === void 0 ? void 0 : options.size) !== null && _l !== void 0 ? _l : this.size;
      this.unit = (_m = options === null || options === void 0 ? void 0 : options.unit) !== null && _m !== void 0 ? _m : this.unit;
      this.textAlign = (_o = options === null || options === void 0 ? void 0 : options.textAlign) !== null && _o !== void 0 ? _o : this.textAlign;
      this.baseAlign = (_p = options === null || options === void 0 ? void 0 : options.baseAlign) !== null && _p !== void 0 ? _p : this.baseAlign;
      this.direction = (_q = options === null || options === void 0 ? void 0 : options.direction) !== null && _q !== void 0 ? _q : this.direction;
      this.quality = (_r = options === null || options === void 0 ? void 0 : options.quality) !== null && _r !== void 0 ? _r : this.quality;
      if (options === null || options === void 0 ? void 0 : options.shadow) {
        this.shadow = {};
        this.shadow.blur = (_s = options.shadow.blur) !== null && _s !== void 0 ? _s : this.shadow.blur;
        this.shadow.offset = (_t2 = options.shadow.offset) !== null && _t2 !== void 0 ? _t2 : this.shadow.offset;
        this.shadow.color = (_u = options.shadow.color) !== null && _u !== void 0 ? _u : this.shadow.color;
      }
    }
    clone() {
      return new Font({
        ...this.cloneGraphicOptions(),
        size: this.size,
        unit: this.unit,
        family: this.family,
        style: this.style,
        bold: this.bold,
        textAlign: this.textAlign,
        baseAlign: this.baseAlign,
        direction: this.direction,
        shadow: this.shadow ? {
          blur: this.shadow.blur,
          offset: this.shadow.offset,
          color: this.shadow.color
        } : null
      });
    }
    get fontString() {
      return `${this.style} ${this.bold ? "bold" : ""} ${this.size}${this.unit} ${this.family}`;
    }
    get localBounds() {
      return this._textBounds;
    }
    _drawImage(_ex, _x, _y) {
    }
    _rotate(ex) {
      var _a;
      const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : this._textBounds.center;
      ex.translate(origin.x, origin.y);
      ex.rotate(this.rotation);
      ex.translate(-origin.x, -origin.y);
    }
    _flip(ex) {
      if (this.flipHorizontal) {
        ex.translate(this._textBounds.width / this.scale.x, 0);
        ex.scale(-1, 1);
      }
      if (this.flipVertical) {
        ex.translate(0, -this._textBounds.height / 2 / this.scale.y);
        ex.scale(1, -1);
      }
    }
    measureTextWithoutCache(text, maxWidth) {
      return this._textMeasurement.measureText(text, maxWidth);
    }
    /**
     * Returns a BoundingBox that is the total size of the text including multiple lines
     *
     * Does not include any padding or adjustment
     * @param text
     * @returns BoundingBox
     */
    measureText(text, maxWidth) {
      return FontCache.measureText(text, this, maxWidth);
    }
    _postDraw(ex) {
      ex.restore();
    }
    render(ex, text, colorOverride, x2, y2, maxWidth) {
      const textInstance = FontCache.getTextInstance(text, this, colorOverride);
      this._textBounds = textInstance.dimensions;
      this._preDraw(ex, x2, y2);
      textInstance.render(ex, x2, y2, maxWidth);
      this._postDraw(ex);
    }
  }
  class Text extends Graphic {
    constructor(options) {
      var _a, _b;
      super(options);
      this._text = "";
      this._textWidth = 0;
      this._textHeight = 0;
      this.font = (_a = options.font) !== null && _a !== void 0 ? _a : new Font();
      this.color = (_b = options.color) !== null && _b !== void 0 ? _b : this.color;
      this.text = options.text;
      this.maxWidth = options.maxWidth;
    }
    clone() {
      var _a, _b;
      return new Text({
        text: this.text.slice(),
        color: (_b = (_a = this.color) === null || _a === void 0 ? void 0 : _a.clone()) !== null && _b !== void 0 ? _b : Color.Black,
        font: this.font.clone(),
        maxWidth: this.maxWidth
      });
    }
    get text() {
      return this._text;
    }
    set text(value) {
      this._text = value;
      this._calculateDimension();
    }
    get font() {
      return this._font;
    }
    set font(font) {
      this._font = font;
    }
    get width() {
      if (this._textWidth === 0) {
        this._calculateDimension();
      }
      return this._textWidth * this.scale.x;
    }
    get height() {
      if (this._textHeight === 0) {
        this._calculateDimension();
      }
      return this._textHeight * this.scale.y;
    }
    _calculateDimension() {
      const { width, height } = this.font.measureText(this._text, this.maxWidth);
      this._textWidth = width;
      this._textHeight = height;
    }
    get localBounds() {
      return this.font.measureText(this._text, this.maxWidth).scale(this.scale);
    }
    _rotate(_ex) {
    }
    _flip(_ex) {
    }
    _preDraw(ex, x2, y2) {
      if (this.isStale() || this.font.isStale()) {
        this.font.flipHorizontal = this.flipHorizontal;
        this.font.flipVertical = this.flipVertical;
        this.font.rotation = this.rotation;
        this.font.origin = this.origin;
        this.font.opacity = this.opacity;
      }
      this.font.tint = this.tint;
      super._preDraw(ex, x2, y2);
    }
    _drawImage(ex, x2, y2) {
      var _a;
      let color2 = Color.Black;
      if (this.font instanceof Font) {
        color2 = (_a = this.color) !== null && _a !== void 0 ? _a : this.font.color;
      }
      const { width, height } = this.font.measureText(this._text, this.maxWidth);
      this._textWidth = width;
      this._textHeight = height;
      this.font.render(ex, this._text, color2, x2, y2, this.maxWidth);
      if (this.font.showDebug) {
        ex.debug.drawRect(x2 - width, y2 - height, width * 2, height * 2);
        if (this.maxWidth != null) {
          ex.debug.drawRect(x2, y2, this.maxWidth, this.height, {
            color: Color.Yellow
          });
        }
      }
    }
  }
  class Actor extends Entity {
    /**
     * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,
     * acceleration, mass, inertia, etc.
     */
    get body() {
      return this.get(BodyComponent);
    }
    /**
     * Access the Actor's built in [[TransformComponent]]
     */
    get transform() {
      return this.get(TransformComponent);
    }
    /**
     * Access the Actor's built in [[MotionComponent]]
     */
    get motion() {
      return this.get(MotionComponent);
    }
    /**
     * Access to the Actor's built in [[GraphicsComponent]]
     */
    get graphics() {
      return this.get(GraphicsComponent);
    }
    /**
     * Access to the Actor's built in [[ColliderComponent]]
     */
    get collider() {
      return this.get(ColliderComponent);
    }
    /**
     * Access to the Actor's built in [[PointerComponent]] config
     */
    get pointer() {
      return this.get(PointerComponent);
    }
    /**
     * Useful for quickly scripting actor behavior, like moving to a place, patrolling back and forth, blinking, etc.
     *
     *  Access to the Actor's built in [[ActionsComponent]] which forwards to the
     * [[ActionContext|Action context]] of the actor.
     */
    get actions() {
      return this.get(ActionsComponent);
    }
    /**
     * Gets the position vector of the actor in pixels
     */
    get pos() {
      return this.transform.pos;
    }
    /**
     * Sets the position vector of the actor in pixels
     */
    set pos(thePos) {
      this.transform.pos = thePos.clone();
    }
    /**
     * Gets the position vector of the actor from the last frame
     */
    get oldPos() {
      return this.body.oldPos;
    }
    /**
     * Sets the position vector of the actor in the last frame
     */
    set oldPos(thePos) {
      this.body.oldPos.setTo(thePos.x, thePos.y);
    }
    /**
     * Gets the velocity vector of the actor in pixels/sec
     */
    get vel() {
      return this.motion.vel;
    }
    /**
     * Sets the velocity vector of the actor in pixels/sec
     */
    set vel(theVel) {
      this.motion.vel = theVel.clone();
    }
    /**
     * Gets the velocity vector of the actor from the last frame
     */
    get oldVel() {
      return this.body.oldVel;
    }
    /**
     * Sets the velocity vector of the actor from the last frame
     */
    set oldVel(theVel) {
      this.body.oldVel.setTo(theVel.x, theVel.y);
    }
    /**
     * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be
     * useful to simulate a gravitational effect.
     */
    get acc() {
      return this.motion.acc;
    }
    /**
     * Sets the acceleration vector of teh actor in pixels/second/second
     */
    set acc(theAcc) {
      this.motion.acc = theAcc.clone();
    }
    /**
     * Sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
     */
    set oldAcc(theAcc) {
      this.body.oldAcc.setTo(theAcc.x, theAcc.y);
    }
    /**
     * Gets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
     */
    get oldAcc() {
      return this.body.oldAcc;
    }
    /**
     * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    get rotation() {
      return this.transform.rotation;
    }
    /**
     * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    set rotation(theAngle) {
      this.transform.rotation = theAngle;
    }
    /**
     * Gets the rotational velocity of the actor in radians/second
     */
    get angularVelocity() {
      return this.motion.angularVelocity;
    }
    /**
     * Sets the rotational velocity of the actor in radians/sec
     */
    set angularVelocity(angularVelocity) {
      this.motion.angularVelocity = angularVelocity;
    }
    get scale() {
      return this.get(TransformComponent).scale;
    }
    set scale(scale2) {
      this.get(TransformComponent).scale = scale2;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(vec2) {
      this._anchor = watch(vec2, (v2) => this._handleAnchorChange(v2));
      this._handleAnchorChange(vec2);
    }
    _handleAnchorChange(v2) {
      if (this.graphics) {
        this.graphics.anchor = v2;
      }
    }
    /**
     * Indicates whether the actor is physically in the viewport
     */
    get isOffScreen() {
      return this.hasTag("ex.offscreen");
    }
    get draggable() {
      return this._draggable;
    }
    set draggable(isDraggable) {
      if (isDraggable) {
        if (isDraggable && !this._draggable) {
          this.events.on("pointerdragstart", this._pointerDragStartHandler);
          this.events.on("pointerdragend", this._pointerDragEndHandler);
          this.events.on("pointerdragmove", this._pointerDragMoveHandler);
          this.events.on("pointerdragleave", this._pointerDragLeaveHandler);
        } else if (!isDraggable && this._draggable) {
          this.events.off("pointerdragstart", this._pointerDragStartHandler);
          this.events.off("pointerdragend", this._pointerDragEndHandler);
          this.events.off("pointerdragmove", this._pointerDragMoveHandler);
          this.events.off("pointerdragleave", this._pointerDragLeaveHandler);
        }
        this._draggable = isDraggable;
      }
    }
    /**
     * Sets the color of the actor's current graphic
     */
    get color() {
      return this._color;
    }
    set color(v2) {
      var _a;
      this._color = v2.clone();
      const defaultLayer = this.graphics.layers.default;
      const currentGraphic = (_a = defaultLayer.graphics[0]) === null || _a === void 0 ? void 0 : _a.graphic;
      if (currentGraphic instanceof Raster || currentGraphic instanceof Text) {
        currentGraphic.color = this._color;
      }
    }
    // #endregion
    /**
     *
     * @param config
     */
    constructor(config) {
      super();
      this.events = new EventEmitter2();
      this._anchor = watch(Vector.Half, (v2) => this._handleAnchorChange(v2));
      this.logger = Logger2.getInstance();
      this._draggable = false;
      this._dragging = false;
      this._pointerDragStartHandler = () => {
        this._dragging = true;
      };
      this._pointerDragEndHandler = () => {
        this._dragging = false;
      };
      this._pointerDragMoveHandler = (pe2) => {
        if (this._dragging) {
          this.pos = pe2.worldPos;
        }
      };
      this._pointerDragLeaveHandler = (pe2) => {
        if (this._dragging) {
          this.pos = pe2.worldPos;
        }
      };
      const { name, x: x2, y: y2, pos, coordPlane, scale: scale2, width, height, radius, collider, vel, acc, rotation, angularVelocity, z: z2, color: color2, visible, anchor, collisionType, collisionGroup } = {
        ...config
      };
      this._setName(name);
      this.anchor = anchor !== null && anchor !== void 0 ? anchor : Actor.defaults.anchor.clone();
      const tx = new TransformComponent();
      this.addComponent(tx);
      this.pos = pos !== null && pos !== void 0 ? pos : vec(x2 !== null && x2 !== void 0 ? x2 : 0, y2 !== null && y2 !== void 0 ? y2 : 0);
      this.rotation = rotation !== null && rotation !== void 0 ? rotation : 0;
      this.scale = scale2 !== null && scale2 !== void 0 ? scale2 : vec(1, 1);
      this.z = z2 !== null && z2 !== void 0 ? z2 : 0;
      tx.coordPlane = coordPlane !== null && coordPlane !== void 0 ? coordPlane : CoordPlane.World;
      this.addComponent(new PointerComponent());
      this.addComponent(new GraphicsComponent({
        anchor: this.anchor
      }));
      this.addComponent(new MotionComponent());
      this.vel = vel !== null && vel !== void 0 ? vel : Vector.Zero;
      this.acc = acc !== null && acc !== void 0 ? acc : Vector.Zero;
      this.angularVelocity = angularVelocity !== null && angularVelocity !== void 0 ? angularVelocity : 0;
      this.addComponent(new ActionsComponent());
      this.addComponent(new BodyComponent());
      this.body.collisionType = collisionType !== null && collisionType !== void 0 ? collisionType : CollisionType.Passive;
      if (collisionGroup) {
        this.body.group = collisionGroup;
      }
      if (collider) {
        this.addComponent(new ColliderComponent(collider));
      } else if (radius) {
        this.addComponent(new ColliderComponent(Shape.Circle(radius)));
      } else {
        if (width > 0 && height > 0) {
          this.addComponent(new ColliderComponent(Shape.Box(width, height, this.anchor)));
        } else {
          this.addComponent(new ColliderComponent());
        }
      }
      this.graphics.visible = visible !== null && visible !== void 0 ? visible : true;
      if (color2) {
        this.color = color2;
        if (width && height) {
          this.graphics.add(new Rectangle({
            color: color2,
            width,
            height
          }));
        } else if (radius) {
          this.graphics.add(new Circle({
            color: color2,
            radius
          }));
        }
      }
    }
    clone() {
      const clone = new Actor({
        color: this.color.clone(),
        anchor: this.anchor.clone()
      });
      clone.clearComponents();
      clone.processComponentRemoval();
      const components = this.getComponents();
      for (const c2 of components) {
        clone.addComponent(c2.clone(), true);
      }
      return clone;
    }
    /**
     * `onInitialize` is called before the first update of the actor. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(_engine) {
    }
    /**
     * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * @internal
     */
    _initialize(engine) {
      super._initialize(engine);
      for (const child of this.children) {
        child._initialize(engine);
      }
    }
    emit(eventName, event) {
      this.events.emit(eventName, event);
    }
    on(eventName, handler) {
      return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
      return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
      this.events.off(eventName, handler);
    }
    // #endregion
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for [[onPreKill]] lifecycle event
     * @internal
     */
    _prekill(_scene) {
      this.events.emit("prekill", new PreKillEvent(this));
      this.onPreKill(_scene);
    }
    /**
     * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`
     *
     * `onPreKill` is called directly before an actor is killed and removed from its current [[Scene]].
     */
    onPreKill(_scene) {
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for [[onPostKill]] lifecycle event
     * @internal
     */
    _postkill(_scene) {
      this.events.emit("postkill", new PostKillEvent(this));
      this.onPostKill(_scene);
    }
    /**
     * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`
     *
     * `onPostKill` is called directly after an actor is killed and remove from its current [[Scene]].
     */
    onPostKill(_scene) {
    }
    /**
     * If the current actor is a member of the scene, this will remove
     * it from the scene graph. It will no longer be drawn or updated.
     */
    kill() {
      if (this.scene) {
        this._prekill(this.scene);
        this.events.emit("kill", new KillEvent(this));
        super.kill();
        this._postkill(this.scene);
      } else {
        this.logger.warn(`Cannot kill actor named "${this.name}", it was never added to the Scene`);
      }
    }
    /**
     * If the current actor is killed, it will now not be killed.
     */
    unkill() {
      this.active = true;
    }
    /**
     * Indicates wether the actor has been killed.
     */
    isKilled() {
      return !this.active;
    }
    /**
     * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     */
    get z() {
      return this.get(TransformComponent).z;
    }
    /**
     * Sets the z-index of an actor and updates it in the drawing list for the scene.
     * The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     * @param newZ new z-index to assign
     */
    set z(newZ) {
      this.get(TransformComponent).z = newZ;
    }
    /**
     * Get the center point of an actor (global position)
     */
    get center() {
      const globalPos = this.getGlobalPos();
      return new Vector(globalPos.x + this.width / 2 - this.anchor.x * this.width, globalPos.y + this.height / 2 - this.anchor.y * this.height);
    }
    /**
     * Get the local center point of an actor
     */
    get localCenter() {
      return new Vector(this.pos.x + this.width / 2 - this.anchor.x * this.width, this.pos.y + this.height / 2 - this.anchor.y * this.height);
    }
    get width() {
      return this.collider.localBounds.width * this.getGlobalScale().x;
    }
    get height() {
      return this.collider.localBounds.height * this.getGlobalScale().y;
    }
    /**
     * Gets this actor's rotation taking into account any parent relationships
     *
     * @returns Rotation angle in radians
     */
    getGlobalRotation() {
      return this.get(TransformComponent).globalRotation;
    }
    /**
     * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation
     *
     * @returns Position in world coordinates
     */
    getGlobalPos() {
      return this.get(TransformComponent).globalPos;
    }
    /**
     * Gets the global scale of the Actor
     */
    getGlobalScale() {
      return this.get(TransformComponent).globalScale;
    }
    // #region Collision
    /**
     * Tests whether the x/y specified are contained in the actor
     * @param x  X coordinate to test (in world coordinates)
     * @param y  Y coordinate to test (in world coordinates)
     * @param recurse checks whether the x/y are contained in any child actors (if they exist).
     */
    contains(x2, y2, recurse = false) {
      const point2 = vec(x2, y2);
      const collider = this.get(ColliderComponent);
      collider.update();
      const geom = collider.get();
      if (!geom) {
        return false;
      }
      const containment = geom.contains(point2);
      if (recurse) {
        return containment || this.children.some((child) => {
          return child.contains(x2, y2, true);
        });
      }
      return containment;
    }
    /**
     * Returns true if the two actor.collider's surfaces are less than or equal to the distance specified from each other
     * @param actor     Actor to test
     * @param distance  Distance in pixels to test
     */
    within(actor, distance2) {
      const collider = this.get(ColliderComponent);
      const otherCollider = actor.get(ColliderComponent);
      const me2 = collider.get();
      const other = otherCollider.get();
      if (me2 && other) {
        return me2.getClosestLineBetween(other).getLength() <= distance2;
      }
      return false;
    }
    // #endregion
    // #region Update
    /**
     * Called by the Engine, updates the state of the actor
     * @internal
     * @param engine The reference to the current game engine
     * @param delta  The time elapsed since the last update in milliseconds
     */
    update(engine, delta) {
      this._initialize(engine);
      this._preupdate(engine, delta);
      this._postupdate(engine, delta);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an actor is updated.
     */
    onPreUpdate(_engine, _delta) {
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an actor is updated.
     */
    onPostUpdate(_engine, _delta) {
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
      this.events.emit("preupdate", new PreUpdateEvent(engine, delta, this));
      this.onPreUpdate(engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
      this.events.emit("postupdate", new PostUpdateEvent(engine, delta, this));
      this.onPostUpdate(engine, delta);
    }
  }
  Actor.defaults = {
    anchor: Vector.Half
  };
  function isScreenElement(actor) {
    return actor instanceof ScreenElement;
  }
  class ScreenElement extends Actor {
    constructor(config) {
      var _a, _b;
      super({ ...config });
      this.get(TransformComponent).coordPlane = CoordPlane.Screen;
      this.anchor = (_a = config === null || config === void 0 ? void 0 : config.anchor) !== null && _a !== void 0 ? _a : vec(0, 0);
      this.body.collisionType = (_b = config === null || config === void 0 ? void 0 : config.collisionType) !== null && _b !== void 0 ? _b : CollisionType.PreventCollision;
      this.pointer.useGraphicsBounds = true;
      this.pointer.useColliderShape = false;
      if (!(config === null || config === void 0 ? void 0 : config.collider) && (config === null || config === void 0 ? void 0 : config.width) > 0 && (config === null || config === void 0 ? void 0 : config.height) > 0) {
        this.collider.useBoxCollider(this.width, this.height, this.anchor);
      }
    }
    _initialize(engine) {
      this._engine = engine;
      super._initialize(engine);
    }
    contains(x2, y2, useWorld = true) {
      if (useWorld) {
        return super.contains(x2, y2);
      }
      const coords = this._engine.worldToScreenCoordinates(new Vector(x2, y2));
      return super.contains(coords.x, coords.y);
    }
  }
  class Timer {
    get complete() {
      return this._complete;
    }
    constructor(fcn, interval, repeats, numberOfRepeats, randomRange, random) {
      this._logger = Logger2.getInstance();
      this.id = 0;
      this._elapsedTime = 0;
      this._totalTimeAlive = 0;
      this._running = false;
      this._numberOfTicks = 0;
      this.interval = 10;
      this.repeats = false;
      this.maxNumberOfRepeats = -1;
      this.randomRange = [0, 0];
      this._baseInterval = 10;
      this._generateRandomInterval = () => {
        return this._baseInterval + this.random.integer(this.randomRange[0], this.randomRange[1]);
      };
      this._complete = false;
      this.scene = null;
      if (typeof fcn !== "function") {
        const options = fcn;
        fcn = options.fcn;
        interval = options.interval;
        repeats = options.repeats;
        numberOfRepeats = options.numberOfRepeats;
        randomRange = options.randomRange;
        random = options.random;
      }
      if (!!numberOfRepeats && numberOfRepeats >= 0) {
        this.maxNumberOfRepeats = numberOfRepeats;
        if (!repeats) {
          throw new Error("repeats must be set to true if numberOfRepeats is set");
        }
      }
      this.id = Timer._MAX_ID++;
      this._callbacks = [];
      this._baseInterval = this.interval = interval;
      if (!!randomRange) {
        if (randomRange[0] > randomRange[1]) {
          throw new Error("min value must be lower than max value for range");
        }
        this.random = random !== null && random !== void 0 ? random : new Random();
        this.randomRange = randomRange;
        this.interval = this._generateRandomInterval();
        this.on(() => {
          this.interval = this._generateRandomInterval();
        });
      }
      this.repeats = repeats || this.repeats;
      if (fcn) {
        this.on(fcn);
      }
    }
    /**
     * Adds a new callback to be fired after the interval is complete
     * @param fcn The callback to be added to the callback list, to be fired after the interval is complete.
     */
    on(fcn) {
      this._callbacks.push(fcn);
    }
    /**
     * Removes a callback from the callback list to be fired after the interval is complete.
     * @param fcn The callback to be removed from the callback list, to be fired after the interval is complete.
     */
    off(fcn) {
      const index = this._callbacks.indexOf(fcn);
      this._callbacks.splice(index, 1);
    }
    /**
     * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
     * @param delta  Number of elapsed milliseconds since the last update.
     */
    update(delta) {
      if (this._running) {
        this._totalTimeAlive += delta;
        this._elapsedTime += delta;
        if (this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats) {
          this._complete = true;
          this._running = false;
          this._elapsedTime = 0;
        }
        if (!this.complete && this._elapsedTime >= this.interval) {
          this._callbacks.forEach((c2) => {
            c2.call(this);
          });
          this._numberOfTicks++;
          if (this.repeats) {
            this._elapsedTime = 0;
          } else {
            this._complete = true;
            this._running = false;
            this._elapsedTime = 0;
          }
        }
      }
    }
    /**
     * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.
     *
     * Warning** you may need to call `timer.start()` again if the timer had completed
     * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback
     * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes
     */
    reset(newInterval, newNumberOfRepeats) {
      if (!!newInterval && newInterval >= 0) {
        this._baseInterval = this.interval = newInterval;
      }
      if (!!this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0) {
        this.maxNumberOfRepeats = newNumberOfRepeats;
        if (!this.repeats) {
          throw new Error("repeats must be set to true if numberOfRepeats is set");
        }
      }
      this._complete = false;
      this._elapsedTime = 0;
      this._numberOfTicks = 0;
    }
    get timesRepeated() {
      return this._numberOfTicks;
    }
    getTimeRunning() {
      return this._totalTimeAlive;
    }
    /**
     * @returns milliseconds until the next action callback, if complete will return 0
     */
    get timeToNextAction() {
      if (this.complete) {
        return 0;
      }
      return this.interval - this._elapsedTime;
    }
    /**
     * @returns milliseconds elapsed toward the next action
     */
    get timeElapsedTowardNextAction() {
      return this._elapsedTime;
    }
    get isRunning() {
      return this._running;
    }
    /**
     * Pauses the timer, time will no longer increment towards the next call
     */
    pause() {
      this._running = false;
      return this;
    }
    /**
     * Resumes the timer, time will now increment towards the next call.
     */
    resume() {
      this._running = true;
      return this;
    }
    /**
     * Starts the timer, if the timer was complete it will restart the timer and reset the elapsed time counter
     */
    start() {
      if (!this.scene) {
        this._logger.warn("Cannot start a timer not part of a scene, timer wont start until added");
      }
      this._running = true;
      if (this.complete) {
        this._complete = false;
        this._elapsedTime = 0;
        this._numberOfTicks = 0;
      }
      return this;
    }
    /**
     * Stops the timer and resets the elapsed time counter towards the next action invocation
     */
    stop() {
      this._running = false;
      this._elapsedTime = 0;
      this._numberOfTicks = 0;
      return this;
    }
    /**
     * Cancels the timer, preventing any further executions.
     */
    cancel() {
      this.pause();
      if (this.scene) {
        this.scene.cancelTimer(this);
      }
    }
  }
  Timer._MAX_ID = 0;
  class ParallaxComponent extends Component {
    constructor(parallaxFactor) {
      super();
      this.type = "ex.parallax";
      this.parallaxFactor = vec(1, 1);
      this.parallaxFactor = parallaxFactor !== null && parallaxFactor !== void 0 ? parallaxFactor : this.parallaxFactor;
    }
  }
  class DebugGraphicsComponent extends Component {
    constructor(draw, useTransform = true) {
      super();
      this.draw = draw;
      this.useTransform = useTransform;
      this.type = "ex.debuggraphics";
    }
  }
  const TileMapEvents = {
    PreUpdate: "preupdate",
    PostUpdate: "postupdate",
    PreDraw: "predraw",
    PostDraw: "postdraw"
  };
  class TileMap extends Entity {
    flagCollidersDirty() {
      this._collidersDirty = true;
    }
    flagTilesDirty() {
      for (let i2 = 0; i2 < this.tiles.length; i2++) {
        if (this.tiles[i2]) {
          this.tiles[i2].flagDirty();
        }
      }
    }
    get x() {
      var _a;
      return (_a = this._transform.pos.x) !== null && _a !== void 0 ? _a : 0;
    }
    set x(val) {
      var _a;
      if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) {
        this.get(TransformComponent).pos = vec(val, this.y);
      }
    }
    get y() {
      var _a, _b;
      return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos.y) !== null && _b !== void 0 ? _b : 0;
    }
    set y(val) {
      var _a;
      if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) {
        this._transform.pos = vec(this.x, val);
      }
    }
    get z() {
      var _a;
      return (_a = this._transform.z) !== null && _a !== void 0 ? _a : 0;
    }
    set z(val) {
      if (this._transform) {
        this._transform.z = val;
      }
    }
    get rotation() {
      var _a, _b;
      return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) !== null && _b !== void 0 ? _b : 0;
    }
    set rotation(val) {
      var _a;
      if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) {
        this._transform.rotation = val;
      }
    }
    get scale() {
      var _a, _b;
      return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) !== null && _b !== void 0 ? _b : Vector.One;
    }
    set scale(val) {
      var _a;
      if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) {
        this._transform.scale = val;
      }
    }
    get pos() {
      return this._transform.pos;
    }
    set pos(val) {
      this._transform.pos = val;
    }
    get vel() {
      return this._motion.vel;
    }
    set vel(val) {
      this._motion.vel = val;
    }
    emit(eventName, event) {
      this.events.emit(eventName, event);
    }
    on(eventName, handler) {
      return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
      return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
      this.events.off(eventName, handler);
    }
    /**
     * @param options
     */
    constructor(options) {
      var _a, _b;
      super(null, options.name);
      this.events = new EventEmitter2();
      this._token = 0;
      this.logger = Logger2.getInstance();
      this.tiles = [];
      this._rows = [];
      this._cols = [];
      this.renderFromTopOfGraphic = false;
      this._collidersDirty = true;
      this._originalOffsets = /* @__PURE__ */ new WeakMap();
      this.addComponent(new TransformComponent());
      this.addComponent(new MotionComponent());
      this.addComponent(new BodyComponent({
        type: CollisionType.Fixed
      }));
      this.addComponent(new GraphicsComponent({
        onPostDraw: (ctx, delta) => this.draw(ctx, delta)
      }));
      this.addComponent(new DebugGraphicsComponent((ctx) => this.debug(ctx)));
      this.addComponent(new ColliderComponent());
      this._graphics = this.get(GraphicsComponent);
      this._transform = this.get(TransformComponent);
      this._motion = this.get(MotionComponent);
      this._collider = this.get(ColliderComponent);
      this._composite = this._collider.useCompositeCollider([]);
      this._transform.pos = (_a = options.pos) !== null && _a !== void 0 ? _a : Vector.Zero;
      this._oldPos = this._transform.pos.clone();
      this._oldScale = this._transform.scale.clone();
      this.renderFromTopOfGraphic = (_b = options.renderFromTopOfGraphic) !== null && _b !== void 0 ? _b : this.renderFromTopOfGraphic;
      this.tileWidth = options.tileWidth;
      this.tileHeight = options.tileHeight;
      this.rows = options.rows;
      this.columns = options.columns;
      this.tiles = new Array(this.rows * this.columns);
      this._rows = new Array(this.rows);
      this._cols = new Array(this.columns);
      let currentCol = [];
      for (let i2 = 0; i2 < this.columns; i2++) {
        for (let j2 = 0; j2 < this.rows; j2++) {
          const cd2 = new Tile({
            x: i2,
            y: j2,
            map: this
          });
          cd2.map = this;
          this.tiles[i2 + j2 * this.columns] = cd2;
          currentCol.push(cd2);
          if (!this._rows[j2]) {
            this._rows[j2] = [];
          }
          this._rows[j2].push(cd2);
        }
        this._cols[i2] = currentCol;
        currentCol = [];
      }
      this._graphics.localBounds = new BoundingBox({
        left: 0,
        top: 0,
        right: this.columns * this.tileWidth * this.scale.x,
        bottom: this.rows * this.tileHeight * this.scale.y
      });
    }
    _initialize(engine) {
      super._initialize(engine);
      this._engine = engine;
    }
    _getOrSetColliderOriginalOffset(collider) {
      if (!this._originalOffsets.has(collider)) {
        const originalOffset = collider.offset;
        this._originalOffsets.set(collider, originalOffset);
        return originalOffset;
      } else {
        return this._originalOffsets.get(collider);
      }
    }
    /**
     * Tiles colliders based on the solid tiles in the tilemap.
     */
    _updateColliders() {
      this._collider.$colliderRemoved.notifyAll(this._composite);
      this._composite.clearColliders();
      const colliders = [];
      this._composite = this._collider.useCompositeCollider([]);
      let current;
      for (let i2 = 0; i2 < this.columns; i2++) {
        for (let j2 = 0; j2 < this.rows; j2++) {
          if (j2 === 0) {
            current = null;
          }
          const tile = this.tiles[i2 + j2 * this.columns];
          if (tile.solid) {
            if (tile.getColliders().length > 0) {
              for (const collider of tile.getColliders()) {
                const originalOffset = this._getOrSetColliderOriginalOffset(collider);
                collider.offset = vec(tile.x * this.tileWidth * this.scale.x, tile.y * this.tileHeight * this.scale.y).add(originalOffset);
                collider.owner = this;
                this._composite.addCollider(collider);
              }
              if (current) {
                colliders.push(current);
              }
              current = null;
            } else {
              if (!current) {
                current = tile.bounds;
              } else {
                current = current.combine(tile.bounds);
              }
            }
          } else {
            if (current) {
              colliders.push(current);
            }
            current = null;
          }
        }
        if (current) {
          const prev = colliders[colliders.length - 1];
          if (prev && prev.top === current.top && prev.bottom === current.bottom) {
            colliders[colliders.length - 1] = prev.combine(current);
          } else {
            colliders.push(current);
          }
        }
      }
      for (const c2 of colliders) {
        const collider = Shape.Box(c2.width, c2.height, Vector.Zero, vec(c2.left - this.pos.x, c2.top - this.pos.y));
        collider.owner = this;
        this._composite.addCollider(collider);
      }
      this._collider.update();
      this._collider.$colliderAdded.notifyAll(this._composite);
    }
    /**
     * Returns the [[Tile]] by index (row major order)
     */
    getTileByIndex(index) {
      return this.tiles[index];
    }
    /**
     * Returns the [[Tile]] by its x and y integer coordinates
     */
    getTile(x2, y2) {
      if (x2 < 0 || y2 < 0 || x2 >= this.columns || y2 >= this.rows) {
        return null;
      }
      return this.tiles[x2 + y2 * this.columns];
    }
    /**
     * Returns the [[Tile]] by testing a point in world coordinates,
     * returns `null` if no Tile was found.
     */
    getTileByPoint(point2) {
      const x2 = Math.floor((point2.x - this.pos.x) / (this.tileWidth * this.scale.x));
      const y2 = Math.floor((point2.y - this.pos.y) / (this.tileHeight * this.scale.y));
      const tile = this.getTile(x2, y2);
      if (x2 >= 0 && y2 >= 0 && x2 < this.columns && y2 < this.rows && tile) {
        return tile;
      }
      return null;
    }
    getRows() {
      return this._rows;
    }
    getColumns() {
      return this._cols;
    }
    update(engine, delta) {
      this.onPreUpdate(engine, delta);
      this.emit("preupdate", new PreUpdateEvent(engine, delta, this));
      if (!this._oldPos.equals(this.pos) || !this._oldScale.equals(this.scale)) {
        this.flagCollidersDirty();
        this.flagTilesDirty();
      }
      if (this._collidersDirty) {
        this._collidersDirty = false;
        this._updateColliders();
      }
      this._token++;
      this.pos.clone(this._oldPos);
      this.scale.clone(this._oldScale);
      this._transform.pos = this.pos;
      this.onPostUpdate(engine, delta);
      this.emit("postupdate", new PostUpdateEvent(engine, delta, this));
    }
    /**
     * Draws the tile map to the screen. Called by the [[Scene]].
     * @param ctx ExcaliburGraphicsContext
     * @param delta  The number of milliseconds since the last draw
     */
    draw(ctx, delta) {
      this.emit("predraw", new PreDrawEvent(ctx, delta, this));
      let worldBounds = this._engine.screen.getWorldBounds();
      let x2 = 0;
      const xEnd = this.columns;
      let y2 = 0;
      const yEnd = this.rows;
      let graphics, graphicsIndex, graphicsLen;
      const maybeParallax = this.get(ParallaxComponent);
      if (maybeParallax) {
        let pos = this.pos;
        const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);
        const parallaxOffset = this._engine.currentScene.camera.pos.scale(oneMinusFactor);
        pos = pos.sub(parallaxOffset);
        worldBounds = worldBounds.translate(pos);
      }
      let tile;
      for (x2; x2 < xEnd; x2++) {
        for (y2; y2 < yEnd; y2++) {
          tile = this.getTile(x2, y2);
          if (!worldBounds.overlaps(tile.bounds)) {
            continue;
          }
          graphics = this.getTile(x2, y2).getGraphics();
          for (graphicsIndex = 0, graphicsLen = graphics.length; graphicsIndex < graphicsLen; graphicsIndex++) {
            const graphic = graphics[graphicsIndex];
            if (graphic) {
              if (hasGraphicsTick(graphic)) {
                graphic === null || graphic === void 0 ? void 0 : graphic.tick(delta, this._token);
              }
              const offsetY = this.renderFromTopOfGraphic ? 0 : graphic.height - this.tileHeight;
              graphic.draw(ctx, x2 * this.tileWidth, y2 * this.tileHeight - offsetY);
            }
          }
        }
        y2 = 0;
      }
      this.emit("postdraw", new PostDrawEvent(ctx, delta, this));
    }
    debug(gfx) {
      const width = this.tileWidth * this.columns;
      const height = this.tileHeight * this.rows;
      const pos = Vector.Zero;
      for (let r2 = 0; r2 < this.rows + 1; r2++) {
        const yOffset = vec(0, r2 * this.tileHeight);
        gfx.drawLine(pos.add(yOffset), pos.add(vec(width, yOffset.y)), Color.Red, 2);
      }
      for (let c2 = 0; c2 < this.columns + 1; c2++) {
        const xOffset = vec(c2 * this.tileWidth, 0);
        gfx.drawLine(pos.add(xOffset), pos.add(vec(xOffset.x, height)), Color.Red, 2);
      }
      const colliders = this._composite.getColliders();
      for (const collider of colliders) {
        const grayish = Color.Gray;
        grayish.a = 0.5;
        const bounds = collider.localBounds;
        const pos2 = collider.worldPos.sub(this.pos);
        gfx.drawRectangle(pos2, bounds.width, bounds.height, grayish);
      }
    }
  }
  class Tile extends Entity {
    // private _transform: TransformComponent;
    /**
     * Return the world position of the top left corner of the tile
     */
    get pos() {
      if (this._posDirty) {
        this._recalculate();
        this._posDirty = false;
      }
      return this._pos;
    }
    /**
     * Width of the tile in pixels
     */
    get width() {
      return this._width;
    }
    /**
     * Height of the tile in pixels
     */
    get height() {
      return this._height;
    }
    /**
     * Wether this tile should be treated as solid by the tilemap
     */
    get solid() {
      return this._solid;
    }
    /**
     * Wether this tile should be treated as solid by the tilemap
     */
    set solid(val) {
      var _a;
      (_a = this.map) === null || _a === void 0 ? void 0 : _a.flagCollidersDirty();
      this._solid = val;
    }
    /**
     * Current list of graphics for this tile
     */
    getGraphics() {
      return this._graphics;
    }
    /**
     * Add another [[Graphic]] to this TileMap tile
     * @param graphic
     */
    addGraphic(graphic) {
      this._graphics.push(graphic);
    }
    /**
     * Remove an instance of a [[Graphic]] from this tile
     */
    removeGraphic(graphic) {
      removeItemFromArray(graphic, this._graphics);
    }
    /**
     * Clear all graphics from this tile
     */
    clearGraphics() {
      this._graphics.length = 0;
    }
    /**
     * Returns the list of colliders
     */
    getColliders() {
      return this._colliders;
    }
    /**
     * Adds a custom collider to the [[Tile]] to use instead of it's bounds
     *
     * If no collider is set but [[Tile.solid]] is set, the tile bounds are used as a collider.
     *
     * **Note!** the [[Tile.solid]] must be set to true for it to act as a "fixed" collider
     * @param collider
     */
    addCollider(collider) {
      this._colliders.push(collider);
      this.map.flagCollidersDirty();
    }
    /**
     * Removes a collider from the [[Tile]]
     * @param collider
     */
    removeCollider(collider) {
      const index = this._colliders.indexOf(collider);
      if (index > -1) {
        this._colliders.splice(index, 1);
      }
      this.map.flagCollidersDirty();
    }
    /**
     * Clears all colliders from the [[Tile]]
     */
    clearColliders() {
      this._colliders.length = 0;
      this.map.flagCollidersDirty();
    }
    constructor(options) {
      var _a, _b;
      super();
      this._posDirty = false;
      this._solid = false;
      this._graphics = [];
      this._colliders = [];
      this.data = /* @__PURE__ */ new Map();
      this.x = options.x;
      this.y = options.y;
      this.map = options.map;
      this._width = options.map.tileWidth * this.map.scale.x;
      this._height = options.map.tileHeight * this.map.scale.y;
      this.solid = (_a = options.solid) !== null && _a !== void 0 ? _a : this.solid;
      this._graphics = (_b = options.graphics) !== null && _b !== void 0 ? _b : [];
      this._recalculate();
    }
    flagDirty() {
      return this._posDirty = true;
    }
    _recalculate() {
      this._width = this.map.tileWidth * this.map.scale.x;
      this._height = this.map.tileHeight * this.map.scale.y;
      this._pos = this.map.pos.add(vec(this.x * this._width, this.y * this._height));
      this._bounds = new BoundingBox(this._pos.x, this._pos.y, this._pos.x + this._width, this._pos.y + this._height);
      this._posDirty = false;
    }
    /**
     * Tile bounds in world space
     */
    get bounds() {
      if (this._posDirty) {
        this._recalculate();
      }
      return this._bounds;
    }
    /**
     * Tile position in world space
     */
    get center() {
      if (this._posDirty) {
        this._recalculate();
      }
      return new Vector(this._pos.x + this._width / 2, this._pos.y + this._height / 2);
    }
  }
  class StrategyContainer {
    constructor(camera) {
      this.camera = camera;
    }
    /**
     * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.
     * @param actor The actor to lock the camera to
     */
    lockToActor(actor) {
      this.camera.addStrategy(new LockCameraToActorStrategy(actor));
    }
    /**
     * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera
     * @param actor The actor to lock the camera to
     * @param axis The axis to follow the actor on
     */
    lockToActorAxis(actor, axis) {
      this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));
    }
    /**
     * Creates and adds the [[ElasticToActorStrategy]] on the current camera
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     *
     * @param actor Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    elasticToActor(actor, cameraElasticity, cameraFriction) {
      this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));
    }
    /**
     * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera
     * @param actor Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    radiusAroundActor(actor, radius) {
      this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));
    }
    /**
     * Creates and adds the [[LimitCameraBoundsStrategy]] on the current camera
     * @param box The bounding box to limit the camera to.
     */
    limitCameraBounds(box) {
      this.camera.addStrategy(new LimitCameraBoundsStrategy(box));
    }
  }
  var Axis;
  (function(Axis2) {
    Axis2[Axis2["X"] = 0] = "X";
    Axis2[Axis2["Y"] = 1] = "Y";
  })(Axis || (Axis = {}));
  class LockCameraToActorStrategy {
    constructor(target) {
      this.target = target;
      this.action = (target2, _cam, _eng, _delta) => {
        const center = target2.center;
        return center;
      };
    }
  }
  class LockCameraToActorAxisStrategy {
    constructor(target, axis) {
      this.target = target;
      this.axis = axis;
      this.action = (target2, cam, _eng, _delta) => {
        const center = target2.center;
        const currentFocus = cam.getFocus();
        if (this.axis === Axis.X) {
          return new Vector(center.x, currentFocus.y);
        } else {
          return new Vector(currentFocus.x, center.y);
        }
      };
    }
  }
  class ElasticToActorStrategy {
    /**
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     *
     * @param target Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    constructor(target, cameraElasticity, cameraFriction) {
      this.target = target;
      this.cameraElasticity = cameraElasticity;
      this.cameraFriction = cameraFriction;
      this.action = (target2, cam, _eng, _delta) => {
        const position = target2.center;
        let focus = cam.getFocus();
        let cameraVel = cam.vel.clone();
        const stretch = position.sub(focus).scale(this.cameraElasticity);
        cameraVel = cameraVel.add(stretch);
        const friction = cameraVel.scale(-1).scale(this.cameraFriction);
        cameraVel = cameraVel.add(friction);
        focus = focus.add(cameraVel);
        return focus;
      };
    }
  }
  class RadiusAroundActorStrategy {
    /**
     *
     * @param target Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    constructor(target, radius) {
      this.target = target;
      this.radius = radius;
      this.action = (target2, cam, _eng, _delta) => {
        const position = target2.center;
        const focus = cam.getFocus();
        const direction = position.sub(focus);
        const distance2 = direction.size;
        if (distance2 >= this.radius) {
          const offset = distance2 - this.radius;
          return focus.add(direction.normalize().scale(offset));
        }
        return focus;
      };
    }
  }
  class LimitCameraBoundsStrategy {
    constructor(target) {
      this.target = target;
      this.boundSizeChecked = false;
      this.action = (target2, cam, _eng, _delta) => {
        const focus = cam.getFocus();
        if (!this.boundSizeChecked) {
          if (target2.bottom - target2.top < _eng.drawHeight || target2.right - target2.left < _eng.drawWidth) {
            Logger2.getInstance().warn("Camera bounds should not be smaller than the engine viewport");
          }
          this.boundSizeChecked = true;
        }
        let focusX = focus.x;
        let focusY = focus.y;
        if (focus.x < target2.left + _eng.halfDrawWidth) {
          focusX = target2.left + _eng.halfDrawWidth;
        } else if (focus.x > target2.right - _eng.halfDrawWidth) {
          focusX = target2.right - _eng.halfDrawWidth;
        }
        if (focus.y < target2.top + _eng.halfDrawHeight) {
          focusY = target2.top + _eng.halfDrawHeight;
        } else if (focus.y > target2.bottom - _eng.halfDrawHeight) {
          focusY = target2.bottom - _eng.halfDrawHeight;
        }
        return vec(focusX, focusY);
      };
    }
  }
  const CameraEvents = {
    Initialize: "initialize",
    PreUpdate: "preupdate",
    PostUpdate: "postupdate"
  };
  class Camera {
    constructor() {
      this.events = new EventEmitter2();
      this.transform = AffineMatrix.identity();
      this.inverse = AffineMatrix.identity();
      this._cameraStrategies = [];
      this.strategy = new StrategyContainer(this);
      this._z = 1;
      this.dz = 0;
      this.az = 0;
      this.rotation = 0;
      this._angularVelocity = 0;
      this._posChanged = false;
      this._pos = watchAny(Vector.Zero, () => this._posChanged = true);
      this.vel = Vector.Zero;
      this.acc = Vector.Zero;
      this._cameraMoving = false;
      this._currentLerpTime = 0;
      this._lerpDuration = 1e3;
      this._lerpStart = null;
      this._lerpEnd = null;
      this._isShaking = false;
      this._shakeMagnitudeX = 0;
      this._shakeMagnitudeY = 0;
      this._shakeDuration = 0;
      this._elapsedShakeTime = 0;
      this._xShake = 0;
      this._yShake = 0;
      this._isZooming = false;
      this._zoomStart = 1;
      this._zoomEnd = 1;
      this._currentZoomTime = 0;
      this._zoomDuration = 0;
      this._zoomEasing = EasingFunctions.EaseInOutCubic;
      this._easing = EasingFunctions.EaseInOutCubic;
      this._halfWidth = 0;
      this._halfHeight = 0;
      this._viewport = null;
      this._isInitialized = false;
    }
    get zoom() {
      return this._z;
    }
    set zoom(val) {
      this._z = val;
      if (this._engine) {
        this._halfWidth = this._engine.halfDrawWidth;
        this._halfHeight = this._engine.halfDrawHeight;
      }
    }
    /**
     * Get or set the camera's angular velocity
     */
    get angularVelocity() {
      return this._angularVelocity;
    }
    set angularVelocity(value) {
      this._angularVelocity = value;
    }
    get pos() {
      return this._pos;
    }
    set pos(vec2) {
      this._pos = watchAny(vec2, () => this._posChanged = true);
      this._posChanged = true;
    }
    /**
     * Get the camera's x position
     */
    get x() {
      return this.pos.x;
    }
    /**
     * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)
     */
    set x(value) {
      if (!this._follow && !this._cameraMoving) {
        this.pos = vec(value, this.pos.y);
      }
    }
    /**
     * Get the camera's y position
     */
    get y() {
      return this.pos.y;
    }
    /**
     * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)
     */
    set y(value) {
      if (!this._follow && !this._cameraMoving) {
        this.pos = vec(this.pos.x, value);
      }
    }
    /**
     * Get or set the camera's x velocity
     */
    get dx() {
      return this.vel.x;
    }
    set dx(value) {
      this.vel = vec(value, this.vel.y);
    }
    /**
     * Get or set the camera's y velocity
     */
    get dy() {
      return this.vel.y;
    }
    set dy(value) {
      this.vel = vec(this.vel.x, value);
    }
    /**
     * Get or set the camera's x acceleration
     */
    get ax() {
      return this.acc.x;
    }
    set ax(value) {
      this.acc = vec(value, this.acc.y);
    }
    /**
     * Get or set the camera's y acceleration
     */
    get ay() {
      return this.acc.y;
    }
    set ay(value) {
      this.acc = vec(this.acc.x, value);
    }
    /**
     * Returns the focal point of the camera, a new point giving the x and y position of the camera
     */
    getFocus() {
      return this.pos;
    }
    /**
     * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.
     *
     * @param pos The target position to move to
     * @param duration The duration in milliseconds the move should last
     * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)
     * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.
     *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.
     */
    move(pos, duration, easingFn = EasingFunctions.EaseInOutCubic) {
      if (typeof easingFn !== "function") {
        throw "Please specify an EasingFunction";
      }
      if (this._follow) {
        return Promise.reject(pos);
      }
      if (this._lerpPromise && this._lerpResolve) {
        this._lerpResolve(pos);
      }
      this._lerpPromise = new Promise((resolve) => {
        this._lerpResolve = resolve;
      });
      this._lerpStart = this.getFocus().clone();
      this._lerpDuration = duration;
      this._lerpEnd = pos;
      this._currentLerpTime = 0;
      this._cameraMoving = true;
      this._easing = easingFn;
      return this._lerpPromise;
    }
    /**
     * Sets the camera to shake at the specified magnitudes for the specified duration
     * @param magnitudeX  The x magnitude of the shake
     * @param magnitudeY  The y magnitude of the shake
     * @param duration    The duration of the shake in milliseconds
     */
    shake(magnitudeX, magnitudeY, duration) {
      this._isShaking = true;
      this._shakeMagnitudeX = magnitudeX;
      this._shakeMagnitudeY = magnitudeY;
      this._shakeDuration = duration;
    }
    /**
     * Zooms the camera in or out by the specified scale over the specified duration.
     * If no duration is specified, it take effect immediately.
     * @param scale    The scale of the zoom
     * @param duration The duration of the zoom in milliseconds
     */
    zoomOverTime(scale2, duration = 0, easingFn = EasingFunctions.EaseInOutCubic) {
      this._zoomPromise = new Promise((resolve) => {
        this._zoomResolve = resolve;
      });
      if (duration) {
        this._isZooming = true;
        this._zoomEasing = easingFn;
        this._currentZoomTime = 0;
        this._zoomDuration = duration;
        this._zoomStart = this.zoom;
        this._zoomEnd = scale2;
      } else {
        this._isZooming = false;
        this.zoom = scale2;
        return Promise.resolve(true);
      }
      return this._zoomPromise;
    }
    /**
     * Gets the bounding box of the viewport of this camera in world coordinates
     */
    get viewport() {
      if (this._viewport) {
        return this._viewport;
      }
      return new BoundingBox(0, 0, 0, 0);
    }
    /**
     * Adds a new camera strategy to this camera
     * @param cameraStrategy Instance of an [[CameraStrategy]]
     */
    addStrategy(cameraStrategy) {
      this._cameraStrategies.push(cameraStrategy);
    }
    /**
     * Removes a camera strategy by reference
     * @param cameraStrategy Instance of an [[CameraStrategy]]
     */
    removeStrategy(cameraStrategy) {
      removeItemFromArray(cameraStrategy, this._cameraStrategies);
    }
    /**
     * Clears all camera strategies from the camera
     */
    clearAllStrategies() {
      this._cameraStrategies.length = 0;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
      this.events.emit("preupdate", new PreUpdateEvent(engine, delta, this));
      this.onPreUpdate(engine, delta);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     */
    onPreUpdate(_engine, _delta) {
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
      this.events.emit("postupdate", new PostUpdateEvent(engine, delta, this));
      this.onPostUpdate(engine, delta);
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onPostUpdate(_engine, _delta) {
    }
    get isInitialized() {
      return this._isInitialized;
    }
    _initialize(_engine) {
      if (!this.isInitialized) {
        this._engine = _engine;
        this._screen = _engine.screen;
        const currentRes = this._screen.contentArea;
        let center = vec(currentRes.width / 2, currentRes.height / 2);
        if (!this._engine.loadingComplete) {
          const res = this._screen.peekResolution();
          if (res) {
            center = vec(res.width / 2, res.height / 2);
          }
        }
        this._halfWidth = center.x;
        this._halfHeight = center.y;
        if (!this._posChanged) {
          this.pos = center;
        }
        this.updateTransform();
        this.runStrategies(_engine, _engine.clock.elapsed());
        this.updateViewport();
        this.updateTransform();
        this.onInitialize(_engine);
        this.events.emit("initialize", new InitializeEvent(_engine, this));
        this._isInitialized = true;
      }
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onInitialize(_engine) {
    }
    emit(eventName, event) {
      this.events.emit(eventName, event);
    }
    on(eventName, handler) {
      return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
      return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
      this.events.off(eventName, handler);
    }
    runStrategies(engine, delta) {
      for (const s2 of this._cameraStrategies) {
        this.pos = s2.action.call(s2, s2.target, this, engine, delta);
      }
    }
    updateViewport() {
      this._viewport = new BoundingBox(this.x - this._halfWidth, this.y - this._halfHeight, this.x + this._halfWidth, this.y + this._halfHeight);
    }
    update(_engine, delta) {
      this._initialize(_engine);
      this._preupdate(_engine, delta);
      this.pos = this.pos.add(this.vel.scale(delta / 1e3));
      this.zoom += this.dz * delta / 1e3;
      this.vel = this.vel.add(this.acc.scale(delta / 1e3));
      this.dz += this.az * delta / 1e3;
      this.rotation += this.angularVelocity * delta / 1e3;
      if (this._isZooming) {
        if (this._currentZoomTime < this._zoomDuration) {
          const zoomEasing = this._zoomEasing;
          const newZoom = zoomEasing(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);
          this.zoom = newZoom;
          this._currentZoomTime += delta;
        } else {
          this._isZooming = false;
          this.zoom = this._zoomEnd;
          this._currentZoomTime = 0;
          this._zoomResolve(true);
        }
      }
      if (this._cameraMoving) {
        if (this._currentLerpTime < this._lerpDuration) {
          const moveEasing = EasingFunctions.CreateVectorEasingFunction(this._easing);
          const lerpPoint = moveEasing(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration);
          this.pos = lerpPoint;
          this._currentLerpTime += delta;
        } else {
          this.pos = this._lerpEnd;
          const end = this._lerpEnd.clone();
          this._lerpStart = null;
          this._lerpEnd = null;
          this._currentLerpTime = 0;
          this._cameraMoving = false;
          this._lerpResolve(end);
        }
      }
      if (this._isDoneShaking()) {
        this._isShaking = false;
        this._elapsedShakeTime = 0;
        this._shakeMagnitudeX = 0;
        this._shakeMagnitudeY = 0;
        this._shakeDuration = 0;
        this._xShake = 0;
        this._yShake = 0;
      } else {
        this._elapsedShakeTime += delta;
        this._xShake = (Math.random() * this._shakeMagnitudeX | 0) + 1;
        this._yShake = (Math.random() * this._shakeMagnitudeY | 0) + 1;
      }
      this.runStrategies(_engine, delta);
      this.updateViewport();
      this.updateTransform();
      this._postupdate(_engine, delta);
    }
    /**
     * Applies the relevant transformations to the game canvas to "move" or apply effects to the Camera
     * @param ctx Canvas context to apply transformations
     */
    draw(ctx) {
      ctx.multiply(this.transform);
    }
    updateTransform() {
      const newCanvasWidth = this._screen.resolution.width / this.zoom;
      const newCanvasHeight = this._screen.resolution.height / this.zoom;
      const cameraPos = vec(-this.x + newCanvasWidth / 2 + this._xShake, -this.y + newCanvasHeight / 2 + this._yShake);
      this.transform.reset();
      this.transform.scale(this.zoom, this.zoom);
      this.transform.translate(newCanvasWidth / 2, newCanvasHeight / 2);
      this.transform.rotate(this.rotation);
      this.transform.translate(-newCanvasWidth / 2, -newCanvasHeight / 2);
      this.transform.translate(cameraPos.x, cameraPos.y);
      this.transform.inverse(this.inverse);
    }
    _isDoneShaking() {
      return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;
    }
  }
  const TriggerEvents = {
    ExitTrigger: "exittrigger",
    EnterTrigger: "entertrigger"
  };
  const triggerDefaults = {
    pos: Vector.Zero,
    width: 10,
    height: 10,
    visible: false,
    action: () => {
      return;
    },
    filter: () => true,
    repeat: -1
  };
  class Trigger extends Actor {
    /**
     *
     * @param opts Trigger options
     */
    constructor(opts) {
      super({ x: opts.pos.x, y: opts.pos.y, width: opts.width, height: opts.height });
      this.events = new EventEmitter2();
      this.action = () => {
        return;
      };
      this.filter = () => true;
      this.repeat = -1;
      opts = {
        ...triggerDefaults,
        ...opts
      };
      this.filter = opts.filter || this.filter;
      this.repeat = opts.repeat || this.repeat;
      this.action = opts.action || this.action;
      if (opts.target) {
        this.target = opts.target;
      }
      this.graphics.visible = opts.visible;
      this.body.collisionType = CollisionType.Passive;
      this.events.on("collisionstart", (evt) => {
        if (this.filter(evt.other)) {
          this.emit("enter", new EnterTriggerEvent(this, evt.other));
          this._dispatchAction();
          if (this.repeat === 0) {
            this.kill();
          }
        }
      });
      this.events.on("collisionend", (evt) => {
        if (this.filter(evt.other)) {
          this.emit("exit", new ExitTriggerEvent(this, evt.other));
        }
      });
    }
    set target(target) {
      this._target = target;
      this.filter = (actor) => actor === target;
    }
    get target() {
      return this._target;
    }
    _initialize(engine) {
      super._initialize(engine);
    }
    _dispatchAction() {
      if (this.repeat !== 0) {
        this.action.call(this);
        this.repeat--;
      }
    }
  }
  var SystemType;
  (function(SystemType2) {
    SystemType2["Update"] = "update";
    SystemType2["Draw"] = "draw";
  })(SystemType || (SystemType = {}));
  class System {
    constructor() {
      this.priority = 0;
    }
    /**
     * Systems observe when entities match their types or no longer match their types, override
     * @param _entityAddedOrRemoved
     */
    notify(_entityAddedOrRemoved) {
    }
  }
  class AddedEntity {
    constructor(data) {
      this.data = data;
      this.type = "Entity Added";
    }
  }
  function isAddedSystemEntity(x2) {
    return !!x2 && x2.type === "Entity Added";
  }
  class RemovedEntity {
    constructor(data) {
      this.data = data;
      this.type = "Entity Removed";
    }
  }
  function isRemoveSystemEntity(x2) {
    return !!x2 && x2.type === "Entity Removed";
  }
  class EntityManager {
    constructor(_world) {
      this._world = _world;
      this.entities = [];
      this._entityIndex = {};
      this._entitiesToRemove = [];
    }
    /**
     * Runs the entity lifecycle
     * @param _context
     */
    updateEntities(_context, elapsed) {
      for (const entity of this.entities) {
        entity.update(_context.engine, elapsed);
        if (!entity.active) {
          this.removeEntity(entity);
        }
      }
    }
    findEntitiesForRemoval() {
      for (const entity of this.entities) {
        if (!entity.active) {
          this.removeEntity(entity);
        }
      }
    }
    /**
     * EntityManager observes changes on entities
     * @param message
     */
    notify(message) {
      if (isAddedComponent(message)) {
        this._world.queryManager.addEntity(message.data.entity);
      }
      if (isRemovedComponent(message)) {
        this._world.queryManager.removeComponent(message.data.entity, message.data.component);
      }
    }
    /**
     * Adds an entity to be tracked by the EntityManager
     * @param entity
     */
    addEntity(entity) {
      entity.active = true;
      entity.scene = this._world.context;
      if (entity && !this._entityIndex[entity.id]) {
        this._entityIndex[entity.id] = entity;
        this.entities.push(entity);
        this._world.queryManager.addEntity(entity);
        entity.componentAdded$.register(this);
        entity.componentRemoved$.register(this);
        entity.children.forEach((c2) => {
          c2.scene = entity.scene;
          this.addEntity(c2);
        });
        entity.childrenAdded$.register({
          notify: (e2) => {
            this.addEntity(e2);
          }
        });
        entity.childrenRemoved$.register({
          notify: (e2) => {
            this.removeEntity(e2, false);
          }
        });
      }
    }
    removeEntity(idOrEntity, deferred = true) {
      var _a;
      let id2 = 0;
      if (idOrEntity instanceof Entity) {
        id2 = idOrEntity.id;
      } else {
        id2 = idOrEntity;
      }
      const entity = this._entityIndex[id2];
      if (entity && entity.active) {
        entity.active = false;
      }
      if (entity && deferred) {
        this._entitiesToRemove.push(entity);
        return;
      }
      delete this._entityIndex[id2];
      if (entity) {
        entity.scene = null;
        removeItemFromArray(entity, this.entities);
        this._world.queryManager.removeEntity(entity);
        entity.componentAdded$.unregister(this);
        entity.componentRemoved$.unregister(this);
        entity.children.forEach((c2) => {
          c2.scene = null;
          this.removeEntity(c2, deferred);
        });
        entity.childrenAdded$.clear();
        entity.childrenRemoved$.clear();
        if ((_a = this._world.context) === null || _a === void 0 ? void 0 : _a.engine) {
          this._world.context.engine.stats.currFrame.actors.killed++;
        }
      }
    }
    processEntityRemovals() {
      for (const entity of this._entitiesToRemove) {
        if (entity.active) {
          continue;
        }
        this.removeEntity(entity, false);
      }
      this._entitiesToRemove.length = 0;
    }
    processComponentRemovals() {
      for (const entity of this.entities) {
        entity.processComponentRemoval();
      }
    }
    getById(id2) {
      return this._entityIndex[id2];
    }
    getByName(name) {
      return this.entities.filter((e2) => e2.name === name);
    }
    clear() {
      for (const entity of this.entities) {
        this.removeEntity(entity);
      }
    }
  }
  const buildTypeKey = (types2) => {
    const key = [...types2].sort((a2, b2) => a2.localeCompare(b2)).join("+");
    return key;
  };
  class Query extends Observable {
    get key() {
      if (this._key) {
        return this._key;
      }
      return this._key = buildTypeKey(this.types);
    }
    constructor(types2) {
      super();
      this._entities = [];
      if (types2[0] instanceof Function) {
        this.types = types2.map((T2) => new T2().type);
      } else {
        this.types = types2;
      }
    }
    /**
     * Returns a list of entities that match the query
     *
     * @param sort Optional sorting function to sort entities returned from the query
     */
    getEntities(sort) {
      if (sort) {
        this._entities.sort(sort);
      }
      return this._entities;
    }
    /**
     * Add an entity to the query, will only be added if the entity matches the query types
     * @param entity
     */
    addEntity(entity) {
      if (!contains(this._entities, entity) && this.matches(entity)) {
        this._entities.push(entity);
        this.notifyAll(new AddedEntity(entity));
      }
    }
    /**
     * If the entity is part of the query it will be removed regardless of types
     * @param entity
     */
    removeEntity(entity) {
      if (removeItemFromArray(entity, this._entities)) {
        this.notifyAll(new RemovedEntity(entity));
      }
    }
    /**
     * Removes all entities and observers from the query
     */
    clear() {
      this._entities.length = 0;
      for (const observer of this.observers) {
        this.unregister(observer);
      }
    }
    matches(typesOrEntity) {
      let types2 = [];
      if (typesOrEntity instanceof Entity) {
        types2 = typesOrEntity.types;
      } else {
        types2 = typesOrEntity;
      }
      let matches = true;
      for (const type of this.types) {
        matches = matches && types2.indexOf(type) > -1;
        if (!matches) {
          return false;
        }
      }
      return matches;
    }
    contain(type) {
      return this.types.indexOf(type) > -1;
    }
  }
  class QueryManager {
    constructor(_world) {
      this._world = _world;
      this._queries = {};
    }
    /**
     * Adds a query to the manager and populates with any entities that match
     * @param query
     */
    _addQuery(query) {
      this._queries[buildTypeKey(query.types)] = query;
      for (const entity of this._world.entityManager.entities) {
        query.addEntity(entity);
      }
    }
    /**
     * Removes the query if there are no observers left
     * @param query
     */
    maybeRemoveQuery(query) {
      if (query.observers.length === 0) {
        query.clear();
        delete this._queries[buildTypeKey(query.types)];
      }
    }
    /**
     * Adds the entity to any matching query in the query manage
     * @param entity
     */
    addEntity(entity) {
      for (const queryType in this._queries) {
        if (this._queries[queryType]) {
          this._queries[queryType].addEntity(entity);
        }
      }
    }
    /**
     * Removes an entity from queries if the removed component disqualifies it
     * @param entity
     * @param component
     */
    removeComponent(entity, component) {
      for (const queryType in this._queries) {
        if (this._queries[queryType].contain(component.type)) {
          this._queries[queryType].removeEntity(entity);
        }
      }
    }
    /**
     * Removes an entity from all queries it is currently a part of
     * @param entity
     */
    removeEntity(entity) {
      for (const queryType in this._queries) {
        this._queries[queryType].removeEntity(entity);
      }
    }
    /**
     * Creates a populated query and returns, if the query already exists that will be returned instead of a new instance
     * @param types
     */
    createQuery(types2) {
      const maybeExistingQuery = this.getQuery(types2);
      if (maybeExistingQuery) {
        return maybeExistingQuery;
      }
      const query = new Query(types2);
      this._addQuery(query);
      return query;
    }
    /**
     * Retrieves an existing query by types if it exists otherwise returns null
     * @param types
     */
    getQuery(types2) {
      const key = buildTypeKey(types2);
      if (this._queries[key]) {
        return this._queries[key];
      }
      return null;
    }
  }
  class SystemManager {
    constructor(_world) {
      this._world = _world;
      this.systems = [];
      this.initialized = false;
    }
    /**
     * Get a system registered in the manager by type
     * @param systemType
     */
    get(systemType) {
      return this.systems.find((s2) => s2 instanceof systemType);
    }
    /**
     * Adds a system to the manager, it will now be updated every frame
     * @param system
     */
    addSystem(system) {
      if (!system.types || system.types.length === 0) {
        throw new Error(`Attempted to add a System without any types`);
      }
      const query = this._world.queryManager.createQuery(system.types);
      this.systems.push(system);
      this.systems.sort((a2, b2) => a2.priority - b2.priority);
      query.register(system);
      if (this.initialized && system.initialize) {
        system.initialize(this._world.context);
      }
    }
    /**
     * Removes a system from the manager, it will no longer be updated
     * @param system
     */
    removeSystem(system) {
      removeItemFromArray(system, this.systems);
      const query = this._world.queryManager.getQuery(system.types);
      if (query) {
        query.unregister(system);
        this._world.queryManager.maybeRemoveQuery(query);
      }
    }
    /**
     * Initialize all systems in the manager
     *
     * Systems added after initialize() will be initialized on add
     */
    initialize() {
      if (!this.initialized) {
        this.initialized = true;
        for (const s2 of this.systems) {
          if (s2.initialize) {
            s2.initialize(this._world.context);
          }
        }
      }
    }
    /**
     * Updates all systems
     * @param type whether this is an update or draw system
     * @param context context reference
     * @param delta time in milliseconds
     */
    updateSystems(type, context, delta) {
      const systems = this.systems.filter((s2) => s2.systemType === type);
      for (const s2 of systems) {
        if (s2.preupdate) {
          s2.preupdate(context, delta);
        }
      }
      for (const s2 of systems) {
        const entities = this._world.queryManager.getQuery(s2.types).getEntities(s2.sort);
        if (context instanceof Scene) {
          for (const entity of entities) {
            entity._initialize(context === null || context === void 0 ? void 0 : context.engine);
          }
        }
        s2.update(entities, delta);
      }
      for (const s2 of systems) {
        if (s2.postupdate) {
          s2.postupdate(context, delta);
        }
      }
    }
    clear() {
      for (const system of this.systems) {
        this.removeSystem(system);
      }
    }
  }
  class World {
    /**
     * The context type is passed to the system updates
     * @param context
     */
    constructor(context) {
      this.context = context;
      this.queryManager = new QueryManager(this);
      this.entityManager = new EntityManager(this);
      this.systemManager = new SystemManager(this);
    }
    /**
     * Update systems by type and time elapsed in milliseconds
     */
    update(type, delta) {
      if (type === SystemType.Update) {
        this.entityManager.updateEntities(this.context, delta);
      }
      this.systemManager.updateSystems(type, this.context, delta);
      this.entityManager.findEntitiesForRemoval();
      this.entityManager.processComponentRemovals();
      this.entityManager.processEntityRemovals();
    }
    add(entityOrSystem) {
      if (entityOrSystem instanceof Entity) {
        this.entityManager.addEntity(entityOrSystem);
      }
      if (entityOrSystem instanceof System) {
        this.systemManager.addSystem(entityOrSystem);
      }
    }
    remove(entityOrSystem, deferred = true) {
      if (entityOrSystem instanceof Entity) {
        this.entityManager.removeEntity(entityOrSystem, deferred);
      }
      if (entityOrSystem instanceof System) {
        this.systemManager.removeSystem(entityOrSystem);
      }
    }
    clearEntities() {
      this.entityManager.clear();
    }
    clearSystems() {
      this.systemManager.clear();
    }
  }
  class EulerIntegrator {
    static integrate(transform, motion2, totalAcc, elapsedMs) {
      const seconds = elapsedMs / 1e3;
      motion2.vel.addEqual(totalAcc.scale(seconds, EulerIntegrator._ACC));
      transform.pos.add(motion2.vel.scale(seconds, EulerIntegrator._VEL), EulerIntegrator._POS).addEqual(totalAcc.scale(0.5 * seconds * seconds, EulerIntegrator._VEL_ACC));
      motion2.angularVelocity += motion2.torque * (1 / motion2.inertia) * seconds;
      const rotation = transform.rotation + motion2.angularVelocity * seconds;
      transform.scale.add(motion2.scaleFactor.scale(seconds, this._SCALE_FACTOR), EulerIntegrator._SCALE);
      const tx = transform.get();
      tx.setTransform(EulerIntegrator._POS, rotation, EulerIntegrator._SCALE);
    }
  }
  EulerIntegrator._POS = new Vector(0, 0);
  EulerIntegrator._SCALE = new Vector(1, 1);
  EulerIntegrator._ACC = new Vector(0, 0);
  EulerIntegrator._VEL = new Vector(0, 0);
  EulerIntegrator._VEL_ACC = new Vector(0, 0);
  EulerIntegrator._SCALE_FACTOR = new Vector(0, 0);
  class MotionSystem extends System {
    constructor() {
      super(...arguments);
      this.types = ["ex.transform", "ex.motion"];
      this.systemType = SystemType.Update;
      this.priority = -1;
    }
    update(entities, elapsedMs) {
      let transform;
      let motion2;
      for (let i2 = 0; i2 < entities.length; i2++) {
        transform = entities[i2].get(TransformComponent);
        motion2 = entities[i2].get(MotionComponent);
        const optionalBody = entities[i2].get(BodyComponent);
        if (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.sleeping) {
          continue;
        }
        const totalAcc = motion2.acc.clone();
        if ((optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.collisionType) === CollisionType.Active && (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.useGravity)) {
          totalAcc.addEqual(Physics.gravity);
        }
        optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.captureOldTransform();
        EulerIntegrator.integrate(transform, motion2, totalAcc, elapsedMs);
      }
    }
  }
  class ArcadeSolver {
    constructor() {
      this.directionMap = /* @__PURE__ */ new Map();
      this.distanceMap = /* @__PURE__ */ new Map();
    }
    solve(contacts) {
      this.preSolve(contacts);
      contacts = contacts.filter((c2) => !c2.isCanceled());
      contacts.sort((a2, b2) => {
        const aDist = this.distanceMap.get(a2.id);
        const bDist = this.distanceMap.get(b2.id);
        return aDist - bDist;
      });
      for (const contact of contacts) {
        this.solvePosition(contact);
        this.solveVelocity(contact);
      }
      this.postSolve(contacts);
      return contacts;
    }
    preSolve(contacts) {
      const epsilon = 1e-4;
      for (const contact of contacts) {
        if (Math.abs(contact.mtv.x) < epsilon && Math.abs(contact.mtv.y) < epsilon) {
          contact.cancel();
          continue;
        }
        const side = Side.fromDirection(contact.mtv);
        const mtv = contact.mtv.negate();
        const distance2 = contact.colliderA.worldPos.squareDistance(contact.colliderB.worldPos);
        this.distanceMap.set(contact.id, distance2);
        contact.colliderA.events.emit("precollision", new PreCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));
        contact.colliderB.events.emit("precollision", new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));
      }
    }
    postSolve(contacts) {
      var _a, _b;
      for (const contact of contacts) {
        if (contact.isCanceled()) {
          continue;
        }
        const colliderA = contact.colliderA;
        const colliderB = contact.colliderB;
        const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
          if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
            continue;
          }
        }
        const side = Side.fromDirection(contact.mtv);
        const mtv = contact.mtv.negate();
        contact.colliderA.events.emit("postcollision", new PostCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));
        contact.colliderB.events.emit("postcollision", new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));
      }
    }
    solvePosition(contact) {
      var _a, _b;
      const epsilon = 1e-4;
      if (!contact.colliderA.bounds.overlaps(contact.colliderB.bounds, epsilon)) {
        contact.cancel();
        return;
      }
      if (Math.abs(contact.mtv.x) < epsilon && Math.abs(contact.mtv.y) < epsilon) {
        contact.cancel();
        return;
      }
      let mtv = contact.mtv;
      const colliderA = contact.colliderA;
      const colliderB = contact.colliderB;
      const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
      const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
      if (bodyA && bodyB) {
        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
          return;
        }
        if (bodyA.collisionType === CollisionType.Active && bodyB.collisionType === CollisionType.Active) {
          mtv = mtv.scale(0.5);
        }
        if (bodyA.collisionType === CollisionType.Active) {
          bodyA.globalPos.x -= mtv.x;
          bodyA.globalPos.y -= mtv.y;
          colliderA.update(bodyA.transform.get());
        }
        if (bodyB.collisionType === CollisionType.Active) {
          bodyB.globalPos.x += mtv.x;
          bodyB.globalPos.y += mtv.y;
          colliderB.update(bodyB.transform.get());
        }
      }
    }
    solveVelocity(contact) {
      var _a, _b;
      if (contact.isCanceled()) {
        return;
      }
      const colliderA = contact.colliderA;
      const colliderB = contact.colliderB;
      const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
      const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
      if (bodyA && bodyB) {
        if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
          return;
        }
        const normal = contact.normal;
        const opposite = normal.negate();
        if (bodyA.collisionType === CollisionType.Active) {
          if (bodyA.vel.normalize().dot(opposite) < 0) {
            const velAdj = normal.scale(normal.dot(bodyA.vel.negate()));
            bodyA.vel = bodyA.vel.add(velAdj);
          }
        }
        if (bodyB.collisionType === CollisionType.Active) {
          if (bodyB.vel.normalize().dot(normal) < 0) {
            const velAdj = opposite.scale(opposite.dot(bodyB.vel.negate()));
            bodyB.vel = bodyB.vel.add(velAdj);
          }
        }
      }
    }
  }
  class ContactConstraintPoint {
    constructor(point2, local, contact) {
      this.point = point2;
      this.local = local;
      this.contact = contact;
      this.normalImpulse = 0;
      this.tangentImpulse = 0;
      this.normalMass = 0;
      this.tangentMass = 0;
      this.aToContact = new Vector(0, 0);
      this.bToContact = new Vector(0, 0);
      this.originalVelocityAndRestitution = 0;
      this.update();
    }
    /**
     * Updates the contact information
     */
    update() {
      var _a, _b;
      const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
      const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
      if (bodyA && bodyB) {
        const normal = this.contact.normal;
        const tangent = this.contact.tangent;
        this.aToContact = this.point.sub(bodyA.globalPos);
        this.bToContact = this.point.sub(bodyB.globalPos);
        const aToContactNormal = this.aToContact.cross(normal);
        const bToContactNormal = this.bToContact.cross(normal);
        this.normalMass = bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * aToContactNormal * aToContactNormal + bodyB.inverseInertia * bToContactNormal * bToContactNormal;
        const aToContactTangent = this.aToContact.cross(tangent);
        const bToContactTangent = this.bToContact.cross(tangent);
        this.tangentMass = bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * aToContactTangent * aToContactTangent + bodyB.inverseInertia * bToContactTangent * bToContactTangent;
      }
      return this;
    }
    /**
     * Returns the relative velocity between bodyA and bodyB
     */
    getRelativeVelocity() {
      var _a, _b;
      const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
      const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
      if (bodyA && bodyB) {
        const velA = bodyA.vel.add(Vector.cross(bodyA.angularVelocity, this.aToContact));
        const velB = bodyB.vel.add(Vector.cross(bodyB.angularVelocity, this.bToContact));
        return velB.sub(velA);
      }
      return Vector.Zero;
    }
  }
  class RealisticSolver {
    constructor() {
      this.lastFrameContacts = /* @__PURE__ */ new Map();
      this.idToContactConstraint = /* @__PURE__ */ new Map();
    }
    getContactConstraints(id2) {
      var _a;
      return (_a = this.idToContactConstraint.get(id2)) !== null && _a !== void 0 ? _a : [];
    }
    solve(contacts) {
      this.preSolve(contacts);
      contacts = contacts.filter((c2) => !c2.isCanceled());
      this.solveVelocity(contacts);
      this.solvePosition(contacts);
      this.postSolve(contacts);
      return contacts;
    }
    preSolve(contacts) {
      var _a, _b, _c;
      const epsilon = 1e-4;
      for (const contact of contacts) {
        if (Math.abs(contact.mtv.x) < epsilon && Math.abs(contact.mtv.y) < epsilon) {
          contact.cancel();
          continue;
        }
        const side = Side.fromDirection(contact.mtv);
        contact.colliderA.events.emit("precollision", new PreCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));
        contact.colliderA.events.emit("beforecollisionresolve", new CollisionPreSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
        contact.colliderB.events.emit("precollision", new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));
        contact.colliderB.events.emit("beforecollisionresolve", new CollisionPreSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));
        contact.matchAwake();
      }
      const finishedContactIds = Array.from(this.idToContactConstraint.keys());
      for (const contact of contacts) {
        const index = finishedContactIds.indexOf(contact.id);
        if (index > -1) {
          finishedContactIds.splice(index, 1);
        }
        const contactPoints = (_a = this.idToContactConstraint.get(contact.id)) !== null && _a !== void 0 ? _a : [];
        let pointIndex = 0;
        const bodyA = contact.colliderA.owner.get(BodyComponent);
        const bodyB = contact.colliderB.owner.get(BodyComponent);
        if (bodyA && bodyB) {
          for (const point2 of contact.points) {
            const normal = contact.normal;
            const tangent = contact.tangent;
            const aToContact = point2.sub(bodyA.globalPos);
            const bToContact = point2.sub(bodyB.globalPos);
            const aToContactNormal = aToContact.cross(normal);
            const bToContactNormal = bToContact.cross(normal);
            const normalMass = bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * aToContactNormal * aToContactNormal + bodyB.inverseInertia * bToContactNormal * bToContactNormal;
            const aToContactTangent = aToContact.cross(tangent);
            const bToContactTangent = bToContact.cross(tangent);
            const tangentMass = bodyA.inverseMass + bodyB.inverseMass + bodyA.inverseInertia * aToContactTangent * aToContactTangent + bodyB.inverseInertia * bToContactTangent * bToContactTangent;
            if (contactPoints[pointIndex] && ((_c = (_b = contactPoints[pointIndex]) === null || _b === void 0 ? void 0 : _b.point) === null || _c === void 0 ? void 0 : _c.squareDistance(point2)) < 4) {
              contactPoints[pointIndex].point = point2;
              contactPoints[pointIndex].local = contact.localPoints[pointIndex];
            } else {
              contactPoints[pointIndex] = new ContactConstraintPoint(point2, contact.localPoints[pointIndex], contact);
            }
            contactPoints[pointIndex].aToContact = aToContact;
            contactPoints[pointIndex].bToContact = bToContact;
            contactPoints[pointIndex].normalMass = 1 / normalMass;
            contactPoints[pointIndex].tangentMass = 1 / tangentMass;
            const restitution = bodyA.bounciness > bodyB.bounciness ? bodyA.bounciness : bodyB.bounciness;
            const relativeVelocity = contact.normal.dot(contactPoints[pointIndex].getRelativeVelocity());
            contactPoints[pointIndex].originalVelocityAndRestitution = 0;
            if (relativeVelocity < -0.1) {
              contactPoints[pointIndex].originalVelocityAndRestitution = -restitution * relativeVelocity;
            }
            pointIndex++;
          }
        }
        this.idToContactConstraint.set(contact.id, contactPoints);
      }
      for (const id2 of finishedContactIds) {
        this.idToContactConstraint.delete(id2);
      }
      if (Physics.warmStart) {
        this.warmStart(contacts);
      } else {
        for (const contact of contacts) {
          const contactPoints = this.getContactConstraints(contact.id);
          for (const point2 of contactPoints) {
            point2.normalImpulse = 0;
            point2.tangentImpulse = 0;
          }
        }
      }
    }
    postSolve(contacts) {
      for (const contact of contacts) {
        const bodyA = contact.colliderA.owner.get(BodyComponent);
        const bodyB = contact.colliderB.owner.get(BodyComponent);
        if (bodyA && bodyB) {
          if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
            continue;
          }
          bodyA.updateMotion();
          bodyB.updateMotion();
        }
        const side = Side.fromDirection(contact.mtv);
        contact.colliderA.events.emit("postcollision", new PostCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));
        contact.colliderA.events.emit("aftercollisionresolve", new CollisionPostSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
        contact.colliderB.events.emit("postcollision", new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));
        contact.colliderB.events.emit("aftercollisionresolve", new CollisionPostSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));
      }
      this.lastFrameContacts.clear();
      for (const c2 of contacts) {
        this.lastFrameContacts.set(c2.id, c2);
      }
    }
    /**
     * Warm up body's based on previous frame contact points
     * @param contacts
     */
    warmStart(contacts) {
      var _a, _b, _c;
      for (const contact of contacts) {
        const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
          const contactPoints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
          for (const point2 of contactPoints) {
            if (Physics.warmStart) {
              const normalImpulse = contact.normal.scale(point2.normalImpulse);
              const tangentImpulse = contact.tangent.scale(point2.tangentImpulse);
              const impulse = normalImpulse.add(tangentImpulse);
              bodyA.applyImpulse(point2.point, impulse.negate());
              bodyB.applyImpulse(point2.point, impulse);
            } else {
              point2.normalImpulse = 0;
              point2.tangentImpulse = 0;
            }
          }
        }
      }
    }
    /**
     * Iteratively solve the position overlap constraint
     * @param contacts
     */
    solvePosition(contacts) {
      var _a, _b, _c;
      for (let i2 = 0; i2 < Physics.positionIterations; i2++) {
        for (const contact of contacts) {
          const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
          const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
          if (bodyA && bodyB) {
            if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
              continue;
            }
            const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
            for (const point2 of constraints) {
              const normal = contact.normal;
              const separation = CollisionJumpTable.FindContactSeparation(contact, point2.local);
              const steeringConstant = Physics.steeringFactor;
              const maxCorrection = -5;
              const slop = Physics.slop;
              const steeringForce = clamp2(steeringConstant * (separation + slop), maxCorrection, 0);
              const impulse = normal.scale(-steeringForce * point2.normalMass);
              if (bodyA.collisionType === CollisionType.Active) {
                const impulseForce = impulse.negate().scale(bodyA.inverseMass);
                if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
                  impulseForce.x = 0;
                }
                if (bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
                  impulseForce.y = 0;
                }
                bodyA.globalPos = bodyA.globalPos.add(impulseForce);
                if (!bodyA.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
                  bodyA.rotation -= point2.aToContact.cross(impulse) * bodyA.inverseInertia;
                }
              }
              if (bodyB.collisionType === CollisionType.Active) {
                const impulseForce = impulse.scale(bodyB.inverseMass);
                if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
                  impulseForce.x = 0;
                }
                if (bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
                  impulseForce.y = 0;
                }
                bodyB.globalPos = bodyB.globalPos.add(impulseForce);
                if (!bodyB.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
                  bodyB.rotation += point2.bToContact.cross(impulse) * bodyB.inverseInertia;
                }
              }
            }
          }
        }
      }
    }
    solveVelocity(contacts) {
      var _a, _b, _c;
      for (let i2 = 0; i2 < Physics.velocityIterations; i2++) {
        for (const contact of contacts) {
          const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
          const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
          if (bodyA && bodyB) {
            if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
              continue;
            }
            const friction = Math.min(bodyA.friction, bodyB.friction);
            const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
            for (const point2 of constraints) {
              const relativeVelocity = point2.getRelativeVelocity();
              const tangentVelocity = -relativeVelocity.dot(contact.tangent);
              let impulseDelta = tangentVelocity * point2.tangentMass;
              const maxFriction = friction * point2.normalImpulse;
              const newImpulse = clamp2(point2.tangentImpulse + impulseDelta, -maxFriction, maxFriction);
              impulseDelta = newImpulse - point2.tangentImpulse;
              point2.tangentImpulse = newImpulse;
              const impulse = contact.tangent.scale(impulseDelta);
              bodyA.applyImpulse(point2.point, impulse.negate());
              bodyB.applyImpulse(point2.point, impulse);
            }
            for (const point2 of constraints) {
              const relativeVelocity = point2.getRelativeVelocity();
              const normalVelocity = relativeVelocity.dot(contact.normal);
              let impulseDelta = -point2.normalMass * (normalVelocity - point2.originalVelocityAndRestitution);
              const newImpulse = Math.max(point2.normalImpulse + impulseDelta, 0);
              impulseDelta = newImpulse - point2.normalImpulse;
              point2.normalImpulse = newImpulse;
              const impulse = contact.normal.scale(impulseDelta);
              bodyA.applyImpulse(point2.point, impulse.negate());
              bodyB.applyImpulse(point2.point, impulse);
            }
          }
        }
      }
    }
  }
  class CollisionSystem extends System {
    constructor(physics) {
      super();
      this.types = ["ex.transform", "ex.motion", "ex.collider"];
      this.systemType = SystemType.Update;
      this.priority = -1;
      this._realisticSolver = new RealisticSolver();
      this._arcadeSolver = new ArcadeSolver();
      this._lastFrameContacts = /* @__PURE__ */ new Map();
      this._currentFrameContacts = /* @__PURE__ */ new Map();
      this._processor = physics.collisionProcessor;
      this._trackCollider = (c2) => this._processor.track(c2);
      this._untrackCollider = (c2) => this._processor.untrack(c2);
    }
    notify(message) {
      if (isAddedSystemEntity(message)) {
        const colliderComponent = message.data.get(ColliderComponent);
        colliderComponent.$colliderAdded.subscribe(this._trackCollider);
        colliderComponent.$colliderRemoved.subscribe(this._untrackCollider);
        const collider = colliderComponent.get();
        if (collider) {
          this._processor.track(collider);
        }
      } else {
        const colliderComponent = message.data.get(ColliderComponent);
        const collider = colliderComponent.get();
        if (colliderComponent && collider) {
          this._processor.untrack(collider);
        }
      }
    }
    initialize(scene) {
      this._engine = scene.engine;
    }
    update(entities, elapsedMs) {
      var _a, _b, _c, _d;
      if (!Physics.enabled) {
        return;
      }
      let colliders = [];
      for (const entity of entities) {
        const colliderComp = entity.get(ColliderComponent);
        const collider = colliderComp === null || colliderComp === void 0 ? void 0 : colliderComp.get();
        if (colliderComp && ((_a = colliderComp.owner) === null || _a === void 0 ? void 0 : _a.active) && collider) {
          colliderComp.update();
          if (collider instanceof CompositeCollider) {
            const compositeColliders = collider.getColliders();
            colliders = colliders.concat(compositeColliders);
          } else {
            colliders.push(collider);
          }
        }
      }
      this._processor.update(colliders);
      const pairs = this._processor.broadphase(colliders, elapsedMs);
      this._currentFrameContacts.clear();
      let contacts = this._processor.narrowphase(pairs, (_d = (_c = (_b = this._engine) === null || _b === void 0 ? void 0 : _b.debug) === null || _c === void 0 ? void 0 : _c.stats) === null || _d === void 0 ? void 0 : _d.currFrame);
      const solver = this.getSolver();
      contacts = solver.solve(contacts);
      for (const contact of contacts) {
        const index = contact.id.indexOf("|");
        if (index > 0) {
          const compositeId = contact.id.substring(index + 1);
          this._currentFrameContacts.set(compositeId, contact);
        } else {
          this._currentFrameContacts.set(contact.id, contact);
        }
      }
      this.runContactStartEnd();
      this._lastFrameContacts.clear();
      this._lastFrameContacts = new Map(this._currentFrameContacts);
    }
    getSolver() {
      return Physics.collisionResolutionStrategy === CollisionResolutionStrategy.Realistic ? this._realisticSolver : this._arcadeSolver;
    }
    debug(ex) {
      this._processor.debug(ex);
    }
    runContactStartEnd() {
      for (const [id2, c2] of this._currentFrameContacts) {
        if (!this._lastFrameContacts.has(id2)) {
          const colliderA = c2.colliderA;
          const colliderB = c2.colliderB;
          colliderA.events.emit("collisionstart", new CollisionStartEvent(colliderA, colliderB, c2));
          colliderA.events.emit("contactstart", new ContactStartEvent(colliderA, colliderB, c2));
          colliderB.events.emit("collisionstart", new CollisionStartEvent(colliderB, colliderA, c2));
          colliderB.events.emit("contactstart", new ContactStartEvent(colliderB, colliderA, c2));
        }
      }
      for (const [id2, c2] of this._lastFrameContacts) {
        if (!this._currentFrameContacts.has(id2)) {
          const colliderA = c2.colliderA;
          const colliderB = c2.colliderB;
          colliderA.events.emit("collisionend", new CollisionEndEvent(colliderA, colliderB));
          colliderA.events.emit("contactend", new ContactEndEvent(colliderA, colliderB));
          colliderB.events.emit("collisionend", new CollisionEndEvent(colliderB, colliderA));
          colliderB.events.emit("contactend", new ContactEndEvent(colliderB, colliderA));
        }
      }
    }
  }
  var AnimationDirection;
  (function(AnimationDirection2) {
    AnimationDirection2["Forward"] = "forward";
    AnimationDirection2["Backward"] = "backward";
  })(AnimationDirection || (AnimationDirection = {}));
  var AnimationStrategy;
  (function(AnimationStrategy2) {
    AnimationStrategy2["End"] = "end";
    AnimationStrategy2["Loop"] = "loop";
    AnimationStrategy2["PingPong"] = "pingpong";
    AnimationStrategy2["Freeze"] = "freeze";
  })(AnimationStrategy || (AnimationStrategy = {}));
  const AnimationEvents = {
    Frame: "frame",
    Loop: "loop",
    Ended: "ended"
  };
  class Animation extends Graphic {
    constructor(options) {
      var _a, _b;
      super(options);
      this.events = new EventEmitter2();
      this.frames = [];
      this.strategy = AnimationStrategy.Loop;
      this.frameDuration = 100;
      this.timeScale = 1;
      this._idempotencyToken = -1;
      this._firstTick = true;
      this._currentFrame = 0;
      this._timeLeftInFrame = 0;
      this._pingPongDirection = 1;
      this._done = false;
      this._playing = true;
      this._reversed = false;
      this.frames = options.frames;
      this.strategy = (_a = options.strategy) !== null && _a !== void 0 ? _a : this.strategy;
      this.frameDuration = options.totalDuration ? options.totalDuration / this.frames.length : (_b = options.frameDuration) !== null && _b !== void 0 ? _b : this.frameDuration;
      if (options.reverse) {
        this.reverse();
      }
      this.goToFrame(0);
    }
    clone() {
      return new Animation({
        frames: this.frames.map((f2) => ({ ...f2 })),
        frameDuration: this.frameDuration,
        reverse: this._reversed,
        strategy: this.strategy,
        ...this.cloneGraphicOptions()
      });
    }
    get width() {
      const maybeFrame = this.currentFrame;
      if (maybeFrame) {
        return Math.abs(maybeFrame.graphic.width * this.scale.x);
      }
      return 0;
    }
    get height() {
      const maybeFrame = this.currentFrame;
      if (maybeFrame) {
        return Math.abs(maybeFrame.graphic.height * this.scale.y);
      }
      return 0;
    }
    /**
     * Create an Animation from a [[SpriteSheet]], a list of indices into the sprite sheet, a duration per frame
     * and optional [[AnimationStrategy]]
     *
     * Example:
     * ```typescript
     * const spriteSheet = SpriteSheet.fromImageSource({...});
     *
     * const anim = Animation.fromSpriteSheet(spriteSheet, range(0, 5), 200, AnimationStrategy.Loop);
     * ```
     *
     * @param spriteSheet
     * @param frameIndices
     * @param durationPerFrameMs
     * @param strategy
     */
    static fromSpriteSheet(spriteSheet, frameIndices, durationPerFrameMs, strategy = AnimationStrategy.Loop) {
      const maxIndex = spriteSheet.sprites.length - 1;
      const invalidIndices = frameIndices.filter((index) => index < 0 || index > maxIndex);
      if (invalidIndices.length) {
        Animation._LOGGER.warn(`Indices into SpriteSheet were provided that don't exist: ${invalidIndices.join(",")} no frame will be shown`);
      }
      return new Animation({
        frames: spriteSheet.sprites.filter((_2, index) => frameIndices.indexOf(index) > -1).map((f2) => ({
          graphic: f2,
          duration: durationPerFrameMs
        })),
        strategy
      });
    }
    /**
     * Create an [[Animation]] from a [[SpriteSheet]] given a list of coordinates
     *
     * Example:
     * ```typescript
     * const spriteSheet = SpriteSheet.fromImageSource({...});
     *
     * const anim = Animation.fromSpriteSheetCoordinates({
     *  spriteSheet,
     *  frameCoordinates: [
     *    {x: 0, y: 5, duration: 100},
     *    {x: 1, y: 5, duration: 200},
     *    {x: 2, y: 5, duration: 100},
     *    {x: 3, y: 5, duration: 500}
     *  ],
     *  strategy: AnimationStrategy.PingPong
     * });
     * ```
     *
     * @param options
     * @returns Animation
     */
    static fromSpriteSheetCoordinates(options) {
      const { spriteSheet, frameCoordinates, durationPerFrameMs, strategy, reverse } = options;
      const defaultDuration = durationPerFrameMs !== null && durationPerFrameMs !== void 0 ? durationPerFrameMs : 100;
      const frames = [];
      for (const coord of frameCoordinates) {
        const { x: x2, y: y2, duration } = coord;
        const sprite = spriteSheet.getSprite(x2, y2);
        if (sprite) {
          frames.push({
            graphic: sprite,
            duration: duration !== null && duration !== void 0 ? duration : defaultDuration
          });
        } else {
          Animation._LOGGER.warn(`Skipping frame! SpriteSheet does not have coordinate (${x2}, ${y2}), please check your SpriteSheet to confirm that sprite exists`);
        }
      }
      return new Animation({
        frames,
        strategy,
        reverse
      });
    }
    /**
     * Returns the current Frame of the animation
     *
     * Use [[Animation.currentFrameIndex]] to get the frame number and
     * [[Animation.goToFrame]] to set the current frame index
     */
    get currentFrame() {
      if (this._currentFrame >= 0 && this._currentFrame < this.frames.length) {
        return this.frames[this._currentFrame];
      }
      return null;
    }
    /**
     * Returns the current frame index of the animation
     *
     * Use [[Animation.currentFrame]] to grab the current [[Frame]] object
     */
    get currentFrameIndex() {
      return this._currentFrame;
    }
    /**
     * Returns `true` if the animation is playing
     */
    get isPlaying() {
      return this._playing;
    }
    /**
     * Reverses the play direction of the Animation, this preserves the current frame
     */
    reverse() {
      this.frames = this.frames.slice().reverse();
      this._reversed = !this._reversed;
    }
    /**
     * Returns the current play direction of the animation
     */
    get direction() {
      const reversed = this._reversed && this._pingPongDirection === 1 ? true : false;
      return reversed ? AnimationDirection.Backward : AnimationDirection.Forward;
    }
    /**
     * Plays or resumes the animation from the current frame
     */
    play() {
      this._playing = true;
    }
    /**
     * Pauses the animation on the current frame
     */
    pause() {
      this._playing = false;
      this._firstTick = true;
    }
    /**
     * Reset the animation back to the beginning, including if the animation were done
     */
    reset() {
      this._done = false;
      this._firstTick = true;
      this._currentFrame = 0;
    }
    /**
     * Returns `true` if the animation can end
     */
    get canFinish() {
      switch (this.strategy) {
        case AnimationStrategy.End:
        case AnimationStrategy.Freeze: {
          return true;
        }
        default: {
          return false;
        }
      }
    }
    /**
     * Returns `true` if the animation is done, for looping type animations
     * `ex.AnimationStrategy.PingPong` and `ex.AnimationStrategy.Loop` this will always return `false`
     *
     * See the `ex.Animation.canFinish()` method to know if an animation type can end
     */
    get done() {
      return this._done;
    }
    /**
     * Jump the animation immediately to a specific frame if it exists
     * @param frameNumber
     */
    goToFrame(frameNumber) {
      this._currentFrame = frameNumber;
      this._timeLeftInFrame = this.frameDuration;
      const maybeFrame = this.frames[this._currentFrame];
      if (maybeFrame && !this._done) {
        this._timeLeftInFrame = (maybeFrame === null || maybeFrame === void 0 ? void 0 : maybeFrame.duration) || this.frameDuration;
        this.events.emit("frame", { ...maybeFrame, frameIndex: this.currentFrameIndex });
      }
    }
    _nextFrame() {
      const currentFrame = this._currentFrame;
      if (this._done) {
        return currentFrame;
      }
      let next = -1;
      switch (this.strategy) {
        case AnimationStrategy.Loop: {
          next = (currentFrame + 1) % this.frames.length;
          if (next === 0) {
            this.events.emit("loop", this);
          }
          break;
        }
        case AnimationStrategy.End: {
          next = currentFrame + 1;
          if (next >= this.frames.length) {
            this._done = true;
            this._currentFrame = this.frames.length;
            this.events.emit("end", this);
          }
          break;
        }
        case AnimationStrategy.Freeze: {
          next = clamp2(currentFrame + 1, 0, this.frames.length - 1);
          if (next >= this.frames.length - 1) {
            this._done = true;
            this.events.emit("end", this);
          }
          break;
        }
        case AnimationStrategy.PingPong: {
          if (currentFrame + this._pingPongDirection >= this.frames.length) {
            this._pingPongDirection = -1;
            this.events.emit("loop", this);
          }
          if (currentFrame + this._pingPongDirection < 0) {
            this._pingPongDirection = 1;
            this.events.emit("loop", this);
          }
          next = currentFrame + this._pingPongDirection % this.frames.length;
          break;
        }
      }
      return next;
    }
    /**
     * Called internally by Excalibur to update the state of the animation potential update the current frame
     * @param elapsedMilliseconds Milliseconds elapsed
     * @param idempotencyToken Prevents double ticking in a frame by passing a unique token to the frame
     */
    tick(elapsedMilliseconds, idempotencyToken = 0) {
      if (this._idempotencyToken === idempotencyToken) {
        return;
      }
      this._idempotencyToken = idempotencyToken;
      if (!this._playing) {
        return;
      }
      if (this._firstTick) {
        this._firstTick = false;
        this.events.emit("frame", { ...this.currentFrame, frameIndex: this.currentFrameIndex });
      }
      this._timeLeftInFrame -= elapsedMilliseconds * this.timeScale;
      if (this._timeLeftInFrame <= 0) {
        this.goToFrame(this._nextFrame());
      }
    }
    _drawImage(ctx, x2, y2) {
      if (this.currentFrame) {
        this.currentFrame.graphic.draw(ctx, x2, y2);
      }
    }
  }
  Animation._LOGGER = Logger2.getInstance();
  class GraphicsGroup extends Graphic {
    constructor(options) {
      super(options);
      this.members = [];
      this.members = options.members;
      this._updateDimensions();
    }
    clone() {
      return new GraphicsGroup({
        members: [...this.members],
        ...this.cloneGraphicOptions()
      });
    }
    _updateDimensions() {
      let bb2 = new BoundingBox();
      for (const { graphic, pos } of this.members) {
        bb2 = graphic.localBounds.translate(pos).combine(bb2);
      }
      this.width = bb2.width;
      this.height = bb2.height;
      return bb2;
    }
    get localBounds() {
      let bb2 = new BoundingBox();
      for (const { graphic, pos } of this.members) {
        bb2 = graphic.localBounds.translate(pos).combine(bb2);
      }
      return bb2;
    }
    _isAnimationOrGroup(graphic) {
      return graphic instanceof Animation || graphic instanceof GraphicsGroup;
    }
    tick(elapsedMilliseconds, idempotencyToken) {
      for (const member of this.members) {
        const maybeAnimation = member.graphic;
        if (this._isAnimationOrGroup(maybeAnimation)) {
          maybeAnimation.tick(elapsedMilliseconds, idempotencyToken);
        }
      }
    }
    reset() {
      for (const member of this.members) {
        const maybeAnimation = member.graphic;
        if (this._isAnimationOrGroup(maybeAnimation)) {
          maybeAnimation.reset();
        }
      }
    }
    _preDraw(ex, x2, y2) {
      this._updateDimensions();
      super._preDraw(ex, x2, y2);
    }
    _drawImage(ex, x2, y2) {
      for (const member of this.members) {
        ex.save();
        ex.translate(x2, y2);
        member.graphic.draw(ex, member.pos.x, member.pos.y);
        if (this.showDebug) {
          ex.debug.drawRect(0, 0, this.width, this.height);
        }
        ex.restore();
      }
    }
  }
  function Configurable(base) {
    return class extends base {
      assign(props) {
        for (const k2 in props) {
          if (typeof this[k2] !== "function") {
            this[k2] = props[k2];
          }
        }
      }
      constructor(...args) {
        super(...args);
        const size = args.filter(function(value) {
          return value !== void 0;
        }).length;
        if (size === 1 && args[0] && typeof args[0] === "object" && !(args[0] instanceof Array)) {
          this.assign(args[0]);
        }
      }
    };
  }
  var EmitterType;
  (function(EmitterType2) {
    EmitterType2[EmitterType2["Circle"] = 0] = "Circle";
    EmitterType2[EmitterType2["Rectangle"] = 1] = "Rectangle";
  })(EmitterType || (EmitterType = {}));
  class ParticleImpl extends Entity {
    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
      super();
      this.position = new Vector(0, 0);
      this.velocity = new Vector(0, 0);
      this.acceleration = new Vector(0, 0);
      this.particleRotationalVelocity = 0;
      this.currentRotation = 0;
      this.focus = null;
      this.focusAccel = 0;
      this.opacity = 1;
      this.beginColor = Color.White;
      this.endColor = Color.White;
      this.life = 300;
      this.fadeFlag = false;
      this._rRate = 1;
      this._gRate = 1;
      this._bRate = 1;
      this._aRate = 0;
      this._currentColor = Color.White;
      this.emitter = null;
      this.particleSize = 5;
      this.particleSprite = null;
      this.sizeRate = 0;
      this.elapsedMultiplier = 0;
      this.visible = true;
      this.isOffscreen = false;
      let emitter = emitterOrConfig;
      if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {
        const config = emitterOrConfig;
        emitter = config.emitter;
        life = config.life;
        opacity = config.opacity;
        endColor = config.endColor;
        beginColor = config.beginColor;
        position = config.position;
        velocity = config.velocity;
        acceleration = config.acceleration;
        startSize = config.startSize;
        endSize = config.endSize;
      }
      this.emitter = emitter;
      this.life = life || this.life;
      this.opacity = opacity || this.opacity;
      this.endColor = endColor || this.endColor.clone();
      this.beginColor = beginColor || this.beginColor.clone();
      this._currentColor = this.beginColor.clone();
      if (this.emitter.particleTransform === ParticleTransform.Global) {
        const globalPos = this.emitter.transform.globalPos;
        this.position = (position || this.position).add(globalPos);
        this.velocity = (velocity || this.velocity).rotate(this.emitter.transform.globalRotation);
      } else {
        this.velocity = velocity || this.velocity;
        this.position = position || this.position;
      }
      this.acceleration = acceleration || this.acceleration;
      this._rRate = (this.endColor.r - this.beginColor.r) / this.life;
      this._gRate = (this.endColor.g - this.beginColor.g) / this.life;
      this._bRate = (this.endColor.b - this.beginColor.b) / this.life;
      this._aRate = this.opacity / this.life;
      this.startSize = startSize || 0;
      this.endSize = endSize || 0;
      if (this.endSize > 0 && this.startSize > 0) {
        this.sizeRate = (this.endSize - this.startSize) / this.life;
        this.particleSize = this.startSize;
      }
      this.addComponent(this.transform = new TransformComponent());
      this.addComponent(this.graphics = new GraphicsComponent());
      this.transform.pos = this.position;
      this.transform.rotation = this.currentRotation;
      this.transform.scale = vec(1, 1);
      if (this.particleSprite) {
        this.graphics.opacity = this.opacity;
        this.graphics.use(this.particleSprite);
      } else {
        this.graphics.localBounds = BoundingBox.fromDimension(this.particleSize, this.particleSize, Vector.Half);
        this.graphics.onPostDraw = (ctx) => {
          ctx.save();
          this.graphics.opacity = this.opacity;
          const tmpColor = this._currentColor.clone();
          tmpColor.a = 1;
          ctx.debug.drawPoint(vec(0, 0), { color: tmpColor, size: this.particleSize });
          ctx.restore();
        };
      }
    }
    kill() {
      this.emitter.removeParticle(this);
    }
    update(_engine, delta) {
      this.life = this.life - delta;
      this.elapsedMultiplier = this.elapsedMultiplier + delta;
      if (this.life < 0) {
        this.kill();
      }
      if (this.fadeFlag) {
        this.opacity = clamp2(this._aRate * this.life, 1e-4, 1);
      }
      if (this.startSize > 0 && this.endSize > 0) {
        this.particleSize = clamp2(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
      }
      this._currentColor.r = clamp2(this._currentColor.r + this._rRate * delta, 0, 255);
      this._currentColor.g = clamp2(this._currentColor.g + this._gRate * delta, 0, 255);
      this._currentColor.b = clamp2(this._currentColor.b + this._bRate * delta, 0, 255);
      this._currentColor.a = clamp2(this.opacity, 1e-4, 1);
      if (this.focus) {
        const accel = this.focus.sub(this.position).normalize().scale(this.focusAccel).scale(delta / 1e3);
        this.velocity = this.velocity.add(accel);
      } else {
        this.velocity = this.velocity.add(this.acceleration.scale(delta / 1e3));
      }
      this.position = this.position.add(this.velocity.scale(delta / 1e3));
      if (this.particleRotationalVelocity) {
        this.currentRotation = (this.currentRotation + this.particleRotationalVelocity * delta / 1e3) % (2 * Math.PI);
      }
      this.transform.pos = this.position;
      this.transform.rotation = this.currentRotation;
      this.transform.scale = vec(1, 1);
      this.graphics.opacity = this.opacity;
    }
  }
  class Particle extends Configurable(ParticleImpl) {
    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
      super(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize);
    }
  }
  var ParticleTransform;
  (function(ParticleTransform2) {
    ParticleTransform2["Global"] = "global";
    ParticleTransform2["Local"] = "local";
  })(ParticleTransform || (ParticleTransform = {}));
  class ParticleEmitter extends Actor {
    /**
     * Gets the opacity of each particle from 0 to 1.0
     */
    get opacity() {
      return super.graphics.opacity;
    }
    /**
     * Gets the opacity of each particle from 0 to 1.0
     */
    set opacity(opacity) {
      super.graphics.opacity = opacity;
    }
    /**
     * Gets or sets the sprite that a particle should use
     */
    get particleSprite() {
      return this._sprite;
    }
    set particleSprite(val) {
      if (val) {
        this._sprite = val;
      }
    }
    /**
     * @param config particle emitter options bag
     */
    constructor(config) {
      var _a, _b;
      super({ width: (_a = config.width) !== null && _a !== void 0 ? _a : 0, height: (_b = config.height) !== null && _b !== void 0 ? _b : 0 });
      this._particlesToEmit = 0;
      this.numParticles = 0;
      this.isEmitting = true;
      this.particles = [];
      this.deadParticles = [];
      this.minVel = 0;
      this.maxVel = 0;
      this.acceleration = new Vector(0, 0);
      this.minAngle = 0;
      this.maxAngle = 0;
      this.emitRate = 1;
      this.particleLife = 2e3;
      this.fadeFlag = false;
      this.focus = null;
      this.focusAccel = null;
      this.startSize = null;
      this.endSize = null;
      this.minSize = 5;
      this.maxSize = 5;
      this.beginColor = Color.White;
      this.endColor = Color.White;
      this._sprite = null;
      this.emitterType = EmitterType.Rectangle;
      this.radius = 0;
      this.particleRotationalVelocity = 0;
      this.randomRotation = false;
      this.particleTransform = ParticleTransform.Global;
      const { x: x2, y: y2, pos, isEmitting, minVel, maxVel, acceleration, minAngle, maxAngle, emitRate, particleLife, opacity, fadeFlag, focus, focusAccel, startSize, endSize, minSize, maxSize, beginColor, endColor, particleSprite, emitterType, radius, particleRotationalVelocity, particleTransform, randomRotation, random } = { ...config };
      this.pos = pos !== null && pos !== void 0 ? pos : vec(x2 !== null && x2 !== void 0 ? x2 : 0, y2 !== null && y2 !== void 0 ? y2 : 0);
      this.isEmitting = isEmitting !== null && isEmitting !== void 0 ? isEmitting : this.isEmitting;
      this.minVel = minVel !== null && minVel !== void 0 ? minVel : this.minVel;
      this.maxVel = maxVel !== null && maxVel !== void 0 ? maxVel : this.maxVel;
      this.acceleration = acceleration !== null && acceleration !== void 0 ? acceleration : this.acceleration;
      this.minAngle = minAngle !== null && minAngle !== void 0 ? minAngle : this.minAngle;
      this.maxAngle = maxAngle !== null && maxAngle !== void 0 ? maxAngle : this.maxAngle;
      this.emitRate = emitRate !== null && emitRate !== void 0 ? emitRate : this.emitRate;
      this.particleLife = particleLife !== null && particleLife !== void 0 ? particleLife : this.particleLife;
      this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;
      this.fadeFlag = fadeFlag !== null && fadeFlag !== void 0 ? fadeFlag : this.fadeFlag;
      this.focus = focus !== null && focus !== void 0 ? focus : this.focus;
      this.focusAccel = focusAccel !== null && focusAccel !== void 0 ? focusAccel : this.focusAccel;
      this.startSize = startSize !== null && startSize !== void 0 ? startSize : this.startSize;
      this.endSize = endSize !== null && endSize !== void 0 ? endSize : this.endSize;
      this.minSize = minSize !== null && minSize !== void 0 ? minSize : this.minSize;
      this.maxSize = maxSize !== null && maxSize !== void 0 ? maxSize : this.maxSize;
      this.beginColor = beginColor !== null && beginColor !== void 0 ? beginColor : this.beginColor;
      this.endColor = endColor !== null && endColor !== void 0 ? endColor : this.endColor;
      this.particleSprite = particleSprite !== null && particleSprite !== void 0 ? particleSprite : this.particleSprite;
      this.emitterType = emitterType !== null && emitterType !== void 0 ? emitterType : this.emitterType;
      this.radius = radius !== null && radius !== void 0 ? radius : this.radius;
      this.particleRotationalVelocity = particleRotationalVelocity !== null && particleRotationalVelocity !== void 0 ? particleRotationalVelocity : this.particleRotationalVelocity;
      this.randomRotation = randomRotation !== null && randomRotation !== void 0 ? randomRotation : this.randomRotation;
      this.particleTransform = particleTransform !== null && particleTransform !== void 0 ? particleTransform : this.particleTransform;
      this.body.collisionType = CollisionType.PreventCollision;
      this.random = random !== null && random !== void 0 ? random : new Random();
    }
    removeParticle(particle) {
      this.deadParticles.push(particle);
    }
    /**
     * Causes the emitter to emit particles
     * @param particleCount  Number of particles to emit right now
     */
    emitParticles(particleCount) {
      var _a;
      for (let i2 = 0; i2 < particleCount; i2++) {
        const p2 = this._createParticle();
        this.particles.push(p2);
        if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {
          if (this.particleTransform === ParticleTransform.Global) {
            this.scene.world.add(p2);
          } else {
            this.addChild(p2);
          }
        }
      }
    }
    clearParticles() {
      this.particles.length = 0;
    }
    // Creates a new particle given the constraints of the emitter
    _createParticle() {
      let ranX = 0;
      let ranY = 0;
      const angle = randomInRange(this.minAngle, this.maxAngle, this.random);
      const vel = randomInRange(this.minVel, this.maxVel, this.random);
      const size = this.startSize || randomInRange(this.minSize, this.maxSize, this.random);
      const dx = vel * Math.cos(angle);
      const dy = vel * Math.sin(angle);
      if (this.emitterType === EmitterType.Rectangle) {
        ranX = randomInRange(0, this.width, this.random);
        ranY = randomInRange(0, this.height, this.random);
      } else if (this.emitterType === EmitterType.Circle) {
        const radius = randomInRange(0, this.radius, this.random);
        ranX = radius * Math.cos(angle);
        ranY = radius * Math.sin(angle);
      }
      const p2 = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new Vector(ranX, ranY), new Vector(dx, dy), this.acceleration, this.startSize, this.endSize);
      p2.fadeFlag = this.fadeFlag;
      p2.particleSize = size;
      if (this.particleSprite) {
        p2.particleSprite = this.particleSprite;
        p2.graphics.opacity = this.opacity;
        p2.graphics.use(this._sprite);
      }
      p2.particleRotationalVelocity = this.particleRotationalVelocity;
      if (this.randomRotation) {
        p2.currentRotation = randomInRange(0, Math.PI * 2, this.random);
      }
      if (this.focus) {
        p2.focus = this.focus.add(new Vector(this.pos.x, this.pos.y));
        p2.focusAccel = this.focusAccel;
      }
      return p2;
    }
    update(engine, delta) {
      var _a;
      super.update(engine, delta);
      if (this.isEmitting) {
        this._particlesToEmit += this.emitRate * (delta / 1e3);
        if (this._particlesToEmit > 1) {
          this.emitParticles(Math.floor(this._particlesToEmit));
          this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
        }
      }
      for (let i2 = 0; i2 < this.deadParticles.length; i2++) {
        removeItemFromArray(this.deadParticles[i2], this.particles);
        if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {
          this.scene.world.remove(this.deadParticles[i2], false);
        }
      }
      this.deadParticles.length = 0;
    }
  }
  class GraphicsSystem extends System {
    constructor() {
      super(...arguments);
      this.types = ["ex.transform", "ex.graphics"];
      this.systemType = SystemType.Draw;
      this.priority = 0;
      this._token = 0;
      this._sortedTransforms = [];
      this._zHasChanged = false;
      this._zIndexUpdate = () => {
        this._zHasChanged = true;
      };
    }
    get sortedTransforms() {
      return this._sortedTransforms;
    }
    initialize(scene) {
      this._camera = scene.camera;
      this._engine = scene.engine;
    }
    preupdate() {
      this._graphicsContext = this._engine.graphicsContext;
      if (this._zHasChanged) {
        this._sortedTransforms.sort((a2, b2) => {
          return a2.z - b2.z;
        });
        this._zHasChanged = false;
      }
    }
    notify(entityAddedOrRemoved) {
      if (isAddedSystemEntity(entityAddedOrRemoved)) {
        const tx = entityAddedOrRemoved.data.get(TransformComponent);
        this._sortedTransforms.push(tx);
        tx.zIndexChanged$.subscribe(this._zIndexUpdate);
        this._zHasChanged = true;
      } else {
        const tx = entityAddedOrRemoved.data.get(TransformComponent);
        tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);
        const index = this._sortedTransforms.indexOf(tx);
        if (index > -1) {
          this._sortedTransforms.splice(index, 1);
        }
      }
    }
    update(_entities, delta) {
      this._token++;
      let graphics;
      FontCache.checkAndClearCache();
      this._graphicsContext.save();
      if (this._camera) {
        this._camera.draw(this._graphicsContext);
      }
      for (const transform of this._sortedTransforms) {
        const entity = transform.owner;
        if (entity.hasTag("ex.offscreen")) {
          continue;
        }
        graphics = entity.get(GraphicsComponent);
        if (!graphics.visible) {
          continue;
        }
        if (transform.coordPlane === CoordPlane.Screen) {
          this._graphicsContext.restore();
        }
        this._graphicsContext.save();
        if (transform.coordPlane === CoordPlane.Screen) {
          this._graphicsContext.translate(this._engine.screen.contentArea.left, this._engine.screen.contentArea.top);
        }
        graphics.update(delta, this._token);
        const parallax = entity.get(ParallaxComponent);
        if (parallax) {
          const oneMinusFactor = Vector.One.sub(parallax.parallaxFactor);
          const parallaxOffset = this._camera.pos.scale(oneMinusFactor);
          this._graphicsContext.translate(parallaxOffset.x, parallaxOffset.y);
        }
        this._applyTransform(entity);
        if (graphics.material) {
          this._graphicsContext.material = graphics.material;
        }
        if (graphics.onPreDraw) {
          graphics.onPreDraw(this._graphicsContext, delta);
        }
        const particleOpacity = entity instanceof Particle ? entity.opacity : 1;
        this._graphicsContext.opacity *= graphics.opacity * particleOpacity;
        this._drawGraphicsComponent(graphics);
        if (graphics.onPostDraw) {
          graphics.onPostDraw(this._graphicsContext, delta);
        }
        this._graphicsContext.restore();
        if (transform.coordPlane === CoordPlane.Screen) {
          this._graphicsContext.save();
          if (this._camera) {
            this._camera.draw(this._graphicsContext);
          }
        }
      }
      this._graphicsContext.restore();
    }
    _drawGraphicsComponent(graphicsComponent) {
      var _a, _b;
      if (graphicsComponent.visible) {
        const flipHorizontal = graphicsComponent.flipHorizontal;
        const flipVertical = graphicsComponent.flipVertical;
        for (const layer of graphicsComponent.layers.get()) {
          for (const { graphic, options } of layer.graphics) {
            let anchor = graphicsComponent.anchor;
            let offset = graphicsComponent.offset;
            if (options === null || options === void 0 ? void 0 : options.anchor) {
              anchor = options.anchor;
            }
            if (options === null || options === void 0 ? void 0 : options.offset) {
              offset = options.offset;
            }
            const offsetX = -graphic.width * anchor.x + offset.x;
            const offsetY = -graphic.height * anchor.y + offset.y;
            const oldFlipHorizontal = graphic.flipHorizontal;
            const oldFlipVertical = graphic.flipVertical;
            if (flipHorizontal || flipVertical) {
              graphic.flipHorizontal = flipHorizontal ? !oldFlipHorizontal : oldFlipHorizontal;
              graphic.flipVertical = flipVertical ? !oldFlipVertical : oldFlipVertical;
            }
            graphic === null || graphic === void 0 ? void 0 : graphic.draw(this._graphicsContext, offsetX + layer.offset.x, offsetY + layer.offset.y);
            if (flipHorizontal || flipVertical) {
              graphic.flipHorizontal = oldFlipHorizontal;
              graphic.flipVertical = oldFlipVertical;
            }
            if (((_a = this._engine) === null || _a === void 0 ? void 0 : _a.isDebug) && this._engine.debug.graphics.showBounds) {
              const offset2 = vec(offsetX + layer.offset.x, offsetY + layer.offset.y);
              if (graphic instanceof GraphicsGroup) {
                for (const g2 of graphic.members) {
                  (_b = g2.graphic) === null || _b === void 0 ? void 0 : _b.localBounds.translate(offset2.add(g2.pos)).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
                }
              } else {
                graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(offset2).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
              }
            }
          }
        }
      }
    }
    /**
     * This applies the current entity transform to the graphics context
     * @param entity
     */
    _applyTransform(entity) {
      const ancestors = entity.getAncestors();
      for (const ancestor of ancestors) {
        const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);
        const optionalBody = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(BodyComponent);
        let interpolatedPos = transform.pos;
        let interpolatedScale = transform.scale;
        let interpolatedRotation = transform.rotation;
        if (optionalBody) {
          if (this._engine.fixedUpdateFps && optionalBody.__oldTransformCaptured && optionalBody.enableFixedUpdateInterpolate) {
            const blend = this._engine.currentFrameLagMs / (1e3 / this._engine.fixedUpdateFps);
            interpolatedPos = transform.pos.scale(blend).add(optionalBody.oldPos.scale(1 - blend));
            interpolatedScale = transform.scale.scale(blend).add(optionalBody.oldScale.scale(1 - blend));
            const cosine = (1 - blend) * Math.cos(optionalBody.oldRotation) + blend * Math.cos(transform.rotation);
            const sine = (1 - blend) * Math.sin(optionalBody.oldRotation) + blend * Math.sin(transform.rotation);
            interpolatedRotation = Math.atan2(sine, cosine);
          }
        }
        if (transform) {
          this._graphicsContext.z = transform.z;
          this._graphicsContext.translate(interpolatedPos.x, interpolatedPos.y);
          this._graphicsContext.scale(interpolatedScale.x, interpolatedScale.y);
          this._graphicsContext.rotate(interpolatedRotation);
        }
      }
    }
  }
  class DebugSystem extends System {
    constructor() {
      super(...arguments);
      this.types = ["ex.transform"];
      this.systemType = SystemType.Draw;
      this.priority = 999;
    }
    initialize(scene) {
      this._graphicsContext = scene.engine.graphicsContext;
      this._camera = scene.camera;
      this._engine = scene.engine;
      this._collisionSystem = scene.world.systemManager.get(CollisionSystem);
    }
    update(entities, _delta) {
      var _a;
      if (!this._engine.isDebug) {
        return;
      }
      const filterSettings = this._engine.debug.filter;
      let id2;
      let name;
      const entitySettings = this._engine.debug.entity;
      let tx;
      const txSettings = this._engine.debug.transform;
      let motion2;
      const motionSettings = this._engine.debug.motion;
      let colliderComp;
      const colliderSettings = this._engine.debug.collider;
      const physicsSettings = this._engine.debug.physics;
      let graphics;
      const graphicsSettings = this._engine.debug.graphics;
      let debugDraw;
      let body;
      const bodySettings = this._engine.debug.body;
      const cameraSettings = this._engine.debug.camera;
      for (const entity of entities) {
        if (entity.hasTag("offscreen")) {
          continue;
        }
        if (entity instanceof Particle) {
          continue;
        }
        if (filterSettings.useFilter) {
          const allIds = filterSettings.ids.length === 0;
          const idMatch = allIds || filterSettings.ids.includes(entity.id);
          if (!idMatch) {
            continue;
          }
          const allNames = filterSettings.nameQuery === "";
          const nameMatch = allNames || entity.name.includes(filterSettings.nameQuery);
          if (!nameMatch) {
            continue;
          }
        }
        let cursor = Vector.Zero;
        const lineHeight = vec(0, 16);
        id2 = entity.id;
        name = entity.name;
        tx = entity.get(TransformComponent);
        this._pushCameraTransform(tx);
        this._graphicsContext.save();
        this._applyTransform(entity);
        if (tx) {
          if (txSettings.showAll || txSettings.showPosition) {
            this._graphicsContext.debug.drawPoint(Vector.Zero, { size: 4, color: txSettings.positionColor });
          }
          if (txSettings.showAll || txSettings.showPositionLabel) {
            this._graphicsContext.debug.drawText(`pos${tx.pos.toString(2)}`, cursor);
            cursor = cursor.add(lineHeight);
          }
          if (txSettings.showAll || txSettings.showZIndex) {
            this._graphicsContext.debug.drawText(`z(${tx.z.toFixed(1)})`, cursor);
            cursor = cursor.add(lineHeight);
          }
          if (entitySettings.showAll || entitySettings.showId) {
            this._graphicsContext.debug.drawText(`id(${id2}) ${entity.parent ? "child of id(" + ((_a = entity.parent) === null || _a === void 0 ? void 0 : _a.id) + ")" : ""}`, cursor);
            cursor = cursor.add(lineHeight);
          }
          if (entitySettings.showAll || entitySettings.showName) {
            this._graphicsContext.debug.drawText(`name(${name})`, cursor);
            cursor = cursor.add(lineHeight);
          }
          if (txSettings.showAll || txSettings.showRotation) {
            this._graphicsContext.drawLine(Vector.Zero, Vector.fromAngle(tx.rotation).scale(50).add(Vector.Zero), txSettings.rotationColor, 2);
            this._graphicsContext.debug.drawText(`rot deg(${toDegrees(tx.rotation).toFixed(2)})`, cursor);
            cursor = cursor.add(lineHeight);
          }
          if (txSettings.showAll || txSettings.showScale) {
            this._graphicsContext.drawLine(Vector.Zero, tx.scale.add(Vector.Zero), txSettings.scaleColor, 2);
          }
        }
        graphics = entity.get(GraphicsComponent);
        if (graphics) {
          if (graphicsSettings.showAll || graphicsSettings.showBounds) {
            const bounds = graphics.localBounds;
            bounds.draw(this._graphicsContext, graphicsSettings.boundsColor);
          }
        }
        debugDraw = entity.get(DebugGraphicsComponent);
        if (debugDraw) {
          if (!debugDraw.useTransform) {
            this._graphicsContext.restore();
          }
          debugDraw.draw(this._graphicsContext);
          if (!debugDraw.useTransform) {
            this._graphicsContext.save();
            this._applyTransform(entity);
          }
        }
        body = entity.get(BodyComponent);
        if (body) {
          if (bodySettings.showAll || bodySettings.showCollisionGroup) {
            this._graphicsContext.debug.drawText(`collision group(${body.group.name})`, cursor);
            cursor = cursor.add(lineHeight);
          }
          if (bodySettings.showAll || bodySettings.showCollisionType) {
            this._graphicsContext.debug.drawText(`collision type(${body.collisionType})`, cursor);
            cursor = cursor.add(lineHeight);
          }
          if (bodySettings.showAll || bodySettings.showMass) {
            this._graphicsContext.debug.drawText(`mass(${body.mass})`, cursor);
            cursor = cursor.add(lineHeight);
          }
          if (bodySettings.showAll || bodySettings.showMotion) {
            this._graphicsContext.debug.drawText(`motion(${body.sleepMotion})`, cursor);
            cursor = cursor.add(lineHeight);
          }
          if (bodySettings.showAll || bodySettings.showSleeping) {
            this._graphicsContext.debug.drawText(`sleeping(${body.canSleep ? body.sleeping : "cant sleep"})`, cursor);
            cursor = cursor.add(lineHeight);
          }
        }
        this._graphicsContext.restore();
        motion2 = entity.get(MotionComponent);
        if (motion2) {
          if (motionSettings.showAll || motionSettings.showVelocity) {
            this._graphicsContext.debug.drawText(`vel${motion2.vel.toString(2)}`, cursor.add(tx.globalPos));
            this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion2.vel), motionSettings.velocityColor, 2);
            cursor = cursor.add(lineHeight);
          }
          if (motionSettings.showAll || motionSettings.showAcceleration) {
            this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion2.acc), motionSettings.accelerationColor, 2);
          }
        }
        colliderComp = entity.get(ColliderComponent);
        if (colliderComp) {
          const collider = colliderComp.get();
          if ((colliderSettings.showAll || colliderSettings.showGeometry) && collider) {
            collider.debug(this._graphicsContext, colliderSettings.geometryColor);
          }
          if (colliderSettings.showAll || colliderSettings.showBounds) {
            if (collider instanceof CompositeCollider) {
              const colliders = collider.getColliders();
              for (const collider2 of colliders) {
                const bounds = collider2.bounds;
                const pos = vec(bounds.left, bounds.top);
                this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
                if (colliderSettings.showAll || colliderSettings.showOwner) {
                  this._graphicsContext.debug.drawText(`owner id(${collider2.owner.id})`, pos);
                }
              }
              colliderComp.bounds.draw(this._graphicsContext, colliderSettings.boundsColor);
            } else if (collider) {
              const bounds = colliderComp.bounds;
              const pos = vec(bounds.left, bounds.top);
              this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
              if (colliderSettings.showAll || colliderSettings.showOwner) {
                this._graphicsContext.debug.drawText(`owner id(${colliderComp.owner.id})`, pos);
              }
            }
          }
        }
        this._popCameraTransform(tx);
      }
      this._graphicsContext.save();
      this._camera.draw(this._graphicsContext);
      if (physicsSettings.showAll || physicsSettings.showBroadphaseSpacePartitionDebug) {
        this._collisionSystem.debug(this._graphicsContext);
      }
      if (physicsSettings.showAll || physicsSettings.showCollisionContacts || physicsSettings.showCollisionNormals) {
        for (const [_2, contact] of this._engine.debug.stats.currFrame.physics.contacts) {
          if (physicsSettings.showAll || physicsSettings.showCollisionContacts) {
            for (const point2 of contact.points) {
              this._graphicsContext.debug.drawPoint(point2, { size: 5, color: physicsSettings.collisionContactColor });
            }
          }
          if (physicsSettings.showAll || physicsSettings.showCollisionNormals) {
            for (const point2 of contact.points) {
              this._graphicsContext.debug.drawLine(point2, contact.normal.scale(30).add(point2), {
                color: physicsSettings.collisionNormalColor
              });
            }
          }
        }
      }
      this._graphicsContext.restore();
      if (cameraSettings) {
        this._graphicsContext.save();
        this._camera.draw(this._graphicsContext);
        if (cameraSettings.showAll || cameraSettings.showFocus) {
          this._graphicsContext.drawCircle(this._camera.pos, 4, cameraSettings.focusColor);
        }
        if (cameraSettings.showAll || cameraSettings.showZoom) {
          this._graphicsContext.debug.drawText(`zoom(${this._camera.zoom})`, this._camera.pos);
        }
        this._graphicsContext.restore();
      }
      this._graphicsContext.flush();
    }
    /**
     * This applies the current entity transform to the graphics context
     * @param entity
     */
    _applyTransform(entity) {
      const ancestors = entity.getAncestors();
      for (const ancestor of ancestors) {
        const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);
        if (transform) {
          this._graphicsContext.translate(transform.pos.x, transform.pos.y);
          this._graphicsContext.scale(transform.scale.x, transform.scale.y);
          this._graphicsContext.rotate(transform.rotation);
        }
      }
    }
    /**
     * Applies the current camera transform if in world coordinates
     * @param transform
     */
    _pushCameraTransform(transform) {
      if (transform.coordPlane === CoordPlane.World) {
        this._graphicsContext.save();
        if (this._camera) {
          this._camera.draw(this._graphicsContext);
        }
      }
    }
    /**
     * Resets the current camera transform if in world coordinates
     * @param transform
     */
    _popCameraTransform(transform) {
      if (transform.coordPlane === CoordPlane.World) {
        this._graphicsContext.restore();
      }
    }
  }
  class PointerSystem extends System {
    constructor() {
      super(...arguments);
      this.types = ["ex.transform", "ex.pointer"];
      this.systemType = SystemType.Update;
      this.priority = -1;
      this.overrideUseColliderShape = false;
      this.overrideUseGraphicsBounds = false;
      this.lastFrameEntityToPointers = /* @__PURE__ */ new Map();
      this.currentFrameEntityToPointers = /* @__PURE__ */ new Map();
      this._sortedTransforms = [];
      this._sortedEntities = [];
      this._zHasChanged = false;
      this._zIndexUpdate = () => {
        this._zHasChanged = true;
      };
    }
    initialize(scene) {
      this._engine = scene.engine;
    }
    preupdate() {
      this._receiver = this._engine.input.pointers;
      if (this._zHasChanged) {
        this._sortedTransforms.sort((a2, b2) => {
          return b2.z - a2.z;
        });
        this._sortedEntities = this._sortedTransforms.map((t2) => t2.owner);
        this._zHasChanged = false;
      }
    }
    notify(entityAddedOrRemoved) {
      if (isAddedSystemEntity(entityAddedOrRemoved)) {
        const tx = entityAddedOrRemoved.data.get(TransformComponent);
        this._sortedTransforms.push(tx);
        this._sortedEntities.push(tx.owner);
        tx.zIndexChanged$.subscribe(this._zIndexUpdate);
        this._zHasChanged = true;
      } else {
        const tx = entityAddedOrRemoved.data.get(TransformComponent);
        tx.zIndexChanged$.unsubscribe(this._zIndexUpdate);
        const index = this._sortedTransforms.indexOf(tx);
        if (index > -1) {
          this._sortedTransforms.splice(index, 1);
          this._sortedEntities.splice(index, 1);
        }
      }
    }
    entityCurrentlyUnderPointer(entity, pointerId) {
      return this.currentFrameEntityToPointers.has(entity.id) && this.currentFrameEntityToPointers.get(entity.id).includes(pointerId);
    }
    entityWasUnderPointer(entity, pointerId) {
      return this.lastFrameEntityToPointers.has(entity.id) && this.lastFrameEntityToPointers.get(entity.id).includes(pointerId);
    }
    entered(entity, pointerId) {
      return this.entityCurrentlyUnderPointer(entity, pointerId) && !this.lastFrameEntityToPointers.has(entity.id);
    }
    left(entity, pointerId) {
      return !this.currentFrameEntityToPointers.has(entity.id) && this.entityWasUnderPointer(entity, pointerId);
    }
    addPointerToEntity(entity, pointerId) {
      if (!this.currentFrameEntityToPointers.has(entity.id)) {
        this.currentFrameEntityToPointers.set(entity.id, [pointerId]);
        return;
      }
      const pointers = this.currentFrameEntityToPointers.get(entity.id);
      this.currentFrameEntityToPointers.set(entity.id, pointers.concat(pointerId));
    }
    update(_entities) {
      this._processPointerToEntity(this._sortedEntities);
      this._dispatchEvents(this._sortedEntities);
      this._receiver.update();
      this.lastFrameEntityToPointers.clear();
      this.lastFrameEntityToPointers = new Map(this.currentFrameEntityToPointers);
      this.currentFrameEntityToPointers.clear();
      this._receiver.clear();
    }
    _processPointerToEntity(entities) {
      var _a;
      let transform;
      let collider;
      let graphics;
      let pointer;
      for (const entity of entities) {
        transform = entity.get(TransformComponent);
        pointer = (_a = entity.get(PointerComponent)) !== null && _a !== void 0 ? _a : new PointerComponent();
        collider = entity.get(ColliderComponent);
        if (collider && (pointer.useColliderShape || this.overrideUseColliderShape)) {
          collider.update();
          const geom = collider.get();
          if (geom) {
            for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries()) {
              if (geom.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) {
                this.addPointerToEntity(entity, pointerId);
              }
            }
          }
        }
        graphics = entity.get(GraphicsComponent);
        if (graphics && (pointer.useGraphicsBounds || this.overrideUseGraphicsBounds)) {
          const graphicBounds = graphics.localBounds.transform(transform.get().matrix);
          for (const [pointerId, pos] of this._receiver.currentFramePointerCoords.entries()) {
            if (graphicBounds.contains(transform.coordPlane === CoordPlane.World ? pos.worldPos : pos.screenPos)) {
              this.addPointerToEntity(entity, pointerId);
            }
          }
        }
      }
    }
    _processDownAndEmit(entity) {
      const lastDownPerPointer = /* @__PURE__ */ new Map();
      for (const event of this._receiver.currentFrameDown) {
        if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {
          entity.events.emit("pointerdown", event);
          if (this._receiver.isDragStart(event.pointerId)) {
            entity.events.emit("pointerdragstart", event);
          }
        }
        lastDownPerPointer.set(event.pointerId, event);
      }
      return lastDownPerPointer;
    }
    _processUpAndEmit(entity) {
      const lastUpPerPointer = /* @__PURE__ */ new Map();
      for (const event of this._receiver.currentFrameUp) {
        if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {
          entity.events.emit("pointerup", event);
          if (this._receiver.isDragEnd(event.pointerId)) {
            entity.events.emit("pointerdragend", event);
          }
        }
        lastUpPerPointer.set(event.pointerId, event);
      }
      return lastUpPerPointer;
    }
    _processMoveAndEmit(entity) {
      const lastMovePerPointer = /* @__PURE__ */ new Map();
      for (const event of this._receiver.currentFrameMove) {
        if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {
          entity.events.emit("pointermove", event);
          if (this._receiver.isDragging(event.pointerId)) {
            entity.events.emit("pointerdragmove", event);
          }
        }
        lastMovePerPointer.set(event.pointerId, event);
      }
      return lastMovePerPointer;
    }
    _processEnterLeaveAndEmit(entity, lastUpDownMoveEvents) {
      for (const event of lastUpDownMoveEvents) {
        if (event.active && entity.active && this.entered(entity, event.pointerId)) {
          entity.events.emit("pointerenter", event);
          if (this._receiver.isDragging(event.pointerId)) {
            entity.events.emit("pointerdragenter", event);
          }
          break;
        }
        if (event.active && entity.active && // leave can happen on move
        (this.left(entity, event.pointerId) || // or leave can happen on pointer up
        this.entityCurrentlyUnderPointer(entity, event.pointerId) && event.type === "up")) {
          entity.events.emit("pointerleave", event);
          if (this._receiver.isDragging(event.pointerId)) {
            entity.events.emit("pointerdragleave", event);
          }
          break;
        }
      }
    }
    _processCancelAndEmit(entity) {
      for (const event of this._receiver.currentFrameCancel) {
        if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, event.pointerId)) {
          entity.events.emit("pointercancel", event);
        }
      }
    }
    _processWheelAndEmit(entity) {
      for (const event of this._receiver.currentFrameWheel) {
        if (event.active && entity.active && this.entityCurrentlyUnderPointer(entity, 0)) {
          entity.events.emit("pointerwheel", event);
        }
      }
    }
    _dispatchEvents(entities) {
      const lastFrameEntities = new Set(this.lastFrameEntityToPointers.keys());
      const currentFrameEntities = new Set(this.currentFrameEntityToPointers.keys());
      const entitiesWithEvents = entities.filter((e2) => lastFrameEntities.has(e2.id) || currentFrameEntities.has(e2.id));
      let lastMovePerPointer;
      let lastUpPerPointer;
      let lastDownPerPointer;
      for (const entity of entitiesWithEvents) {
        lastDownPerPointer = this._processDownAndEmit(entity);
        lastUpPerPointer = this._processUpAndEmit(entity);
        lastMovePerPointer = this._processMoveAndEmit(entity);
        const lastUpDownMoveEvents = [
          ...lastMovePerPointer.values(),
          ...lastDownPerPointer.values(),
          ...lastUpPerPointer.values()
        ];
        this._processEnterLeaveAndEmit(entity, lastUpDownMoveEvents);
        this._processCancelAndEmit(entity);
        this._processWheelAndEmit(entity);
      }
    }
  }
  class ActionsSystem extends System {
    constructor() {
      super(...arguments);
      this.types = ["ex.actions"];
      this.systemType = SystemType.Update;
      this.priority = -1;
      this._actions = [];
    }
    notify(entityAddedOrRemoved) {
      if (isAddedSystemEntity(entityAddedOrRemoved)) {
        const action = entityAddedOrRemoved.data.get(ActionsComponent);
        this._actions.push(action);
      } else {
        const action = entityAddedOrRemoved.data.get(ActionsComponent);
        const index = this._actions.indexOf(action);
        if (index > -1) {
          this._actions.splice(index, 1);
        }
      }
    }
    update(_entities, delta) {
      for (const actions of this._actions) {
        actions.update(delta);
      }
    }
  }
  class IsometricEntityComponent extends Component {
    /**
     * Specify the isometric map to use to position this entity's z-index
     * @param map
     */
    constructor(map) {
      super();
      this.type = "ex.isometricentity";
      this.elevation = 0;
      this.map = map;
    }
  }
  class IsometricEntitySystem extends System {
    constructor() {
      super(...arguments);
      this.types = ["ex.transform", "ex.isometricentity"];
      this.systemType = SystemType.Update;
      this.priority = 99;
    }
    update(entities, _delta) {
      let transform;
      let iso;
      for (const entity of entities) {
        transform = entity.get(TransformComponent);
        iso = entity.get(IsometricEntityComponent);
        const maxZindexPerElevation = Math.max(iso.map.columns * iso.map.tileWidth, iso.map.rows * iso.map.tileHeight);
        const newZ = maxZindexPerElevation * iso.elevation + transform.pos.y;
        transform.z = newZ;
      }
    }
  }
  class OffscreenSystem extends System {
    constructor() {
      super(...arguments);
      this.types = ["ex.transform", "ex.graphics"];
      this.systemType = SystemType.Draw;
      this.priority = -1;
    }
    initialize(scene) {
      this._camera = scene.camera;
      this._screen = scene.engine.screen;
    }
    update(entities) {
      this._worldBounds = this._screen.getWorldBounds();
      let transform;
      let graphics;
      let maybeParallax;
      for (const entity of entities) {
        graphics = entity.get(GraphicsComponent);
        transform = entity.get(TransformComponent);
        maybeParallax = entity.get(ParallaxComponent);
        let parallaxOffset;
        if (maybeParallax) {
          const oneMinusFactor = Vector.One.sub(maybeParallax.parallaxFactor);
          parallaxOffset = this._camera.pos.scale(oneMinusFactor);
        }
        const entityOffscreen = this._isOffscreen(transform, graphics, parallaxOffset);
        if (entityOffscreen && !entity.hasTag("ex.offscreen")) {
          entity.events.emit("exitviewport", new ExitViewPortEvent(entity));
          entity.addTag("ex.offscreen");
        }
        if (!entityOffscreen && entity.hasTag("ex.offscreen")) {
          entity.events.emit("enterviewport", new EnterViewPortEvent(entity));
          entity.removeTag("ex.offscreen");
        }
      }
    }
    _isOffscreen(transform, graphics, parallaxOffset) {
      if (transform.coordPlane === CoordPlane.World) {
        let bounds = graphics.localBounds;
        if (parallaxOffset) {
          bounds = bounds.translate(parallaxOffset);
        }
        const transformedBounds = bounds.transform(transform.get().matrix);
        const graphicsOffscreen = !this._worldBounds.overlaps(transformedBounds);
        return graphicsOffscreen;
      } else {
        return false;
      }
    }
  }
  class PhysicsWorld {
    constructor() {
      this.collisionProcessor = new DynamicTreeCollisionProcessor();
    }
    rayCast(ray, options) {
      return this.collisionProcessor.rayCast(ray, options);
    }
  }
  const SceneEvents = {
    Initialize: "initialize",
    Activate: "activate",
    Deactivate: "deactivate",
    PreUpdate: "preupdate",
    PostUpdate: "postupdate",
    PreDraw: "predraw",
    PostDraw: "postdraw",
    PreDebugDraw: "predebugdraw",
    PostDebugDraw: "postdebugdraw"
  };
  class Scene {
    /**
     * The actors in the current scene
     */
    get actors() {
      return this.world.entityManager.entities.filter((e2) => {
        return e2 instanceof Actor;
      });
    }
    /**
     * The entities in the current scene
     */
    get entities() {
      return this.world.entityManager.entities;
    }
    /**
     * The triggers in the current scene
     */
    get triggers() {
      return this.world.entityManager.entities.filter((e2) => {
        return e2 instanceof Trigger;
      });
    }
    /**
     * The [[TileMap]]s in the scene, if any
     */
    get tileMaps() {
      return this.world.entityManager.entities.filter((e2) => {
        return e2 instanceof TileMap;
      });
    }
    get timers() {
      return this._timers;
    }
    constructor() {
      this._logger = Logger2.getInstance();
      this.events = new EventEmitter2();
      this.camera = new Camera();
      this.world = new World(this);
      this.physics = new PhysicsWorld();
      this._isInitialized = false;
      this._timers = [];
      this._cancelQueue = [];
      this.world.add(new ActionsSystem());
      this.world.add(new MotionSystem());
      this.world.add(new CollisionSystem(this.physics));
      this.world.add(new PointerSystem());
      this.world.add(new IsometricEntitySystem());
      this.world.add(new OffscreenSystem());
      this.world.add(new GraphicsSystem());
      this.world.add(new DebugSystem());
    }
    emit(eventName, event) {
      this.events.emit(eventName, event);
    }
    on(eventName, handler) {
      return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
      return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
      this.events.off(eventName, handler);
    }
    /**
     * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     */
    onInitialize(_engine) {
    }
    /**
     * This is called when the scene is made active and started. It is meant to be overridden,
     * this is where you should setup any DOM UI or event handlers needed for the scene.
     */
    onActivate(_context) {
    }
    /**
     * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,
     * this is where you should cleanup any DOM UI or event handlers needed for the scene.
     */
    onDeactivate(_context) {
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     */
    onPreUpdate(_engine, _delta) {
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onPostUpdate(_engine, _delta) {
    }
    /**
     * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreDraw` is called directly before a scene is drawn.
     *
     */
    onPreDraw(_ctx, _delta) {
    }
    /**
     * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostDraw` is called directly after a scene is drawn.
     *
     */
    onPostDraw(_ctx, _delta) {
    }
    /**
     * Initializes actors in the scene
     */
    _initializeChildren() {
      for (const child of this.entities) {
        child._initialize(this.engine);
      }
    }
    /**
     * Gets whether or not the [[Scene]] has been initialized
     */
    get isInitialized() {
      return this._isInitialized;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Initializes the scene before the first update, meant to be called by engine not by users of
     * Excalibur
     * @internal
     */
    _initialize(engine) {
      if (!this.isInitialized) {
        this.engine = engine;
        this.camera._initialize(engine);
        this.world.systemManager.initialize();
        this.onInitialize.call(this, engine);
        this._initializeChildren();
        this._logger.debug("Scene.onInitialize", this, engine);
        this.events.emit("initialize", new InitializeEvent(engine, this));
        this._isInitialized = true;
      }
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.
     * @internal
     */
    _activate(context) {
      this._logger.debug("Scene.onActivate", this);
      this.onActivate(context);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.
     * @internal
     */
    _deactivate(context) {
      this._logger.debug("Scene.onDeactivate", this);
      this.onDeactivate(context);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(_engine, delta) {
      this.emit("preupdate", new PreUpdateEvent(_engine, delta, this));
      this.onPreUpdate(_engine, delta);
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(_engine, delta) {
      this.emit("postupdate", new PostUpdateEvent(_engine, delta, this));
      this.onPostUpdate(_engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _predraw handler for [[onPreDraw]] lifecycle event
     *
     * @internal
     */
    _predraw(_ctx, _delta) {
      this.emit("predraw", new PreDrawEvent(_ctx, _delta, this));
      this.onPreDraw(_ctx, _delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _postdraw handler for [[onPostDraw]] lifecycle event
     *
     * @internal
     */
    _postdraw(_ctx, _delta) {
      this.emit("postdraw", new PostDrawEvent(_ctx, _delta, this));
      this.onPostDraw(_ctx, _delta);
    }
    /**
     * Updates all the actors and timers in the scene. Called by the [[Engine]].
     * @param engine  Reference to the current Engine
     * @param delta   The number of milliseconds since the last update
     */
    update(engine, delta) {
      this._preupdate(engine, delta);
      let i2, len;
      for (i2 = 0, len = this._cancelQueue.length; i2 < len; i2++) {
        this.removeTimer(this._cancelQueue[i2]);
      }
      this._cancelQueue.length = 0;
      for (const timer of this._timers) {
        timer.update(delta);
      }
      this.world.update(SystemType.Update, delta);
      if (this.camera) {
        this.camera.update(engine, delta);
      }
      this._collectActorStats(engine);
      this._postupdate(engine, delta);
    }
    /**
     * Draws all the actors in the Scene. Called by the [[Engine]].
     *
     * @param ctx    The current rendering context
     * @param delta  The number of milliseconds since the last draw
     */
    draw(ctx, delta) {
      var _a;
      this._predraw(ctx, delta);
      this.world.update(SystemType.Draw, delta);
      if ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.isDebug) {
        this.debugDraw(ctx);
      }
      this._postdraw(ctx, delta);
    }
    /**
     * Draws all the actors' debug information in the Scene. Called by the [[Engine]].
     * @param ctx  The current rendering context
     */
    /* istanbul ignore next */
    debugDraw(ctx) {
      this.emit("predebugdraw", new PreDebugDrawEvent(ctx, this));
      this.emit("postdebugdraw", new PostDebugDrawEvent(ctx, this));
    }
    /**
     * Checks whether an actor is contained in this scene or not
     */
    contains(actor) {
      return this.actors.indexOf(actor) > -1;
    }
    add(entity) {
      this.emit("entityadded", { target: entity });
      this.world.add(entity);
      entity.scene = this;
      if (entity instanceof Timer) {
        if (!contains(this._timers, entity)) {
          this.addTimer(entity);
        }
        return;
      }
    }
    /**
     * Removes an [[Entity]] (Actor, TileMap, Trigger, etc) or [[Timer]] from it's current scene
     * and adds it to this scene.
     *
     * Useful if you want to have an object be present in only 1 scene at a time.
     * @param entity
     */
    transfer(entity) {
      let scene;
      if (entity instanceof Entity && entity.scene && entity.scene !== this) {
        scene = entity.scene;
        entity.scene.world.remove(entity, false);
      }
      if (entity instanceof Timer && entity.scene) {
        scene = entity.scene;
        entity.scene.removeTimer(entity);
      }
      scene === null || scene === void 0 ? void 0 : scene.emit("entityremoved", { target: entity });
      this.add(entity);
    }
    remove(entity) {
      if (entity instanceof Entity) {
        this.emit("entityremoved", { target: entity });
        if (entity.active) {
          entity.kill();
        }
        this.world.remove(entity);
      }
      if (entity instanceof Timer) {
        this.removeTimer(entity);
      }
    }
    /**
     * Removes all entities and timers from the scene, optionally indicate whether deferred should or shouldn't be used.
     *
     * By default entities use deferred removal
     * @param deferred
     */
    clear(deferred = true) {
      for (const entity of this.entities) {
        this.world.remove(entity, deferred);
      }
      for (const timer of this.timers) {
        this.removeTimer(timer);
      }
    }
    /**
     * Adds a [[Timer]] to the scene
     * @param timer  The timer to add
     */
    addTimer(timer) {
      this._timers.push(timer);
      timer.scene = this;
      return timer;
    }
    /**
     * Removes a [[Timer]] from the scene.
     * @warning Can be dangerous, use [[cancelTimer]] instead
     * @param timer  The timer to remove
     */
    removeTimer(timer) {
      const i2 = this._timers.indexOf(timer);
      if (i2 !== -1) {
        this._timers.splice(i2, 1);
      }
      return timer;
    }
    /**
     * Cancels a [[Timer]], removing it from the scene nicely
     * @param timer  The timer to cancel
     */
    cancelTimer(timer) {
      this._cancelQueue.push(timer);
      return timer;
    }
    /**
     * Tests whether a [[Timer]] is active in the scene
     */
    isTimerActive(timer) {
      return this._timers.indexOf(timer) > -1 && !timer.complete;
    }
    isCurrentScene() {
      if (this.engine) {
        return this.engine.currentScene === this;
      }
      return false;
    }
    _collectActorStats(engine) {
      const screenElements = this.actors.filter((a2) => a2 instanceof ScreenElement);
      for (const _ui of screenElements) {
        engine.stats.currFrame.actors.ui++;
      }
      for (const actor of this.actors) {
        engine.stats.currFrame.actors.alive++;
        for (const child of actor.children) {
          if (isScreenElement(child)) {
            engine.stats.currFrame.actors.ui++;
          } else {
            engine.stats.currFrame.actors.alive++;
          }
        }
      }
    }
  }
  var ColorBlindnessMode;
  (function(ColorBlindnessMode2) {
    ColorBlindnessMode2["Protanope"] = "Protanope";
    ColorBlindnessMode2["Deuteranope"] = "Deuteranope";
    ColorBlindnessMode2["Tritanope"] = "Tritanope";
  })(ColorBlindnessMode || (ColorBlindnessMode = {}));
  const color_blind_fragment = "#version 300 es\r\nprecision mediump float;\r\n// our texture\r\nuniform sampler2D u_image;\r\n// the texCoords passed in from the vertex shader.\r\nin vec2 v_texcoord;\r\n\r\n// color blind type\r\nuniform int u_type;\r\n\r\n// simulation?\r\nuniform bool u_simulate;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  vec4 o =  texture(u_image, v_texcoord);\r\n  // RGB to LMS matrix conversion\r\n  float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);\r\n  float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);\r\n  float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);\r\n  // Simulate color blindness\r\n  float l;\r\n  float m;\r\n  float s;\r\n  //MODE CODE//\r\n  if (u_type == 0) {\r\n    // Protanope\r\n    l = 0.0 * L + 2.02344 * M + -2.52581 * S;\r\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\r\n    s = 0.0 * L + 0.0 * M + 1.0 * S;;\r\n  } else if (u_type == 1) {\r\n    // Deuteranope\r\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\r\n    m = 0.494207 * L + 0.0 * M + 1.24827 * S;\r\n    s = 0.0 * L + 0.0 * M + 1.0 * S;\r\n  } else if (u_type == 2) {\r\n    // Tritanope\r\n    l = 1.0 * L + 0.0 * M + 0.0 * S;\r\n    m = 0.0 * L + 1.0 * M + 0.0 * S;\r\n    s = -0.395913 * L + 0.801109 * M + 0.0 * S;\r\n  }\r\n\r\n  // LMS to RGB matrix conversion\r\n  vec4 error; // simulate the colors\r\n  error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);\r\n  error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);\r\n  error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);\r\n  error.a = 1.0;\r\n  vec4 diff = o - error;\r\n  vec4 correction; // correct the colors\r\n  correction.r = 0.0;\r\n  correction.g =  (diff.r * 0.7) + (diff.g * 1.0);\r\n  correction.b =  (diff.r * 0.7) + (diff.b * 1.0);\r\n  correction = o + correction;\r\n  correction.a = o.a;\r\n  //SIMULATE//\r\n\r\n  // sim \r\n  if (u_simulate) {\r\n    fragColor = error.rgba;\r\n  } else {\r\n    fragColor = correction.rgba;\r\n  }\r\n}";
  class ScreenShader {
    constructor(gl2, fragmentSource) {
      this._shader = new Shader({
        gl: gl2,
        vertexSource: `#version 300 es
      in vec2 a_position;
      in vec2 a_texcoord;
      out vec2 v_texcoord;

      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        // Pass the texcoord to the fragment shader.
        v_texcoord = a_texcoord;
      }`,
        fragmentSource
      });
      this._shader.compile();
      this._buffer = new VertexBuffer({
        gl: gl2,
        type: "static",
        // clip space quad + uv since we don't need a camera
        data: new Float32Array([
          -1,
          -1,
          0,
          0,
          -1,
          1,
          0,
          1,
          1,
          -1,
          1,
          0,
          1,
          -1,
          1,
          0,
          -1,
          1,
          0,
          1,
          1,
          1,
          1,
          1
        ])
      });
      this._layout = new VertexLayout({
        gl: gl2,
        shader: this._shader,
        vertexBuffer: this._buffer,
        attributes: [
          ["a_position", 2],
          ["a_texcoord", 2]
        ]
      });
      this._buffer.upload();
    }
    getShader() {
      return this._shader;
    }
    getLayout() {
      return this._layout;
    }
  }
  class ColorBlindnessPostProcessor {
    constructor(_colorBlindnessMode, simulate = false) {
      this._colorBlindnessMode = _colorBlindnessMode;
      this._simulate = false;
      this._simulate = simulate;
    }
    initialize(gl2) {
      this._shader = new ScreenShader(gl2, color_blind_fragment);
      this.simulate = this._simulate;
      this.colorBlindnessMode = this._colorBlindnessMode;
    }
    getShader() {
      return this._shader.getShader();
    }
    getLayout() {
      return this._shader.getLayout();
    }
    set colorBlindnessMode(colorBlindMode) {
      this._colorBlindnessMode = colorBlindMode;
      if (this._shader) {
        const shader = this._shader.getShader();
        shader.use();
        if (this._colorBlindnessMode === ColorBlindnessMode.Protanope) {
          shader.setUniformInt("u_type", 0);
        } else if (this._colorBlindnessMode === ColorBlindnessMode.Deuteranope) {
          shader.setUniformInt("u_type", 1);
        } else if (this._colorBlindnessMode === ColorBlindnessMode.Tritanope) {
          shader.setUniformInt("u_type", 2);
        }
      }
    }
    get colorBlindnessMode() {
      return this._colorBlindnessMode;
    }
    set simulate(value) {
      this._simulate = value;
      if (this._shader) {
        const shader = this._shader.getShader();
        shader.use();
        shader.setUniformBoolean("u_simulate", value);
      }
    }
    get simulate() {
      return this._simulate;
    }
  }
  class ColorBlindFlags {
    constructor(engine) {
      this._engine = engine;
      this._colorBlindPostProcessor = new ColorBlindnessPostProcessor(ColorBlindnessMode.Protanope);
    }
    /**
     * Correct colors for a specified color blindness
     * @param colorBlindness
     */
    correct(colorBlindness) {
      if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {
        this.clear();
        this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;
        this._colorBlindPostProcessor.simulate = false;
        this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);
      }
    }
    /**
     * Simulate colors for a specified color blindness
     * @param colorBlindness
     */
    simulate(colorBlindness) {
      if (this._engine.graphicsContext instanceof ExcaliburGraphicsContextWebGL) {
        this.clear();
        this._colorBlindPostProcessor.colorBlindnessMode = colorBlindness;
        this._colorBlindPostProcessor.simulate = true;
        this._engine.graphicsContext.addPostProcessor(this._colorBlindPostProcessor);
      }
    }
    /**
     * Remove color blindness post processor
     */
    clear() {
      this._engine.graphicsContext.removePostProcessor(this._colorBlindPostProcessor);
    }
  }
  class Debug {
    constructor(engine) {
      this.stats = {
        /**
         * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
         * Best accessed on [[postframe]] event. See [[FrameStats]]
         */
        currFrame: new FrameStats(),
        /**
         * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
         * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[FrameStats]]
         */
        prevFrame: new FrameStats()
      };
      this.filter = {
        /**
         * Toggle filter on or off (default off) must be on for DebugDraw to use filters
         */
        useFilter: false,
        /**
         * Query for entities by name, if the entity name contains `nameQuery` it will be included
         */
        nameQuery: "",
        /**
         * Query for Entity ids, if the id matches it will be included
         */
        ids: []
      };
      this.entity = {
        showAll: false,
        showId: true,
        showName: false
      };
      this.transform = {
        showAll: false,
        showPosition: false,
        showPositionLabel: false,
        positionColor: Color.Yellow,
        showZIndex: false,
        showScale: false,
        scaleColor: Color.Green,
        showRotation: false,
        rotationColor: Color.Blue
      };
      this.graphics = {
        showAll: false,
        showBounds: true,
        boundsColor: Color.Yellow
      };
      this.collider = {
        showAll: false,
        showBounds: true,
        boundsColor: Color.Blue,
        showOwner: false,
        showGeometry: true,
        geometryColor: Color.Green
      };
      this.physics = {
        showAll: false,
        showBroadphaseSpacePartitionDebug: false,
        showCollisionNormals: false,
        collisionNormalColor: Color.Cyan,
        showCollisionContacts: true,
        collisionContactColor: Color.Red
      };
      this.motion = {
        showAll: false,
        showVelocity: false,
        velocityColor: Color.Yellow,
        showAcceleration: false,
        accelerationColor: Color.Red
      };
      this.body = {
        showAll: false,
        showCollisionGroup: false,
        showCollisionType: false,
        showSleeping: false,
        showMotion: false,
        showMass: false
      };
      this.camera = {
        showAll: false,
        showFocus: false,
        focusColor: Color.Red,
        showZoom: false
      };
      this._engine = engine;
      this.colorBlindMode = new ColorBlindFlags(this._engine);
    }
    /**
     * Switch the current excalibur clock with the [[TestClock]] and return
     * it in the same running state.
     *
     * This is useful when you need to debug frame by frame.
     */
    useTestClock() {
      const clock = this._engine.clock;
      const wasRunning = clock.isRunning();
      clock.stop();
      const testClock = clock.toTestClock();
      if (wasRunning) {
        testClock.start();
      }
      this._engine.clock = testClock;
      return testClock;
    }
    /**
     * Switch the current excalibur clock with the [[StandardClock]] and
     * return it in the same running state.
     *
     * This is useful when you need to switch back to normal mode after
     * debugging.
     */
    useStandardClock() {
      const currentClock = this._engine.clock;
      const wasRunning = currentClock.isRunning();
      currentClock.stop();
      const standardClock = currentClock.toStandardClock();
      if (wasRunning) {
        standardClock.start();
      }
      this._engine.clock = standardClock;
      return standardClock;
    }
  }
  class FrameStats {
    constructor() {
      this._id = 0;
      this._delta = 0;
      this._fps = 0;
      this._actorStats = {
        alive: 0,
        killed: 0,
        ui: 0,
        get remaining() {
          return this.alive - this.killed;
        },
        get total() {
          return this.remaining + this.ui;
        }
      };
      this._durationStats = {
        update: 0,
        draw: 0,
        get total() {
          return this.update + this.draw;
        }
      };
      this._physicsStats = new PhysicsStats();
      this._graphicsStats = {
        drawCalls: 0,
        drawnImages: 0
      };
    }
    /**
     * Zero out values or clone other IFrameStat stats. Allows instance reuse.
     *
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
      if (otherStats) {
        this.id = otherStats.id;
        this.delta = otherStats.delta;
        this.fps = otherStats.fps;
        this.actors.alive = otherStats.actors.alive;
        this.actors.killed = otherStats.actors.killed;
        this.actors.ui = otherStats.actors.ui;
        this.duration.update = otherStats.duration.update;
        this.duration.draw = otherStats.duration.draw;
        this._physicsStats.reset(otherStats.physics);
        this.graphics.drawCalls = otherStats.graphics.drawCalls;
        this.graphics.drawnImages = otherStats.graphics.drawnImages;
      } else {
        this.id = this.delta = this.fps = 0;
        this.actors.alive = this.actors.killed = this.actors.ui = 0;
        this.duration.update = this.duration.draw = 0;
        this._physicsStats.reset();
        this.graphics.drawnImages = this.graphics.drawCalls = 0;
      }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
      const fs = new FrameStats();
      fs.reset(this);
      return fs;
    }
    /**
     * Gets the frame's id
     */
    get id() {
      return this._id;
    }
    /**
     * Sets the frame's id
     */
    set id(value) {
      this._id = value;
    }
    /**
     * Gets the frame's delta (time since last frame)
     */
    get delta() {
      return this._delta;
    }
    /**
     * Sets the frame's delta (time since last frame). Internal use only.
     * @internal
     */
    set delta(value) {
      this._delta = value;
    }
    /**
     * Gets the frame's frames-per-second (FPS)
     */
    get fps() {
      return this._fps;
    }
    /**
     * Sets the frame's frames-per-second (FPS). Internal use only.
     * @internal
     */
    set fps(value) {
      this._fps = value;
    }
    /**
     * Gets the frame's actor statistics
     */
    get actors() {
      return this._actorStats;
    }
    /**
     * Gets the frame's duration statistics
     */
    get duration() {
      return this._durationStats;
    }
    /**
     * Gets the frame's physics statistics
     */
    get physics() {
      return this._physicsStats;
    }
    /**
     * Gets the frame's graphics statistics
     */
    get graphics() {
      return this._graphicsStats;
    }
  }
  class PhysicsStats {
    constructor() {
      this._pairs = 0;
      this._collisions = 0;
      this._contacts = /* @__PURE__ */ new Map();
      this._fastBodies = 0;
      this._fastBodyCollisions = 0;
      this._broadphase = 0;
      this._narrowphase = 0;
    }
    /**
     * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.
     *
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
      if (otherStats) {
        this.pairs = otherStats.pairs;
        this.collisions = otherStats.collisions;
        this.contacts = otherStats.contacts;
        this.fastBodies = otherStats.fastBodies;
        this.fastBodyCollisions = otherStats.fastBodyCollisions;
        this.broadphase = otherStats.broadphase;
        this.narrowphase = otherStats.narrowphase;
      } else {
        this.pairs = this.collisions = this.fastBodies = 0;
        this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;
        this.contacts.clear();
      }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
      const ps = new PhysicsStats();
      ps.reset(this);
      return ps;
    }
    get pairs() {
      return this._pairs;
    }
    set pairs(value) {
      this._pairs = value;
    }
    get collisions() {
      return this._collisions;
    }
    set collisions(value) {
      this._collisions = value;
    }
    get contacts() {
      return this._contacts;
    }
    set contacts(contacts) {
      this._contacts = contacts;
    }
    get fastBodies() {
      return this._fastBodies;
    }
    set fastBodies(value) {
      this._fastBodies = value;
    }
    get fastBodyCollisions() {
      return this._fastBodyCollisions;
    }
    set fastBodyCollisions(value) {
      this._fastBodyCollisions = value;
    }
    get broadphase() {
      return this._broadphase;
    }
    set broadphase(value) {
      this._broadphase = value;
    }
    get narrowphase() {
      return this._narrowphase;
    }
    set narrowphase(value) {
      this._narrowphase = value;
    }
  }
  class BrowserComponent {
    on(eventName, handler) {
      if (this._nativeHandlers[eventName]) {
        this.off(eventName, this._nativeHandlers[eventName]);
      }
      this._nativeHandlers[eventName] = this._decorate(handler);
      this.nativeComponent.addEventListener(eventName, this._nativeHandlers[eventName]);
    }
    off(eventName, handler) {
      if (!handler) {
        handler = this._nativeHandlers[eventName];
      }
      this.nativeComponent.removeEventListener(eventName, handler);
      this._nativeHandlers[eventName] = null;
    }
    _decorate(handler) {
      return (evt) => {
        if (!this._paused) {
          handler(evt);
        }
      };
    }
    pause() {
      this._paused = true;
    }
    resume() {
      this._paused = false;
    }
    clear() {
      for (const event in this._nativeHandlers) {
        this.off(event);
      }
    }
    constructor(nativeComponent) {
      this.nativeComponent = nativeComponent;
      this._paused = false;
      this._nativeHandlers = {};
    }
  }
  class BrowserEvents {
    constructor(_windowGlobal, _documentGlobal) {
      this._windowGlobal = _windowGlobal;
      this._documentGlobal = _documentGlobal;
      this._windowComponent = new BrowserComponent(this._windowGlobal);
      this._documentComponent = new BrowserComponent(this._documentGlobal);
    }
    get window() {
      return this._windowComponent;
    }
    get document() {
      return this._documentComponent;
    }
    pause() {
      this.window.pause();
      this.document.pause();
    }
    resume() {
      this.window.resume();
      this.document.resume();
    }
    clear() {
      this.window.clear();
      this.document.clear();
    }
  }
  class GlobalCoordinates {
    static fromPagePosition(xOrPos, yOrEngine, engineOrUndefined) {
      let pageX;
      let pageY;
      let pagePos;
      let engine;
      if (arguments.length === 3) {
        pageX = xOrPos;
        pageY = yOrEngine;
        pagePos = new Vector(pageX, pageY);
        engine = engineOrUndefined;
      } else {
        pagePos = xOrPos;
        pageX = pagePos.x;
        pageY = pagePos.y;
        engine = yOrEngine;
      }
      const screenPos = engine.screen.pageToScreenCoordinates(pagePos);
      const worldPos = engine.screen.screenToWorldCoordinates(screenPos);
      return new GlobalCoordinates(worldPos, pagePos, screenPos);
    }
    constructor(worldPos, pagePos, screenPos) {
      this.worldPos = worldPos;
      this.pagePos = pagePos;
      this.screenPos = screenPos;
    }
  }
  class PointerEvent2 {
    cancel() {
      this.active = false;
    }
    get pagePos() {
      return this.coordinates.pagePos;
    }
    get screenPos() {
      return this.coordinates.screenPos;
    }
    get worldPos() {
      return this.coordinates.worldPos;
    }
    constructor(type, pointerId, button, pointerType, coordinates, nativeEvent) {
      this.type = type;
      this.pointerId = pointerId;
      this.button = button;
      this.pointerType = pointerType;
      this.coordinates = coordinates;
      this.nativeEvent = nativeEvent;
      this.active = true;
    }
  }
  class WheelEvent {
    cancel() {
      this.active = false;
    }
    constructor(x2, y2, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev) {
      this.x = x2;
      this.y = y2;
      this.pageX = pageX;
      this.pageY = pageY;
      this.screenX = screenX;
      this.screenY = screenY;
      this.index = index;
      this.deltaX = deltaX;
      this.deltaY = deltaY;
      this.deltaZ = deltaZ;
      this.deltaMode = deltaMode;
      this.ev = ev;
      this.active = true;
    }
  }
  class PointerAbstraction {
    constructor() {
      this.events = new EventEmitter2();
      this.lastPagePos = Vector.Zero;
      this.lastScreenPos = Vector.Zero;
      this.lastWorldPos = Vector.Zero;
      this._onPointerMove = (ev) => {
        this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);
        this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);
        this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);
      };
      this._onPointerDown = (ev) => {
        this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);
        this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);
        this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);
      };
      this.on("move", this._onPointerMove);
      this.on("down", this._onPointerDown);
    }
    emit(eventName, event) {
      this.events.emit(eventName, event);
    }
    on(eventName, handler) {
      return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
      return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
      this.events.off(eventName, handler);
    }
  }
  var WheelDeltaMode;
  (function(WheelDeltaMode2) {
    WheelDeltaMode2["Pixel"] = "Pixel";
    WheelDeltaMode2["Line"] = "Line";
    WheelDeltaMode2["Page"] = "Page";
  })(WheelDeltaMode || (WheelDeltaMode = {}));
  var NativePointerButton;
  (function(NativePointerButton2) {
    NativePointerButton2[NativePointerButton2["NoButton"] = -1] = "NoButton";
    NativePointerButton2[NativePointerButton2["Left"] = 0] = "Left";
    NativePointerButton2[NativePointerButton2["Middle"] = 1] = "Middle";
    NativePointerButton2[NativePointerButton2["Right"] = 2] = "Right";
    NativePointerButton2[NativePointerButton2["Unknown"] = 3] = "Unknown";
  })(NativePointerButton || (NativePointerButton = {}));
  var PointerButton;
  (function(PointerButton2) {
    PointerButton2["Left"] = "Left";
    PointerButton2["Middle"] = "Middle";
    PointerButton2["Right"] = "Right";
    PointerButton2["Unknown"] = "Unknown";
    PointerButton2["NoButton"] = "NoButton";
  })(PointerButton || (PointerButton = {}));
  var PointerType;
  (function(PointerType2) {
    PointerType2["Touch"] = "Touch";
    PointerType2["Mouse"] = "Mouse";
    PointerType2["Pen"] = "Pen";
    PointerType2["Unknown"] = "Unknown";
  })(PointerType || (PointerType = {}));
  function isTouchEvent(value) {
    return globalThis.TouchEvent && value instanceof globalThis.TouchEvent;
  }
  function isPointerEvent(value) {
    return globalThis.PointerEvent && value instanceof globalThis.PointerEvent;
  }
  class PointerEventReceiver {
    constructor(target, engine) {
      this.target = target;
      this.engine = engine;
      this.events = new EventEmitter2();
      this.primary = new PointerAbstraction();
      this._activeNativePointerIdsToNormalized = /* @__PURE__ */ new Map();
      this.lastFramePointerCoords = /* @__PURE__ */ new Map();
      this.currentFramePointerCoords = /* @__PURE__ */ new Map();
      this.currentFramePointerDown = /* @__PURE__ */ new Map();
      this.lastFramePointerDown = /* @__PURE__ */ new Map();
      this.currentFrameDown = [];
      this.currentFrameUp = [];
      this.currentFrameMove = [];
      this.currentFrameCancel = [];
      this.currentFrameWheel = [];
      this._pointers = [this.primary];
      this._boundHandle = this._handle.bind(this);
      this._boundWheel = this._handleWheel.bind(this);
    }
    /**
     * Creates a new PointerEventReceiver with a new target and engine while preserving existing pointer event
     * handlers.
     * @param target
     * @param engine
     */
    recreate(target, engine) {
      const eventReceiver = new PointerEventReceiver(target, engine);
      eventReceiver.primary = this.primary;
      eventReceiver._pointers = this._pointers;
      return eventReceiver;
    }
    /**
     * Locates a specific pointer by id, creates it if it doesn't exist
     * @param index
     */
    at(index) {
      if (index >= this._pointers.length) {
        for (let i2 = this._pointers.length - 1, max = index; i2 < max; i2++) {
          this._pointers.push(new PointerAbstraction());
        }
      }
      return this._pointers[index];
    }
    /**
     * The number of pointers currently being tracked by excalibur
     */
    count() {
      return this._pointers.length;
    }
    /**
     * Is the specified pointer id down this frame
     * @param pointerId
     */
    isDown(pointerId) {
      var _a;
      return (_a = this.currentFramePointerDown.get(pointerId)) !== null && _a !== void 0 ? _a : false;
    }
    /**
     * Was the specified pointer id down last frame
     * @param pointerId
     */
    wasDown(pointerId) {
      var _a;
      return (_a = this.lastFramePointerDown.get(pointerId)) !== null && _a !== void 0 ? _a : false;
    }
    /**
     * Whether the Pointer is currently dragging.
     */
    isDragging(pointerId) {
      return this.isDown(pointerId);
    }
    /**
     * Whether the Pointer just started dragging.
     */
    isDragStart(pointerId) {
      return this.isDown(pointerId) && !this.wasDown(pointerId);
    }
    /**
     * Whether the Pointer just ended dragging.
     */
    isDragEnd(pointerId) {
      return !this.isDown(pointerId) && this.wasDown(pointerId);
    }
    emit(eventName, event) {
      this.events.emit(eventName, event);
    }
    on(eventName, handler) {
      return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
      return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
      this.events.off(eventName, handler);
    }
    /**
     * Called internally by excalibur
     *
     * Updates the current frame pointer info and emits raw pointer events
     *
     * This does not emit events to entities, see PointerSystem
     */
    update() {
      this.lastFramePointerDown = new Map(this.currentFramePointerDown);
      this.lastFramePointerCoords = new Map(this.currentFramePointerCoords);
      for (const event of this.currentFrameDown) {
        this.emit("down", event);
        const pointer = this.at(event.pointerId);
        pointer.emit("down", event);
        this.primary.emit("pointerdown", event);
      }
      for (const event of this.currentFrameUp) {
        this.emit("up", event);
        const pointer = this.at(event.pointerId);
        pointer.emit("up", event);
      }
      for (const event of this.currentFrameMove) {
        this.emit("move", event);
        const pointer = this.at(event.pointerId);
        pointer.emit("move", event);
      }
      for (const event of this.currentFrameCancel) {
        this.emit("cancel", event);
        const pointer = this.at(event.pointerId);
        pointer.emit("cancel", event);
      }
      for (const event of this.currentFrameWheel) {
        this.emit("wheel", event);
        this.primary.emit("pointerwheel", event);
      }
    }
    /**
     * Clears the current frame event and pointer data
     */
    clear() {
      for (const event of this.currentFrameUp) {
        this.currentFramePointerCoords.delete(event.pointerId);
        const ids = this._activeNativePointerIdsToNormalized.entries();
        for (const [native, normalized] of ids) {
          if (normalized === event.pointerId) {
            this._activeNativePointerIdsToNormalized.delete(native);
          }
        }
      }
      this.currentFrameDown.length = 0;
      this.currentFrameUp.length = 0;
      this.currentFrameMove.length = 0;
      this.currentFrameCancel.length = 0;
      this.currentFrameWheel.length = 0;
    }
    /**
     * Initializes the pointer event receiver so that it can start listening to native
     * browser events.
     */
    init(options) {
      var _a;
      if (this.target === this.engine.canvas) {
        this.engine.canvas.style.touchAction = "none";
      } else {
        document.body.style.touchAction = "none";
      }
      if (window.PointerEvent) {
        this.target.addEventListener("pointerdown", this._boundHandle);
        this.target.addEventListener("pointerup", this._boundHandle);
        this.target.addEventListener("pointermove", this._boundHandle);
        this.target.addEventListener("pointercancel", this._boundHandle);
      } else {
        this.target.addEventListener("touchstart", this._boundHandle);
        this.target.addEventListener("touchend", this._boundHandle);
        this.target.addEventListener("touchmove", this._boundHandle);
        this.target.addEventListener("touchcancel", this._boundHandle);
        this.target.addEventListener("mousedown", this._boundHandle);
        this.target.addEventListener("mouseup", this._boundHandle);
        this.target.addEventListener("mousemove", this._boundHandle);
      }
      const wheelOptions = {
        passive: !(this.engine.pageScrollPreventionMode === ScrollPreventionMode.All || this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas)
      };
      if ("onwheel" in document.createElement("div")) {
        this.target.addEventListener("wheel", this._boundWheel, wheelOptions);
      } else if (document.onmousewheel !== void 0) {
        this.target.addEventListener("mousewheel", this._boundWheel, wheelOptions);
      } else {
        this.target.addEventListener("MozMousePixelScroll", this._boundWheel, wheelOptions);
      }
      const grabWindowFocus = (_a = options === null || options === void 0 ? void 0 : options.grabWindowFocus) !== null && _a !== void 0 ? _a : true;
      if (grabWindowFocus && isCrossOriginIframe()) {
        const grabFocus = () => {
          window.focus();
        };
        if (window.PointerEvent) {
          this.target.addEventListener("pointerdown", grabFocus);
        } else {
          this.target.addEventListener("touchstart", grabFocus);
          this.target.addEventListener("mousedown", grabFocus);
        }
      }
    }
    detach() {
      if (window.PointerEvent) {
        this.target.removeEventListener("pointerdown", this._boundHandle);
        this.target.removeEventListener("pointerup", this._boundHandle);
        this.target.removeEventListener("pointermove", this._boundHandle);
        this.target.removeEventListener("pointercancel", this._boundHandle);
      } else {
        this.target.removeEventListener("touchstart", this._boundHandle);
        this.target.removeEventListener("touchend", this._boundHandle);
        this.target.removeEventListener("touchmove", this._boundHandle);
        this.target.removeEventListener("touchcancel", this._boundHandle);
        this.target.removeEventListener("mousedown", this._boundHandle);
        this.target.removeEventListener("mouseup", this._boundHandle);
        this.target.removeEventListener("mousemove", this._boundHandle);
      }
      if ("onwheel" in document.createElement("div")) {
        this.target.removeEventListener("wheel", this._boundWheel);
      } else if (document.onmousewheel !== void 0) {
        this.target.addEventListener("mousewheel", this._boundWheel);
      } else {
        this.target.addEventListener("MozMousePixelScroll", this._boundWheel);
      }
    }
    /**
     * Take native pointer id and map it to index in active pointers
     * @param nativePointerId
     */
    _normalizePointerId(nativePointerId) {
      this._activeNativePointerIdsToNormalized.set(nativePointerId, -1);
      const currentPointerIds = Array.from(this._activeNativePointerIdsToNormalized.keys()).sort((a2, b2) => a2 - b2);
      const id2 = currentPointerIds.findIndex((p2) => p2 === nativePointerId);
      this._activeNativePointerIdsToNormalized.set(nativePointerId, id2);
      return id2;
    }
    /**
     * Responsible for handling and parsing pointer events
     */
    _handle(ev) {
      ev.preventDefault();
      const eventCoords = /* @__PURE__ */ new Map();
      let button;
      let pointerType;
      if (isTouchEvent(ev)) {
        button = PointerButton.Unknown;
        pointerType = PointerType.Touch;
        for (let i2 = 0; i2 < ev.changedTouches.length; i2++) {
          const touch = ev.changedTouches[i2];
          const coordinates = GlobalCoordinates.fromPagePosition(touch.pageX, touch.pageY, this.engine);
          const nativePointerId = i2 + 1;
          const pointerId = this._normalizePointerId(nativePointerId);
          this.currentFramePointerCoords.set(pointerId, coordinates);
          eventCoords.set(pointerId, coordinates);
        }
      } else {
        button = this._nativeButtonToPointerButton(ev.button);
        pointerType = PointerType.Mouse;
        const coordinates = GlobalCoordinates.fromPagePosition(ev.pageX, ev.pageY, this.engine);
        let nativePointerId = 1;
        if (isPointerEvent(ev)) {
          nativePointerId = ev.pointerId;
          pointerType = this._stringToPointerType(ev.pointerType);
        }
        const pointerId = this._normalizePointerId(nativePointerId);
        this.currentFramePointerCoords.set(pointerId, coordinates);
        eventCoords.set(pointerId, coordinates);
      }
      for (const [pointerId, coord] of eventCoords.entries()) {
        switch (ev.type) {
          case "mousedown":
          case "pointerdown":
          case "touchstart":
            this.currentFrameDown.push(new PointerEvent2("down", pointerId, button, pointerType, coord, ev));
            this.currentFramePointerDown.set(pointerId, true);
            break;
          case "mouseup":
          case "pointerup":
          case "touchend":
            this.currentFrameUp.push(new PointerEvent2("up", pointerId, button, pointerType, coord, ev));
            this.currentFramePointerDown.set(pointerId, false);
            break;
          case "mousemove":
          case "pointermove":
          case "touchmove":
            this.currentFrameMove.push(new PointerEvent2("move", pointerId, button, pointerType, coord, ev));
            break;
          case "touchcancel":
          case "pointercancel":
            this.currentFrameCancel.push(new PointerEvent2("cancel", pointerId, button, pointerType, coord, ev));
            break;
        }
      }
    }
    _handleWheel(ev) {
      if (this.engine.pageScrollPreventionMode === ScrollPreventionMode.All || this.engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas && ev.target === this.engine.canvas) {
        ev.preventDefault();
      }
      const screen = this.engine.screen.pageToScreenCoordinates(vec(ev.pageX, ev.pageY));
      const world = this.engine.screen.screenToWorldCoordinates(screen);
      const ScrollWheelNormalizationFactor = -1 / 40;
      const deltaX = ev.deltaX || ev.wheelDeltaX * ScrollWheelNormalizationFactor || 0;
      const deltaY = ev.deltaY || ev.wheelDeltaY * ScrollWheelNormalizationFactor || ev.wheelDelta * ScrollWheelNormalizationFactor || ev.detail || 0;
      const deltaZ = ev.deltaZ || 0;
      let deltaMode = WheelDeltaMode.Pixel;
      if (ev.deltaMode) {
        if (ev.deltaMode === 1) {
          deltaMode = WheelDeltaMode.Line;
        } else if (ev.deltaMode === 2) {
          deltaMode = WheelDeltaMode.Page;
        }
      }
      const we2 = new WheelEvent(world.x, world.y, ev.pageX, ev.pageY, screen.x, screen.y, 0, deltaX, deltaY, deltaZ, deltaMode, ev);
      this.currentFrameWheel.push(we2);
    }
    /**
     * Triggers an excalibur pointer event in a world space pos
     *
     * Useful for testing pointers in excalibur
     * @param type
     * @param pos
     */
    triggerEvent(type, pos) {
      const page = this.engine.screen.worldToPageCoordinates(pos);
      if (window.PointerEvent) {
        this._handle(new window.PointerEvent("pointer" + type, {
          pointerId: 0,
          clientX: page.x,
          clientY: page.y
        }));
      } else {
        this._handle(new window.MouseEvent("mouse" + type, {
          clientX: page.x,
          clientY: page.y
        }));
      }
      const pointerSystem = this.engine.currentScene.world.systemManager.get(PointerSystem);
      const transformEntities = this.engine.currentScene.world.queryManager.createQuery(pointerSystem.types);
      pointerSystem.preupdate();
      pointerSystem.update(transformEntities.getEntities());
    }
    _nativeButtonToPointerButton(s2) {
      switch (s2) {
        case NativePointerButton.NoButton:
          return PointerButton.NoButton;
        case NativePointerButton.Left:
          return PointerButton.Left;
        case NativePointerButton.Middle:
          return PointerButton.Middle;
        case NativePointerButton.Right:
          return PointerButton.Right;
        case NativePointerButton.Unknown:
          return PointerButton.Unknown;
        default:
          return fail(s2);
      }
    }
    _stringToPointerType(s2) {
      switch (s2) {
        case "touch":
          return PointerType.Touch;
        case "mouse":
          return PointerType.Mouse;
        case "pen":
          return PointerType.Pen;
        default:
          return PointerType.Unknown;
      }
    }
  }
  class FpsSampler {
    constructor(options) {
      var _a;
      this._samplePeriod = 100;
      this._currentFrameTime = 0;
      this._frames = 0;
      this._previousSampleTime = 0;
      this._beginFrameTime = 0;
      this._fps = options.initialFps;
      this._samplePeriod = (_a = options.samplePeriod) !== null && _a !== void 0 ? _a : this._samplePeriod;
      this._currentFrameTime = 1e3 / options.initialFps;
      this._nowFn = options.nowFn;
      this._previousSampleTime = this._nowFn();
    }
    /**
     * Start of code block to sample FPS for
     */
    start() {
      this._beginFrameTime = this._nowFn();
    }
    /**
     * End of code block to sample FPS for
     */
    end() {
      this._frames++;
      const time = this._nowFn();
      this._currentFrameTime = time - this._beginFrameTime;
      if (time >= this._previousSampleTime + this._samplePeriod) {
        this._fps = this._frames * 1e3 / (time - this._previousSampleTime);
        this._previousSampleTime = time;
        this._frames = 0;
      }
    }
    /**
     * Return the currently sampled fps over the last sample period, by default every 100ms
     */
    get fps() {
      return this._fps;
    }
    /**
     * Return the instantaneous fps, this can be less useful because it will fluctuate given the current frames time
     */
    get instant() {
      return 1e3 / this._currentFrameTime;
    }
  }
  class Clock {
    constructor(options) {
      var _a, _b, _c;
      this._onFatalException = () => {
      };
      this._maxFps = Infinity;
      this._lastTime = 0;
      this._elapsed = 1;
      this._scheduledCbs = [];
      this._totalElapsed = 0;
      this._options = options;
      this.tick = options.tick;
      this._lastTime = (_a = this.now()) !== null && _a !== void 0 ? _a : 0;
      this._maxFps = (_b = options.maxFps) !== null && _b !== void 0 ? _b : this._maxFps;
      this._onFatalException = (_c = options.onFatalException) !== null && _c !== void 0 ? _c : this._onFatalException;
      this.fpsSampler = new FpsSampler({
        initialFps: 60,
        nowFn: () => this.now()
      });
    }
    /**
     * Get the elapsed time for the last completed frame
     */
    elapsed() {
      return this._elapsed;
    }
    /**
     * Get the current time in milliseconds
     */
    now() {
      return performance.now();
    }
    toTestClock() {
      const testClock = new TestClock({
        ...this._options,
        defaultUpdateMs: 16.6
      });
      return testClock;
    }
    toStandardClock() {
      const clock = new StandardClock({
        ...this._options
      });
      return clock;
    }
    setFatalExceptionHandler(handler) {
      this._onFatalException = handler;
    }
    /**
     * Schedule a callback to fire given a timeout in milliseconds using the excalibur [[Clock]]
     *
     * This is useful to use over the built in browser `setTimeout` because callbacks will be tied to the
     * excalibur update clock, instead of browser time, this means that callbacks wont fire if the game is
     * stopped or paused.
     *
     * @param cb callback to fire
     * @param timeoutMs Optionally specify a timeout in milliseconds from now, default is 0ms which means the next possible tick
     */
    schedule(cb2, timeoutMs = 0) {
      const scheduledTime = this._totalElapsed + timeoutMs;
      this._scheduledCbs.push([cb2, scheduledTime]);
    }
    _runScheduledCbs() {
      for (let i2 = this._scheduledCbs.length - 1; i2 > -1; i2--) {
        if (this._scheduledCbs[i2][1] <= this._totalElapsed) {
          this._scheduledCbs[i2][0]();
          this._scheduledCbs.splice(i2, 1);
        }
      }
    }
    update(overrideUpdateMs) {
      try {
        this.fpsSampler.start();
        const now = this.now();
        let elapsed = now - this._lastTime || 1;
        const fpsInterval = 1e3 / this._maxFps;
        if (elapsed >= fpsInterval) {
          let leftover = 0;
          if (fpsInterval !== 0) {
            leftover = elapsed % fpsInterval;
            elapsed = elapsed - leftover;
          }
          if (elapsed > 200) {
            elapsed = 1;
          }
          this._elapsed = overrideUpdateMs || elapsed;
          this._totalElapsed += this._elapsed;
          this._runScheduledCbs();
          this.tick(overrideUpdateMs || elapsed);
          if (fpsInterval !== 0) {
            this._lastTime = now - leftover;
          } else {
            this._lastTime = now;
          }
          this.fpsSampler.end();
        }
      } catch (e2) {
        this._onFatalException(e2);
        this.stop();
      }
    }
  }
  class StandardClock extends Clock {
    constructor(options) {
      super(options);
      this._running = false;
    }
    isRunning() {
      return this._running;
    }
    start() {
      if (this._running) {
        return;
      }
      this._running = true;
      const mainloop = () => {
        if (!this._running) {
          return;
        }
        try {
          this._requestId = window.requestAnimationFrame(mainloop);
          this.update();
        } catch (e2) {
          window.cancelAnimationFrame(this._requestId);
          throw e2;
        }
      };
      mainloop();
    }
    stop() {
      this._running = false;
    }
  }
  class TestClock extends Clock {
    constructor(options) {
      super({
        ...options
      });
      this._logger = Logger2.getInstance();
      this._running = false;
      this._currentTime = 0;
      this._updateMs = options.defaultUpdateMs;
    }
    /**
     * Get the current time in milliseconds
     */
    now() {
      var _a;
      return (_a = this._currentTime) !== null && _a !== void 0 ? _a : 0;
    }
    isRunning() {
      return this._running;
    }
    start() {
      this._running = true;
    }
    stop() {
      this._running = false;
    }
    /**
     * Manually step the clock forward 1 tick, optionally specify an elapsed time in milliseconds
     * @param overrideUpdateMs
     */
    step(overrideUpdateMs) {
      const time = overrideUpdateMs !== null && overrideUpdateMs !== void 0 ? overrideUpdateMs : this._updateMs;
      if (this._running) {
        this.update(time);
        this._currentTime += time;
      } else {
        this._logger.warn("The clock is not running, no step will be performed");
      }
    }
    /**
     * Run a number of steps that tick the clock, optionally specify an elapsed time in milliseconds
     * @param numberOfSteps
     * @param overrideUpdateMs
     */
    run(numberOfSteps, overrideUpdateMs) {
      for (let i2 = 0; i2 < numberOfSteps; i2++) {
        this.step(overrideUpdateMs !== null && overrideUpdateMs !== void 0 ? overrideUpdateMs : this._updateMs);
      }
    }
  }
  var Util_Toaster = __webpack_require__(7379);
  class Toaster {
    constructor() {
      this._toasterCss = Util_Toaster.Z.toString();
      this._isInitialized = false;
    }
    _initialize() {
      if (!this._isInitialized) {
        this._container = document.createElement("div");
        this._container.id = "ex-toast-container";
        document.body.appendChild(this._container);
        this._isInitialized = true;
        this._styleBlock = document.createElement("style");
        this._styleBlock.textContent = this._toasterCss;
        document.head.appendChild(this._styleBlock);
      }
    }
    dispose() {
      this._container.parentElement.removeChild(this._container);
      this._styleBlock.parentElement.removeChild(this._styleBlock);
      this._isInitialized = false;
    }
    _createFragment(message) {
      const toastMessage = document.createElement("span");
      toastMessage.innerText = message;
      return toastMessage;
    }
    /**
     * Display a toast message to a player
     * @param message Text of the message, messages may have a single "[LINK]" to influence placement
     * @param linkTarget Optionally specify a link location
     * @param linkName Optionally specify a name for that link location
     */
    toast(message, linkTarget, linkName) {
      this._initialize();
      const toast = document.createElement("div");
      toast.className = "ex-toast-message";
      const messageFragments = message.split("[LINK]").map((message2) => this._createFragment(message2));
      if (linkTarget) {
        const link = document.createElement("a");
        link.href = linkTarget;
        if (linkName) {
          link.innerText = linkName;
        } else {
          link.innerText = linkTarget;
        }
        messageFragments.splice(1, 0, link);
      }
      const finalMessage = document.createElement("div");
      messageFragments.forEach((message2) => {
        finalMessage.appendChild(message2);
      });
      toast.appendChild(finalMessage);
      const dismissBtn = document.createElement("button");
      dismissBtn.innerText = "x";
      dismissBtn.addEventListener("click", () => {
        this._container.removeChild(toast);
      });
      toast.appendChild(dismissBtn);
      const keydownHandler = (evt) => {
        if (evt.key === "Escape") {
          try {
            this._container.removeChild(toast);
          } catch (_a) {
          }
        }
        document.removeEventListener("keydown", keydownHandler);
      };
      document.addEventListener("keydown", keydownHandler);
      const first = this._container.firstChild;
      this._container.insertBefore(toast, first);
    }
  }
  class InputMapper {
    constructor(inputs) {
      this.inputs = inputs;
      this._handlers = /* @__PURE__ */ new Map();
    }
    /**
     * Executes the input map, called internally by Excalibur
     */
    execute() {
      for (const [input, command] of this._handlers.entries()) {
        const results2 = input(this.inputs);
        if (results2) {
          command(results2);
        }
      }
    }
    /**
     * This allows you to map multiple inputs to specific commands! This is useful
     *
     * The inputHandler should return a truthy value if you wish the commandHandler to fire.
     *
     * Example:
     * ```typescript
     * const moveRight = (amount: number) => { actor.vel.x = 100 * amount }
     * const moveLeft = (amount: number) => { actor.vel.x = -100 * amount }
     * const moveUp = (amount: number) => { actor.vel.y = -100 * amount }
     * const moveDown = (amount: number) => { actor.vel.y = 100 * amount }
     *
     * engine.inputMapper.on(({keyboard}) => keyboard.isHeld(ex.Keys.ArrowRight) ? 1 : 0, moveRight);
     * engine.inputMapper.on(({gamepads}) => gamepads.at(0).isButtonPressed(ex.Buttons.DpadRight) ? 1 : 0, moveRight);
     * engine.inputMapper.on(({gamepads}) => gamepads.at(0).getAxes(ex.Axes.LeftStickX) > 0 ?
     *  gamepads.at(0).getAxes(ex.Axes.LeftStickX) : 0, moveRight);
     * ```
     * @param inputHandler
     * @param commandHandler
     */
    on(inputHandler, commandHandler) {
      this._handlers.set(inputHandler, commandHandler);
    }
  }
  polyfill2();
  const EngineEvents = {
    FallbackGraphicsContext: "fallbackgraphicscontext",
    Initialize: "initialize",
    Visible: "visible",
    Hidden: "hidden",
    Start: "start",
    Stop: "stop",
    PreUpdate: "preupdate",
    PostUpdate: "postupdate",
    PreFrame: "preframe",
    PostFrame: "postframe",
    PreDraw: "predraw",
    PostDraw: "postdraw"
  };
  var ScrollPreventionMode;
  (function(ScrollPreventionMode2) {
    ScrollPreventionMode2[ScrollPreventionMode2["None"] = 0] = "None";
    ScrollPreventionMode2[ScrollPreventionMode2["Canvas"] = 1] = "Canvas";
    ScrollPreventionMode2[ScrollPreventionMode2["All"] = 2] = "All";
  })(ScrollPreventionMode || (ScrollPreventionMode = {}));
  class Engine {
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
      return this.screen.canvasWidth;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
      return this.screen.halfCanvasWidth;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
      return this.screen.canvasHeight;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
      return this.screen.halfCanvasHeight;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
      return this.screen.drawWidth;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
      return this.screen.halfDrawWidth;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
      return this.screen.drawHeight;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
      return this.screen.halfDrawHeight;
    }
    /**
     * Returns whether excalibur detects the current screen to be HiDPI
     */
    get isHiDpi() {
      return this.screen.isHiDpi;
    }
    /**
     * Access [[stats]] that holds frame statistics.
     */
    get stats() {
      return this.debug.stats;
    }
    /**
     * Indicates whether the engine is set to fullscreen or not
     */
    get isFullscreen() {
      return this.screen.isFullScreen;
    }
    /**
     * Indicates the current [[DisplayMode]] of the engine.
     */
    get displayMode() {
      return this.screen.displayMode;
    }
    /**
     * Returns the calculated pixel ration for use in rendering
     */
    get pixelRatio() {
      return this.screen.pixelRatio;
    }
    get isDebug() {
      return this._isDebug;
    }
    /**
     * Hints the graphics context to truncate fractional world space coordinates
     */
    get snapToPixel() {
      return this.graphicsContext.snapToPixel;
    }
    set snapToPixel(shouldSnapToPixel) {
      this.graphicsContext.snapToPixel = shouldSnapToPixel;
    }
    emit(eventName, event) {
      this.events.emit(eventName, event);
    }
    on(eventName, handler) {
      return this.events.on(eventName, handler);
    }
    once(eventName, handler) {
      return this.events.once(eventName, handler);
    }
    off(eventName, handler) {
      this.events.off(eventName, handler);
    }
    /**
     * Creates a new game using the given [[EngineOptions]]. By default, if no options are provided,
     * the game will be rendered full screen (taking up all available browser window space).
     * You can customize the game rendering through [[EngineOptions]].
     *
     * Example:
     *
     * ```js
     * var game = new ex.Engine({
     *   width: 0, // the width of the canvas
     *   height: 0, // the height of the canvas
     *   enableCanvasTransparency: true, // the transparencySection of the canvas
     *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own
     *   displayMode: ex.DisplayMode.FullScreen, // the display mode
     *   pointerScope: ex.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events
     *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine
     * });
     *
     * // call game.start, which is a Promise
     * game.start().then(function () {
     *   // ready, set, go!
     * });
     * ```
     */
    constructor(options) {
      var _a, _b, _c, _d, _e, _f;
      this.events = new EventEmitter2();
      this.maxFps = Number.POSITIVE_INFINITY;
      this.scenes = {};
      this._suppressPlayButton = false;
      this.pauseAudioWhenHidden = true;
      this._isDebug = false;
      this.enableCanvasTransparency = true;
      this.onFatalException = (e2) => {
        Logger2.getInstance().fatal(e2);
      };
      this._toaster = new Toaster();
      this._timescale = 1;
      this._isInitialized = false;
      this._deferredGoTo = null;
      this._originalOptions = {};
      this._performanceThresholdTriggered = false;
      this._fpsSamples = [];
      this._loadingComplete = false;
      this._isReady = false;
      this._isReadyPromise = new Promise((resolve) => {
        this._isReadyResolve = resolve;
      });
      this.currentFrameElapsedMs = 0;
      this.currentFrameLagMs = 0;
      this._lagMs = 0;
      this._screenShotRequests = [];
      options = { ...Engine._DEFAULT_ENGINE_OPTIONS, ...options };
      this._originalOptions = options;
      Flags.freeze();
      this.browser = new BrowserEvents(window, document);
      const detector = new Detector();
      if (!options.suppressMinimumBrowserFeatureDetection && !(this._compatible = detector.test())) {
        const message = document.createElement("div");
        message.innerText = "Sorry, your browser does not support all the features needed for Excalibur";
        document.body.appendChild(message);
        detector.failedTests.forEach(function(test2) {
          const testMessage = document.createElement("div");
          testMessage.innerText = "Browser feature missing " + test2;
          document.body.appendChild(testMessage);
        });
        if (options.canvasElementId) {
          const canvas = document.getElementById(options.canvasElementId);
          if (canvas) {
            canvas.parentElement.removeChild(canvas);
          }
        }
        return;
      } else {
        this._compatible = true;
      }
      if (console.log && !options.suppressConsoleBootMessage) {
        console.log(`%cPowered by Excalibur.js (v${EX_VERSION})`, "background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;");
        console.log("\n      /| ________________\nO|===|* >________________>\n      \\|");
        console.log("Visit", "http://excaliburjs.com", "for more information");
      }
      if (options.suppressPlayButton) {
        this._suppressPlayButton = true;
      }
      this._logger = Logger2.getInstance();
      if (this._logger.defaultLevel === LogLevel.Debug) {
        detector.logBrowserFeatures();
      }
      this._logger.debug("Building engine...");
      this.canvasElementId = options.canvasElementId;
      if (options.canvasElementId) {
        this._logger.debug("Using Canvas element specified: " + options.canvasElementId);
        this.canvas = document.getElementById(options.canvasElementId);
      } else if (options.canvasElement) {
        this._logger.debug("Using Canvas element specified:", options.canvasElement);
        this.canvas = options.canvasElement;
      } else {
        this._logger.debug("Using generated canvas element");
        this.canvas = document.createElement("canvas");
      }
      let displayMode = (_a = options.displayMode) !== null && _a !== void 0 ? _a : DisplayMode.Fixed;
      if (options.width && options.height || options.viewport) {
        if (options.displayMode === void 0) {
          displayMode = DisplayMode.Fixed;
        }
        this._logger.debug("Engine viewport is size " + options.width + " x " + options.height);
      } else if (!options.displayMode) {
        this._logger.debug("Engine viewport is fit");
        displayMode = DisplayMode.FitScreen;
      }
      this._originalDisplayMode = displayMode;
      let useCanvasGraphicsContext = Flags.isEnabled("use-canvas-context");
      if (!useCanvasGraphicsContext) {
        try {
          this.graphicsContext = new ExcaliburGraphicsContextWebGL({
            canvasElement: this.canvas,
            enableTransparency: this.enableCanvasTransparency,
            smoothing: options.antialiasing,
            backgroundColor: options.backgroundColor,
            snapToPixel: options.snapToPixel,
            useDrawSorting: options.useDrawSorting
          });
        } catch (e2) {
          this._logger.warn(`Excalibur could not load webgl for some reason (${e2.message}) and loaded a Canvas 2D fallback. Some features of Excalibur will not work in this mode. 

Read more about this issue at https://excaliburjs.com/docs/webgl`);
          useCanvasGraphicsContext = true;
        }
      }
      if (useCanvasGraphicsContext) {
        this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({
          canvasElement: this.canvas,
          enableTransparency: this.enableCanvasTransparency,
          smoothing: options.antialiasing,
          backgroundColor: options.backgroundColor,
          snapToPixel: options.snapToPixel,
          useDrawSorting: options.useDrawSorting
        });
      }
      this.screen = new Screen({
        canvas: this.canvas,
        context: this.graphicsContext,
        antialiasing: (_b = options.antialiasing) !== null && _b !== void 0 ? _b : true,
        browser: this.browser,
        viewport: (_c = options.viewport) !== null && _c !== void 0 ? _c : options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA,
        resolution: options.resolution,
        displayMode,
        pixelRatio: options.suppressHiDPIScaling ? 1 : (_d = options.pixelRatio) !== null && _d !== void 0 ? _d : null
      });
      TextureLoader.filtering = options.antialiasing ? ImageFiltering.Blended : ImageFiltering.Pixel;
      if (options.backgroundColor) {
        this.backgroundColor = options.backgroundColor.clone();
      }
      this.maxFps = (_e = options.maxFps) !== null && _e !== void 0 ? _e : this.maxFps;
      this.fixedUpdateFps = (_f = options.fixedUpdateFps) !== null && _f !== void 0 ? _f : this.fixedUpdateFps;
      this.clock = new StandardClock({
        maxFps: this.maxFps,
        tick: this._mainloop.bind(this),
        onFatalException: (e2) => this.onFatalException(e2)
      });
      this.enableCanvasTransparency = options.enableCanvasTransparency;
      this._loader = new Loader();
      this._loader.wireEngine(this);
      this.debug = new Debug(this);
      this._initialize(options);
      this.rootScene = this.currentScene = new Scene();
      this.addScene("root", this.rootScene);
      window.___EXCALIBUR_DEVTOOL = this;
    }
    _monitorPerformanceThresholdAndTriggerFallback() {
      const { allow } = this._originalOptions.configurePerformanceCanvas2DFallback;
      let { threshold, showPlayerMessage } = this._originalOptions.configurePerformanceCanvas2DFallback;
      if (threshold === void 0) {
        threshold = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.threshold;
      }
      if (showPlayerMessage === void 0) {
        showPlayerMessage = Engine._DEFAULT_ENGINE_OPTIONS.configurePerformanceCanvas2DFallback.showPlayerMessage;
      }
      if (!Flags.isEnabled("use-canvas-context") && allow && this.ready && !this._performanceThresholdTriggered) {
        if (this._fpsSamples.length === threshold.numberOfFrames) {
          this._fpsSamples.splice(0, 1);
        }
        this._fpsSamples.push(this.clock.fpsSampler.fps);
        let total = 0;
        for (let i2 = 0; i2 < this._fpsSamples.length; i2++) {
          total += this._fpsSamples[i2];
        }
        const average = total / this._fpsSamples.length;
        if (this._fpsSamples.length === threshold.numberOfFrames) {
          if (average <= threshold.fps) {
            this._performanceThresholdTriggered = true;
            this._logger.warn(`Switching to browser 2D Canvas fallback due to performance. Some features of Excalibur will not work in this mode.
this might mean your browser doesn't have webgl enabled or hardware acceleration is unavailable.

If in Chrome:
  * Visit Settings > Advanced > System, and ensure "Use Hardware Acceleration" is checked.
  * Visit chrome://flags/#ignore-gpu-blocklist and ensure "Override software rendering list" is "enabled"
If in Firefox, visit about:config
  * Ensure webgl.disabled = false
  * Ensure webgl.force-enabled = true
  * Ensure layers.acceleration.force-enabled = true

Read more about this issue at https://excaliburjs.com/docs/performance`);
            if (showPlayerMessage) {
              this._toaster.toast("Excalibur is encountering performance issues. It's possible that your browser doesn't have hardware acceleration enabled. Visit [LINK] for more information and potential solutions.", "https://excaliburjs.com/docs/performance");
            }
            this.useCanvas2DFallback();
            this.emit("fallbackgraphicscontext", this.graphicsContext);
          }
        }
      }
    }
    /**
     * Switches the engine's graphics context to the 2D Canvas.
     * @warning Some features of Excalibur will not work in this mode.
     */
    useCanvas2DFallback() {
      var _a, _b, _c;
      const newCanvas = this.canvas.cloneNode(false);
      this.canvas.parentNode.replaceChild(newCanvas, this.canvas);
      this.canvas = newCanvas;
      const options = this._originalOptions;
      const displayMode = this._originalDisplayMode;
      this.graphicsContext = new ExcaliburGraphicsContext2DCanvas({
        canvasElement: this.canvas,
        enableTransparency: this.enableCanvasTransparency,
        smoothing: options.antialiasing,
        backgroundColor: options.backgroundColor,
        snapToPixel: options.snapToPixel,
        useDrawSorting: options.useDrawSorting
      });
      if (this.screen) {
        this.screen.dispose();
      }
      this.screen = new Screen({
        canvas: this.canvas,
        context: this.graphicsContext,
        antialiasing: (_a = options.antialiasing) !== null && _a !== void 0 ? _a : true,
        browser: this.browser,
        viewport: (_b = options.viewport) !== null && _b !== void 0 ? _b : options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA,
        resolution: options.resolution,
        displayMode,
        pixelRatio: options.suppressHiDPIScaling ? 1 : (_c = options.pixelRatio) !== null && _c !== void 0 ? _c : null
      });
      this.screen.setCurrentCamera(this.currentScene.camera);
      this.input.pointers.detach();
      const pointerTarget = options && options.pointerScope === PointerScope.Document ? document : this.canvas;
      this.input.pointers = this.input.pointers.recreate(pointerTarget, this);
      this.input.pointers.init();
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     */
    getWorldBounds() {
      return this.screen.getWorldBounds();
    }
    /**
     * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)
     */
    get timescale() {
      return this._timescale;
    }
    /**
     * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects
     * when using time-based movement.
     */
    set timescale(value) {
      if (value <= 0) {
        Logger2.getInstance().error("Cannot set engine.timescale to a value of 0 or less than 0.");
        return;
      }
      this._timescale = value;
    }
    /**
     * Adds a [[Timer]] to the [[currentScene]].
     * @param timer  The timer to add to the [[currentScene]].
     */
    addTimer(timer) {
      return this.currentScene.addTimer(timer);
    }
    /**
     * Removes a [[Timer]] from the [[currentScene]].
     * @param timer  The timer to remove to the [[currentScene]].
     */
    removeTimer(timer) {
      return this.currentScene.removeTimer(timer);
    }
    /**
     * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you
     * would levels or menus.
     *
     * @param key  The name of the scene, must be unique
     * @param scene The scene to add to the engine
     */
    addScene(key, scene) {
      if (this.scenes[key]) {
        this._logger.warn("Scene", key, "already exists overwriting");
      }
      this.scenes[key] = scene;
    }
    /**
     * @internal
     */
    removeScene(entity) {
      if (entity instanceof Scene) {
        for (const key in this.scenes) {
          if (this.scenes.hasOwnProperty(key)) {
            if (this.scenes[key] === entity) {
              delete this.scenes[key];
            }
          }
        }
      }
      if (typeof entity === "string") {
        delete this.scenes[entity];
      }
    }
    add(entity) {
      if (arguments.length === 2) {
        this.addScene(arguments[0], arguments[1]);
        return;
      }
      if (this._deferredGoTo && this.scenes[this._deferredGoTo]) {
        this.scenes[this._deferredGoTo].add(entity);
      } else {
        this.currentScene.add(entity);
      }
    }
    remove(entity) {
      if (entity instanceof Entity) {
        this.currentScene.remove(entity);
      }
      if (entity instanceof Scene) {
        this.removeScene(entity);
      }
      if (typeof entity === "string") {
        this.removeScene(entity);
      }
    }
    /**
     * Changes the currently updating and drawing scene to a different,
     * named scene. Calls the [[Scene]] lifecycle events.
     * @param key  The key of the scene to transition to.
     * @param data Optional data to send to the scene's onActivate method
     */
    goToScene(key, data) {
      if (!this.isInitialized) {
        this._deferredGoTo = key;
        return;
      }
      if (this.scenes[key]) {
        const previousScene = this.currentScene;
        const nextScene = this.scenes[key];
        this._logger.debug("Going to scene:", key);
        if (this.currentScene.isInitialized) {
          const context2 = { engine: this, previousScene, nextScene };
          this.currentScene._deactivate.apply(this.currentScene, [context2, nextScene]);
          this.currentScene.events.emit("deactivate", new DeactivateEvent(context2, this.currentScene));
        }
        this.currentScene = nextScene;
        this.screen.setCurrentCamera(nextScene.camera);
        this.currentScene._initialize(this);
        const context = { engine: this, previousScene, nextScene, data };
        this.currentScene._activate.apply(this.currentScene, [context, nextScene]);
        this.currentScene.events.emit("activate", new ActivateEvent(context, this.currentScene));
      } else {
        this._logger.error("Scene", key, "does not exist!");
      }
    }
    /**
     * Transforms the current x, y from screen coordinates to world coordinates
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point2) {
      return this.screen.screenToWorldCoordinates(point2);
    }
    /**
     * Transforms a world coordinate, to a screen coordinate
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point2) {
      return this.screen.worldToScreenCoordinates(point2);
    }
    /**
     * Initializes the internal canvas, rendering context, display mode, and native event listeners
     */
    _initialize(options) {
      var _a, _b, _c, _d;
      this.pageScrollPreventionMode = options.scrollPreventionMode;
      const pointerTarget = options && options.pointerScope === PointerScope.Document ? document : this.canvas;
      this.input = {
        keyboard: new Keyboard(),
        pointers: new PointerEventReceiver(pointerTarget, this),
        gamepads: new Gamepads()
      };
      this.input.keyboard.init({
        grabWindowFocus: (_b = (_a = this._originalOptions) === null || _a === void 0 ? void 0 : _a.grabWindowFocus) !== null && _b !== void 0 ? _b : true
      });
      this.input.pointers.init({
        grabWindowFocus: (_d = (_c = this._originalOptions) === null || _c === void 0 ? void 0 : _c.grabWindowFocus) !== null && _d !== void 0 ? _d : true
      });
      this.input.gamepads.init();
      this.inputMapper = new InputMapper(this.input);
      this.browser.document.on("visibilitychange", () => {
        if (document.visibilityState === "hidden") {
          this.events.emit("hidden", new HiddenEvent(this));
          this._logger.debug("Window hidden");
        } else if (document.visibilityState === "visible") {
          this.events.emit("visible", new VisibleEvent(this));
          this._logger.debug("Window visible");
        }
      });
      if (!this.canvasElementId && !options.canvasElement) {
        document.body.appendChild(this.canvas);
      }
    }
    onInitialize(_engine) {
    }
    /**
     * If supported by the browser, this will set the antialiasing flag on the
     * canvas. Set this to `false` if you want a 'jagged' pixel art look to your
     * image resources.
     * @param isSmooth  Set smoothing to true or false
     */
    setAntialiasing(isSmooth) {
      this.screen.antialiasing = isSmooth;
    }
    /**
     * Return the current smoothing status of the canvas
     */
    getAntialiasing() {
      return this.screen.antialiasing;
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
      return this._isInitialized;
    }
    _overrideInitialize(engine) {
      if (!this.isInitialized) {
        this.onInitialize(engine);
        this.events.emit("initialize", new InitializeEvent(engine, this));
        this._isInitialized = true;
        if (this._deferredGoTo) {
          const deferredScene = this._deferredGoTo;
          this._deferredGoTo = null;
          this.goToScene(deferredScene);
        } else {
          this.goToScene("root");
        }
      }
    }
    /**
     * Updates the entire state of the game
     * @param delta  Number of milliseconds elapsed since the last update.
     */
    _update(delta) {
      if (!this.ready) {
        this._loader.update(this, delta);
        this.input.keyboard.update();
        this.input.gamepads.update();
        this.inputMapper.execute();
        return;
      }
      this._preupdate(delta);
      this.currentScene.update(this, delta);
      this.graphicsContext.updatePostProcessors(delta);
      this._postupdate(delta);
      this.input.keyboard.update();
      this.input.gamepads.update();
      this.inputMapper.execute();
    }
    /**
     * @internal
     */
    _preupdate(delta) {
      this.emit("preupdate", new PreUpdateEvent(this, delta, this));
      this.onPreUpdate(this, delta);
    }
    onPreUpdate(_engine, _delta) {
    }
    /**
     * @internal
     */
    _postupdate(delta) {
      this.emit("postupdate", new PostUpdateEvent(this, delta, this));
      this.onPostUpdate(this, delta);
    }
    onPostUpdate(_engine, _delta) {
    }
    /**
     * Draws the entire game
     * @param delta  Number of milliseconds elapsed since the last draw.
     */
    _draw(delta) {
      this.graphicsContext.beginDrawLifecycle();
      this.graphicsContext.clear();
      this._predraw(this.graphicsContext, delta);
      if (!this._isReady) {
        this._loader.canvas.draw(this.graphicsContext, 0, 0);
        this.graphicsContext.flush();
        return;
      }
      this.graphicsContext.backgroundColor = this.backgroundColor;
      this.currentScene.draw(this.graphicsContext, delta);
      this._postdraw(this.graphicsContext, delta);
      this.graphicsContext.flush();
      this.graphicsContext.endDrawLifecycle();
      this._checkForScreenShots();
    }
    /**
     * @internal
     */
    _predraw(_ctx, delta) {
      this.emit("predraw", new PreDrawEvent(_ctx, delta, this));
      this.onPreDraw(_ctx, delta);
    }
    onPreDraw(_ctx, _delta) {
    }
    /**
     * @internal
     */
    _postdraw(_ctx, delta) {
      this.emit("postdraw", new PostDrawEvent(_ctx, delta, this));
      this.onPostDraw(_ctx, delta);
    }
    onPostDraw(_ctx, _delta) {
    }
    /**
     * Enable or disable Excalibur debugging functionality.
     * @param toggle a value that debug drawing will be changed to
     */
    showDebug(toggle) {
      this._isDebug = toggle;
    }
    /**
     * Toggle Excalibur debugging functionality.
     */
    toggleDebug() {
      this._isDebug = !this._isDebug;
      return this._isDebug;
    }
    /**
     * Returns true when loading is totally complete and the player has clicked start
     */
    get loadingComplete() {
      return this._loadingComplete;
    }
    get ready() {
      return this._isReady;
    }
    isReady() {
      return this._isReadyPromise;
    }
    /**
     * Starts the internal game loop for Excalibur after loading
     * any provided assets.
     * @param loader  Optional [[Loader]] to use to load resources. The default loader is [[Loader]], override to provide your own
     * custom loader.
     *
     * Note: start() only resolves AFTER the user has clicked the play button
     */
    async start(loader2) {
      if (!this._compatible) {
        throw new Error("Excalibur is incompatible with your browser");
      }
      if (loader2) {
        this.screen.pushResolutionAndViewport();
        this.screen.resolution = this.screen.viewport;
        this.screen.applyResolutionAndViewport();
        this._loader = loader2;
        this._loader.suppressPlayButton = this._suppressPlayButton || this._loader.suppressPlayButton;
        this._loader.wireEngine(this);
      }
      this._logger.debug("Starting game clock...");
      this.browser.resume();
      this.clock.start();
      this._logger.debug("Game clock started");
      if (loader2) {
        await this.load(this._loader);
        this._loadingComplete = true;
        this.screen.popResolutionAndViewport();
        this.screen.applyResolutionAndViewport();
      }
      this._loadingComplete = true;
      this._overrideInitialize(this);
      this._isReady = true;
      this._isReadyResolve();
      this.emit("start", new GameStartEvent(this));
      return this._isReadyPromise;
    }
    _mainloop(elapsed) {
      this.emit("preframe", new PreFrameEvent(this, this.stats.prevFrame));
      const delta = elapsed * this.timescale;
      this.currentFrameElapsedMs = delta;
      const frameId = this.stats.prevFrame.id + 1;
      this.stats.currFrame.reset();
      this.stats.currFrame.id = frameId;
      this.stats.currFrame.delta = delta;
      this.stats.currFrame.fps = this.clock.fpsSampler.fps;
      GraphicsDiagnostics.clear();
      const beforeUpdate = this.clock.now();
      const fixedTimestepMs = 1e3 / this.fixedUpdateFps;
      if (this.fixedUpdateFps) {
        this._lagMs += delta;
        while (this._lagMs >= fixedTimestepMs) {
          this._update(fixedTimestepMs);
          this._lagMs -= fixedTimestepMs;
        }
      } else {
        this._update(delta);
      }
      const afterUpdate = this.clock.now();
      this.currentFrameLagMs = this._lagMs;
      this._draw(delta);
      const afterDraw = this.clock.now();
      this.stats.currFrame.duration.update = afterUpdate - beforeUpdate;
      this.stats.currFrame.duration.draw = afterDraw - afterUpdate;
      this.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;
      this.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;
      this.emit("postframe", new PostFrameEvent(this, this.stats.currFrame));
      this.stats.prevFrame.reset(this.stats.currFrame);
      this._monitorPerformanceThresholdAndTriggerFallback();
    }
    /**
     * Stops Excalibur's main loop, useful for pausing the game.
     */
    stop() {
      if (this.clock.isRunning()) {
        this.emit("stop", new GameStopEvent(this));
        this.browser.pause();
        this.clock.stop();
        this._logger.debug("Game stopped");
      }
    }
    /**
     * Returns the Engine's running status, Useful for checking whether engine is running or paused.
     */
    isRunning() {
      return this.clock.isRunning();
    }
    /**
     * Takes a screen shot of the current viewport and returns it as an
     * HTML Image Element.
     * @param preserveHiDPIResolution in the case of HiDPI return the full scaled backing image, by default false
     */
    screenshot(preserveHiDPIResolution = false) {
      const screenShotPromise = new Promise((resolve) => {
        this._screenShotRequests.push({ preserveHiDPIResolution, resolve });
      });
      return screenShotPromise;
    }
    _checkForScreenShots() {
      for (const request of this._screenShotRequests) {
        const finalWidth = request.preserveHiDPIResolution ? this.canvas.width : this.screen.resolution.width;
        const finalHeight = request.preserveHiDPIResolution ? this.canvas.height : this.screen.resolution.height;
        const screenshot = document.createElement("canvas");
        screenshot.width = finalWidth;
        screenshot.height = finalHeight;
        const ctx = screenshot.getContext("2d");
        ctx.imageSmoothingEnabled = this.screen.antialiasing;
        ctx.drawImage(this.canvas, 0, 0, finalWidth, finalHeight);
        const result = new Image();
        const raw = screenshot.toDataURL("image/png");
        result.src = raw;
        request.resolve(result);
      }
      this._screenShotRequests.length = 0;
    }
    /**
     * Another option available to you to load resources into the game.
     * Immediately after calling this the game will pause and the loading screen
     * will appear.
     * @param loader  Some [[Loadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].
     */
    async load(loader2) {
      try {
        await loader2.load();
      } catch (e2) {
        this._logger.error("Error loading resources, things may not behave properly", e2);
        await Promise.resolve();
      }
    }
  }
  Engine._DEFAULT_ENGINE_OPTIONS = {
    width: 0,
    height: 0,
    enableCanvasTransparency: true,
    useDrawSorting: true,
    configurePerformanceCanvas2DFallback: {
      allow: true,
      showPlayerMessage: false,
      threshold: { fps: 20, numberOfFrames: 100 }
    },
    canvasElementId: "",
    canvasElement: void 0,
    snapToPixel: false,
    pointerScope: PointerScope.Canvas,
    suppressConsoleBootMessage: null,
    suppressMinimumBrowserFeatureDetection: null,
    suppressHiDPIScaling: null,
    suppressPlayButton: null,
    grabWindowFocus: true,
    scrollPreventionMode: ScrollPreventionMode.Canvas,
    backgroundColor: Color.fromHex("#2185d0")
    // Excalibur blue
  };
  class EventDispatcher {
    constructor() {
      this._handlers = {};
      this._wiredEventDispatchers = [];
      this._deferedHandlerRemovals = [];
    }
    /**
     * Clears any existing handlers or wired event dispatchers on this event dispatcher
     */
    clear() {
      this._handlers = {};
      this._wiredEventDispatchers = [];
    }
    _processDeferredHandlerRemovals() {
      for (const eventHandler of this._deferedHandlerRemovals) {
        this._removeHandler(eventHandler.name, eventHandler.handler);
      }
      this._deferedHandlerRemovals.length = 0;
    }
    /**
     * Emits an event for target
     * @param eventName  The name of the event to publish
     * @param event      Optionally pass an event data object to the handler
     */
    emit(eventName, event) {
      this._processDeferredHandlerRemovals();
      if (!eventName) {
        return;
      }
      eventName = eventName.toLowerCase();
      if (typeof event === "undefined" || event === null) {
        event = new GameEvent();
      }
      let i2, len;
      if (this._handlers[eventName]) {
        i2 = 0;
        len = this._handlers[eventName].length;
        for (i2; i2 < len; i2++) {
          this._handlers[eventName][i2](event);
        }
      }
      i2 = 0;
      len = this._wiredEventDispatchers.length;
      for (i2; i2 < len; i2++) {
        this._wiredEventDispatchers[i2].emit(eventName, event);
      }
    }
    /**
     * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.
     * @param eventName  The name of the event to subscribe to
     * @param handler    The handler callback to fire on this event
     */
    on(eventName, handler) {
      this._processDeferredHandlerRemovals();
      eventName = eventName.toLowerCase();
      if (!this._handlers[eventName]) {
        this._handlers[eventName] = [];
      }
      this._handlers[eventName].push(handler);
    }
    /**
     * Unsubscribe an event handler(s) from an event. If a specific handler
     * is specified for an event, only that handler will be unsubscribed.
     * Otherwise all handlers will be unsubscribed for that event.
     *
     * @param eventName  The name of the event to unsubscribe
     * @param handler    Optionally the specific handler to unsubscribe
     */
    off(eventName, handler) {
      this._deferedHandlerRemovals.push({ name: eventName, handler });
    }
    _removeHandler(eventName, handler) {
      eventName = eventName.toLowerCase();
      const eventHandlers = this._handlers[eventName];
      if (eventHandlers) {
        if (!handler) {
          this._handlers[eventName].length = 0;
        } else {
          const index = eventHandlers.indexOf(handler);
          if (index > -1) {
            this._handlers[eventName].splice(index, 1);
          }
        }
      }
    }
    /**
     * Once listens to an event one time, then unsubscribes from that event
     *
     * @param eventName The name of the event to subscribe to once
     * @param handler   The handler of the event that will be auto unsubscribed
     */
    once(eventName, handler) {
      this._processDeferredHandlerRemovals();
      const metaHandler = (event) => {
        const ev = event || new GameEvent();
        this.off(eventName, metaHandler);
        handler(ev);
      };
      this.on(eventName, metaHandler);
    }
    /**
     * Wires this event dispatcher to also receive events from another
     */
    wire(eventDispatcher) {
      eventDispatcher._wiredEventDispatchers.push(this);
    }
    /**
     * Unwires this event dispatcher from another
     */
    unwire(eventDispatcher) {
      const index = eventDispatcher._wiredEventDispatchers.indexOf(this);
      if (index > -1) {
        eventDispatcher._wiredEventDispatchers.splice(index, 1);
      }
    }
  }
  class Label extends Actor {
    get font() {
      return this._font;
    }
    set font(newFont) {
      this._font = newFont;
      this._text.font = newFont;
    }
    /**
     * The text to draw.
     */
    get text() {
      return this._text.text;
    }
    set text(text) {
      this._text.text = text;
    }
    get color() {
      return this._text.color;
    }
    set color(color2) {
      if (this._text) {
        this._text.color = color2;
      }
    }
    get opacity() {
      return this._text.opacity;
    }
    set opacity(opacity) {
      this._text.opacity = opacity;
    }
    /**
     * The [[SpriteFont]] to use, if any. Overrides [[Font|font]] if present.
     */
    get spriteFont() {
      return this._spriteFont;
    }
    set spriteFont(sf2) {
      if (sf2) {
        this._spriteFont = sf2;
        this._text.font = this._spriteFont;
      }
    }
    /**
     * Build a new label
     * @param options
     */
    constructor(options) {
      super(options);
      this._font = new Font();
      this._text = new Text({ text: "", font: this._font });
      const { text, pos, x: x2, y: y2, spriteFont, font, color: color2 } = options;
      this.pos = pos !== null && pos !== void 0 ? pos : x2 && y2 ? vec(x2, y2) : this.pos;
      this.text = text !== null && text !== void 0 ? text : this.text;
      this.font = font !== null && font !== void 0 ? font : this.font;
      this.spriteFont = spriteFont !== null && spriteFont !== void 0 ? spriteFont : this.spriteFont;
      this._text.color = color2 !== null && color2 !== void 0 ? color2 : this.color;
      const gfx = this.get(GraphicsComponent);
      gfx.anchor = Vector.Zero;
      gfx.use(this._text);
    }
    _initialize(engine) {
      super._initialize(engine);
    }
    /**
     * Returns the width of the text in the label (in pixels);
     */
    getTextWidth() {
      return this._text.width;
    }
  }
  class IsometricTile extends Entity {
    getGraphics() {
      return this._graphics;
    }
    /**
     * Tile graphics
     */
    addGraphic(graphic) {
      this._graphics.push(graphic);
      this._gfx.visible = true;
      this._gfx.localBounds = this._recalculateBounds();
    }
    _recalculateBounds() {
      let bounds = this._tileBounds.clone();
      for (const graphic of this._graphics) {
        const offset = vec(this.map.graphicsOffset.x - this.map.tileWidth / 2, this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : graphic.height - this.map.tileHeight));
        bounds = bounds.combine(graphic.localBounds.translate(offset));
      }
      return bounds;
    }
    removeGraphic(graphic) {
      const index = this._graphics.indexOf(graphic);
      if (index > -1) {
        this._graphics.splice(index, 1);
      }
      this._gfx.localBounds = this._recalculateBounds();
    }
    clearGraphics() {
      this._graphics.length = 0;
      this._gfx.visible = false;
      this._gfx.localBounds = this._recalculateBounds();
    }
    getColliders() {
      return this._colliders;
    }
    /**
     * Adds a collider to the IsometricTile
     *
     * **Note!** the [[Tile.solid]] must be set to true for it to act as a "fixed" collider
     * @param collider
     */
    addCollider(collider) {
      this._colliders.push(collider);
      this.map.flagCollidersDirty();
    }
    /**
     * Removes a collider from the IsometricTile
     * @param collider
     */
    removeCollider(collider) {
      const index = this._colliders.indexOf(collider);
      if (index > -1) {
        this._colliders.splice(index, 1);
      }
      this.map.flagCollidersDirty();
    }
    /**
     * Clears all colliders from the IsometricTile
     */
    clearColliders() {
      this._colliders.length = 0;
      this.map.flagCollidersDirty();
    }
    /**
     * Returns the top left corner of the [[IsometricTile]] in world space
     */
    get pos() {
      return this.map.tileToWorld(vec(this.x, this.y));
    }
    /**
     * Returns the center of the [[IsometricTile]]
     */
    get center() {
      return this.pos.add(vec(0, this.map.tileHeight / 2));
    }
    /**
     * Construct a new IsometricTile
     * @param x tile coordinate in x (not world position)
     * @param y tile coordinate in y (not world position)
     * @param graphicsOffset offset that tile should be shifted by (default (0, 0))
     * @param map reference to owning IsometricMap
     */
    constructor(x2, y2, graphicsOffset, map) {
      super([
        new TransformComponent(),
        new GraphicsComponent({
          offset: graphicsOffset !== null && graphicsOffset !== void 0 ? graphicsOffset : Vector.Zero,
          onPostDraw: (gfx, elapsed) => this.draw(gfx, elapsed)
        }),
        new IsometricEntityComponent(map)
      ]);
      this.solid = false;
      this._tileBounds = new BoundingBox();
      this._graphics = [];
      this._colliders = [];
      this.x = x2;
      this.y = y2;
      this.map = map;
      this._transform = this.get(TransformComponent);
      this._isometricEntityComponent = this.get(IsometricEntityComponent);
      const halfTileWidth = this.map.tileWidth / 2;
      const halfTileHeight = this.map.tileHeight / 2;
      const xPos = (this.x - this.y) * halfTileWidth;
      const yPos = (this.x + this.y) * halfTileHeight;
      this._transform.pos = vec(xPos, yPos);
      this._isometricEntityComponent.elevation = 0;
      this._gfx = this.get(GraphicsComponent);
      this._gfx.visible = false;
      const totalWidth = this.map.tileWidth;
      const totalHeight = this.map.tileHeight;
      const offset = vec(0, this.map.renderFromTopOfGraphic ? totalHeight : 0);
      this._gfx.localBounds = this._tileBounds = new BoundingBox({
        left: -totalWidth / 2,
        top: -totalHeight,
        right: totalWidth / 2,
        bottom: totalHeight
      }).translate(offset);
    }
    draw(gfx, _elapsed) {
      const halfTileWidth = this.map.tileWidth / 2;
      gfx.save();
      gfx.translate(-halfTileWidth, 0);
      for (const graphic of this._graphics) {
        graphic.draw(gfx, this.map.graphicsOffset.x, this.map.graphicsOffset.y - (this.map.renderFromTopOfGraphic ? 0 : graphic.height - this.map.tileHeight));
      }
      gfx.restore();
    }
  }
  class IsometricMap extends Entity {
    constructor(options) {
      super([
        new TransformComponent(),
        new BodyComponent({
          type: CollisionType.Fixed
        }),
        new ColliderComponent(),
        new DebugGraphicsComponent((ctx) => this.debug(ctx), false)
      ], options.name);
      this.renderFromTopOfGraphic = false;
      this.graphicsOffset = vec(0, 0);
      this._collidersDirty = false;
      this._originalOffsets = /* @__PURE__ */ new WeakMap();
      const { pos, tileWidth, tileHeight, columns: width, rows: height, renderFromTopOfGraphic, graphicsOffset } = options;
      this.transform = this.get(TransformComponent);
      if (pos) {
        this.transform.pos = pos;
      }
      this.collider = this.get(ColliderComponent);
      if (this.collider) {
        this.collider.set(this._composite = new CompositeCollider([]));
      }
      this.renderFromTopOfGraphic = renderFromTopOfGraphic !== null && renderFromTopOfGraphic !== void 0 ? renderFromTopOfGraphic : this.renderFromTopOfGraphic;
      this.graphicsOffset = graphicsOffset !== null && graphicsOffset !== void 0 ? graphicsOffset : this.graphicsOffset;
      this.tileWidth = tileWidth;
      this.tileHeight = tileHeight;
      this.columns = width;
      this.rows = height;
      this.tiles = new Array(width * height);
      for (let y2 = 0; y2 < height; y2++) {
        for (let x2 = 0; x2 < width; x2++) {
          const tile = new IsometricTile(x2, y2, this.graphicsOffset, this);
          this.tiles[x2 + y2 * width] = tile;
          this.addChild(tile);
        }
      }
    }
    update() {
      if (this._collidersDirty) {
        this.updateColliders();
        this._collidersDirty = false;
      }
    }
    flagCollidersDirty() {
      this._collidersDirty = true;
    }
    _getOrSetColliderOriginalOffset(collider) {
      if (!this._originalOffsets.has(collider)) {
        const originalOffset = collider.offset;
        this._originalOffsets.set(collider, originalOffset);
        return originalOffset;
      } else {
        return this._originalOffsets.get(collider);
      }
    }
    updateColliders() {
      this._composite.clearColliders();
      const pos = this.get(TransformComponent).pos;
      for (const tile of this.tiles) {
        if (tile.solid) {
          for (const collider of tile.getColliders()) {
            const originalOffset = this._getOrSetColliderOriginalOffset(collider);
            collider.offset = this.tileToWorld(vec(tile.x, tile.y)).sub(pos).add(originalOffset).sub(vec(this.tileWidth / 2, this.tileHeight));
            collider.owner = this;
            this._composite.addCollider(collider);
          }
        }
      }
      this.collider.update();
    }
    /**
     * Convert world space coordinates to the tile x, y coordinate
     * @param worldCoordinate
     */
    worldToTile(worldCoordinate) {
      worldCoordinate = worldCoordinate.sub(this.transform.globalPos);
      const halfTileWidth = this.tileWidth / 2;
      const halfTileHeight = this.tileHeight / 2;
      return vec(~~((worldCoordinate.x / halfTileWidth + worldCoordinate.y / halfTileHeight) / 2), ~~((worldCoordinate.y / halfTileHeight - worldCoordinate.x / halfTileWidth) / 2));
    }
    /**
     * Given a tile coordinate, return the top left corner in world space
     * @param tileCoordinate
     */
    tileToWorld(tileCoordinate) {
      const halfTileWidth = this.tileWidth / 2;
      const halfTileHeight = this.tileHeight / 2;
      const xPos = (tileCoordinate.x - tileCoordinate.y) * halfTileWidth;
      const yPos = (tileCoordinate.x + tileCoordinate.y) * halfTileHeight;
      return vec(xPos, yPos).add(this.transform.pos);
    }
    /**
     * Returns the [[IsometricTile]] by its x and y coordinates
     */
    getTile(x2, y2) {
      if (x2 < 0 || y2 < 0 || x2 >= this.columns || y2 >= this.rows) {
        return null;
      }
      return this.tiles[x2 + y2 * this.columns];
    }
    /**
     * Returns the [[IsometricTile]] by testing a point in world coordinates,
     * returns `null` if no Tile was found.
     */
    getTileByPoint(point2) {
      const tileCoord = this.worldToTile(point2);
      const tile = this.getTile(tileCoord.x, tileCoord.y);
      return tile;
    }
    _getMaxZIndex() {
      let maxZ = Number.NEGATIVE_INFINITY;
      for (const tile of this.tiles) {
        const currentZ = tile.get(TransformComponent).z;
        if (currentZ > maxZ) {
          maxZ = currentZ;
        }
      }
      return maxZ;
    }
    /**
     * Debug draw for IsometricMap, called internally by excalibur when debug mode is toggled on
     * @param gfx
     */
    debug(gfx) {
      gfx.save();
      gfx.z = this._getMaxZIndex() + 0.5;
      for (let y2 = 0; y2 < this.rows + 1; y2++) {
        const left = this.tileToWorld(vec(0, y2));
        const right = this.tileToWorld(vec(this.columns, y2));
        gfx.drawLine(left, right, Color.Red, 2);
      }
      for (let x2 = 0; x2 < this.columns + 1; x2++) {
        const top = this.tileToWorld(vec(x2, 0));
        const bottom = this.tileToWorld(vec(x2, this.rows));
        gfx.drawLine(top, bottom, Color.Red, 2);
      }
      for (const tile of this.tiles) {
        gfx.drawCircle(this.tileToWorld(vec(tile.x, tile.y)), 3, Color.Yellow);
      }
      gfx.restore();
    }
  }
  class ActionSequence {
    constructor(entity, actionBuilder) {
      this._stopped = false;
      this._sequenceBuilder = actionBuilder;
      this._sequenceContext = new ActionContext(entity);
      this._actionQueue = this._sequenceContext.getQueue();
      this._sequenceBuilder(this._sequenceContext);
    }
    update(delta) {
      this._actionQueue.update(delta);
    }
    isComplete() {
      return this._stopped || this._actionQueue.isComplete();
    }
    stop() {
      this._stopped = true;
    }
    reset() {
      this._stopped = false;
      this._actionQueue.reset();
    }
    clone(entity) {
      return new ActionSequence(entity, this._sequenceBuilder);
    }
  }
  class ParallelActions {
    constructor(parallelActions) {
      this._actions = parallelActions;
    }
    update(delta) {
      for (let i2 = 0; i2 < this._actions.length; i2++) {
        this._actions[i2].update(delta);
      }
    }
    isComplete(entity) {
      return this._actions.every((a2) => a2.isComplete(entity));
    }
    reset() {
      this._actions.forEach((a2) => a2.reset());
    }
    stop() {
      this._actions.forEach((a2) => a2.stop());
    }
  }
  class CollisionGroupManager {
    /**
     * Create a new named collision group up to a max of 32.
     * @param name Name for the collision group
     * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one
     */
    static create(name, mask) {
      if (this._CURRENT_GROUP > this._MAX_GROUPS) {
        throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);
      }
      if (this._GROUPS.get(name)) {
        throw new Error(`Collision group ${name} already exists`);
      }
      const group = new CollisionGroup(name, this._CURRENT_BIT, mask !== void 0 ? mask : ~this._CURRENT_BIT);
      this._CURRENT_BIT = this._CURRENT_BIT << 1 | 0;
      this._CURRENT_GROUP++;
      this._GROUPS.set(name, group);
      return group;
    }
    /**
     * Get all collision groups currently tracked by excalibur
     */
    static get groups() {
      return Array.from(this._GROUPS.values());
    }
    /**
     * Get a collision group by it's name
     * @param name
     */
    static groupByName(name) {
      return this._GROUPS.get(name);
    }
    /**
     * Resets the managers internal group management state
     */
    static reset() {
      this._GROUPS = /* @__PURE__ */ new Map();
      this._CURRENT_BIT = this._STARTING_BIT;
      this._CURRENT_GROUP = 1;
    }
  }
  CollisionGroupManager._STARTING_BIT = 1 | 0;
  CollisionGroupManager._MAX_GROUPS = 32;
  CollisionGroupManager._CURRENT_GROUP = 1;
  CollisionGroupManager._CURRENT_BIT = CollisionGroupManager._STARTING_BIT;
  CollisionGroupManager._GROUPS = /* @__PURE__ */ new Map();
  function has_initialize(a2) {
    return !!a2._initialize;
  }
  function hasOnInitialize(a2) {
    return !!a2.onInitialize;
  }
  function has_preupdate(a2) {
    return !!a2._preupdate;
  }
  function hasOnPreUpdate(a2) {
    return !!a2.onPreUpdate;
  }
  function has_postupdate(a2) {
    return !!a2.onPostUpdate;
  }
  function hasOnPostUpdate(a2) {
    return !!a2.onPostUpdate;
  }
  function hasPreDraw(a2) {
    return !!a2.onPreDraw;
  }
  function hasPostDraw(a2) {
    return !!a2.onPostDraw;
  }
  class Gif {
    /**
     * @param path       Path to the image resource
     * @param color      Optionally set the color to treat as transparent the gif, by default [[Color.Magenta]]
     * @param bustCache  Optionally load texture with cache busting
     */
    constructor(path, color2 = Color.Magenta, bustCache = false) {
      this.path = path;
      this.color = color2;
      this._stream = null;
      this._gif = null;
      this._textures = [];
      this._animation = null;
      this._transparentColor = null;
      this._resource = new Resource(path, "arraybuffer", bustCache);
      this._transparentColor = color2;
    }
    /**
     * Should excalibur add a cache busting querystring? By default false.
     * Must be set before loading
     */
    get bustCache() {
      return this._resource.bustCache;
    }
    set bustCache(val) {
      this._resource.bustCache = val;
    }
    /**
     * Begins loading the texture and returns a promise to be resolved on completion
     */
    async load() {
      const arraybuffer = await this._resource.load();
      this._stream = new Stream(arraybuffer);
      this._gif = new ParseGif(this._stream, this._transparentColor);
      const images = this._gif.images.map((i2) => new ImageSource(i2.src, false));
      await Promise.all(images.map((t2) => t2.load()));
      return this.data = this._textures = images;
    }
    isLoaded() {
      return !!this.data;
    }
    /**
     * Return a frame of the gif as a sprite by id
     * @param id
     */
    toSprite(id2 = 0) {
      const sprite = this._textures[id2].toSprite();
      return sprite;
    }
    /**
     * Return the gif as a spritesheet
     */
    toSpriteSheet() {
      const sprites = this._textures.map((image) => {
        return image.toSprite();
      });
      return new SpriteSheet({ sprites });
    }
    /**
     * Transform the GIF into an animation with duration per frame
     */
    toAnimation(durationPerFrameMs) {
      const spriteSheet = this.toSpriteSheet();
      const length = spriteSheet.sprites.length;
      this._animation = Animation.fromSpriteSheet(spriteSheet, range(0, length), durationPerFrameMs);
      return this._animation;
    }
    get readCheckBytes() {
      return this._gif.checkBytes;
    }
  }
  const bitsToNum = (ba) => {
    return ba.reduce(function(s2, n2) {
      return s2 * 2 + n2;
    }, 0);
  };
  const byteToBitArr = (bite) => {
    const a2 = [];
    for (let i2 = 7; i2 >= 0; i2--) {
      a2.push(!!(bite & 1 << i2));
    }
    return a2;
  };
  class Stream {
    constructor(dataArray) {
      this.data = null;
      this.len = 0;
      this.position = 0;
      this.readByte = () => {
        if (this.position >= this.data.byteLength) {
          throw new Error("Attempted to read past end of stream.");
        }
        return this.data[this.position++];
      };
      this.readBytes = (n2) => {
        const bytes = [];
        for (let i2 = 0; i2 < n2; i2++) {
          bytes.push(this.readByte());
        }
        return bytes;
      };
      this.read = (n2) => {
        let s2 = "";
        for (let i2 = 0; i2 < n2; i2++) {
          s2 += String.fromCharCode(this.readByte());
        }
        return s2;
      };
      this.readUnsigned = () => {
        const a2 = this.readBytes(2);
        return (a2[1] << 8) + a2[0];
      };
      this.data = new Uint8Array(dataArray);
      this.len = this.data.byteLength;
      if (this.len === 0) {
        throw new Error("No data loaded from file");
      }
    }
  }
  const lzwDecode = function(minCodeSize, data) {
    let pos = 0;
    const readCode = function(size) {
      let code2 = 0;
      for (let i2 = 0; i2 < size; i2++) {
        if (data.charCodeAt(pos >> 3) & 1 << (pos & 7)) {
          code2 |= 1 << i2;
        }
        pos++;
      }
      return code2;
    };
    const output = [];
    const clearCode = 1 << minCodeSize;
    const eoiCode = clearCode + 1;
    let codeSize = minCodeSize + 1;
    let dict = [];
    const clear = function() {
      dict = [];
      codeSize = minCodeSize + 1;
      for (let i2 = 0; i2 < clearCode; i2++) {
        dict[i2] = [i2];
      }
      dict[clearCode] = [];
      dict[eoiCode] = null;
    };
    let code;
    let last;
    while (true) {
      last = code;
      code = readCode(codeSize);
      if (code === clearCode) {
        clear();
        continue;
      }
      if (code === eoiCode) {
        break;
      }
      if (code < dict.length) {
        if (last !== clearCode) {
          dict.push(dict[last].concat(dict[code][0]));
        }
      } else {
        if (code !== dict.length) {
          throw new Error("Invalid LZW code.");
        }
        dict.push(dict[last].concat(dict[last][0]));
      }
      output.push.apply(output, dict[code]);
      if (dict.length === 1 << codeSize && codeSize < 12) {
        codeSize++;
      }
    }
    return output;
  };
  class ParseGif {
    constructor(stream, color2 = Color.Magenta) {
      this._st = null;
      this._handler = {};
      this._transparentColor = null;
      this.frames = [];
      this.images = [];
      this.globalColorTable = [];
      this.checkBytes = [];
      this.parseColorTable = (entries) => {
        const ct = [];
        for (let i2 = 0; i2 < entries; i2++) {
          const rgb = this._st.readBytes(3);
          const rgba2 = "#" + rgb.map((x2) => {
            const hex2 = x2.toString(16);
            return hex2.length === 1 ? "0" + hex2 : hex2;
          }).join("");
          ct.push(rgba2);
        }
        return ct;
      };
      this.readSubBlocks = () => {
        let size, data;
        data = "";
        do {
          size = this._st.readByte();
          data += this._st.read(size);
        } while (size !== 0);
        return data;
      };
      this.parseHeader = () => {
        const hdr = {
          sig: null,
          ver: null,
          width: null,
          height: null,
          colorRes: null,
          globalColorTableSize: null,
          gctFlag: null,
          sorted: null,
          globalColorTable: [],
          bgColor: null,
          pixelAspectRatio: null
          // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
        };
        hdr.sig = this._st.read(3);
        hdr.ver = this._st.read(3);
        if (hdr.sig !== "GIF") {
          throw new Error("Not a GIF file.");
        }
        hdr.width = this._st.readUnsigned();
        hdr.height = this._st.readUnsigned();
        const bits = byteToBitArr(this._st.readByte());
        hdr.gctFlag = bits.shift();
        hdr.colorRes = bitsToNum(bits.splice(0, 3));
        hdr.sorted = bits.shift();
        hdr.globalColorTableSize = bitsToNum(bits.splice(0, 3));
        hdr.bgColor = this._st.readByte();
        hdr.pixelAspectRatio = this._st.readByte();
        if (hdr.gctFlag) {
          hdr.globalColorTable = this.parseColorTable(1 << hdr.globalColorTableSize + 1);
          this.globalColorTable = hdr.globalColorTable;
        }
        if (this._handler.hdr && this._handler.hdr(hdr)) {
          this.checkBytes.push(this._handler.hdr);
        }
      };
      this.parseExt = (block) => {
        const parseGCExt = (block2) => {
          this.checkBytes.push(this._st.readByte());
          const bits = byteToBitArr(this._st.readByte());
          block2.reserved = bits.splice(0, 3);
          block2.disposalMethod = bitsToNum(bits.splice(0, 3));
          block2.userInput = bits.shift();
          block2.transparencyGiven = bits.shift();
          block2.delayTime = this._st.readUnsigned();
          block2.transparencyIndex = this._st.readByte();
          block2.terminator = this._st.readByte();
          if (this._handler.gce && this._handler.gce(block2)) {
            this.checkBytes.push(this._handler.gce);
          }
        };
        const parseComExt = (block2) => {
          block2.comment = this.readSubBlocks();
          if (this._handler.com && this._handler.com(block2)) {
            this.checkBytes.push(this._handler.com);
          }
        };
        const parsePTExt = (block2) => {
          this.checkBytes.push(this._st.readByte());
          block2.ptHeader = this._st.readBytes(12);
          block2.ptData = this.readSubBlocks();
          if (this._handler.pte && this._handler.pte(block2)) {
            this.checkBytes.push(this._handler.pte);
          }
        };
        const parseAppExt = (block2) => {
          const parseNetscapeExt = (block3) => {
            this.checkBytes.push(this._st.readByte());
            block3.unknown = this._st.readByte();
            block3.iterations = this._st.readUnsigned();
            block3.terminator = this._st.readByte();
            if (this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(block3)) {
              this.checkBytes.push(this._handler.app);
            }
          };
          const parseUnknownAppExt = (block3) => {
            block3.appData = this.readSubBlocks();
            if (this._handler.app && this._handler.app[block3.identifier] && this._handler.app[block3.identifier](block3)) {
              this.checkBytes.push(this._handler.app[block3.identifier]);
            }
          };
          this.checkBytes.push(this._st.readByte());
          block2.identifier = this._st.read(8);
          block2.authCode = this._st.read(3);
          switch (block2.identifier) {
            case "NETSCAPE":
              parseNetscapeExt(block2);
              break;
            default:
              parseUnknownAppExt(block2);
              break;
          }
        };
        const parseUnknownExt = (block2) => {
          block2.data = this.readSubBlocks();
          if (this._handler.unknown && this._handler.unknown(block2)) {
            this.checkBytes.push(this._handler.unknown);
          }
        };
        block.label = this._st.readByte();
        switch (block.label) {
          case 249:
            block.extType = "gce";
            parseGCExt(block);
            break;
          case 254:
            block.extType = "com";
            parseComExt(block);
            break;
          case 1:
            block.extType = "pte";
            parsePTExt(block);
            break;
          case 255:
            block.extType = "app";
            parseAppExt(block);
            break;
          default:
            block.extType = "unknown";
            parseUnknownExt(block);
            break;
        }
      };
      this.parseImg = (img) => {
        const deinterlace = (pixels, width) => {
          const newPixels = new Array(pixels.length);
          const rows = pixels.length / width;
          const cpRow = (toRow, fromRow2) => {
            const fromPixels = pixels.slice(fromRow2 * width, (fromRow2 + 1) * width);
            newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
          };
          const offsets = [0, 4, 2, 1];
          const steps2 = [8, 8, 4, 2];
          let fromRow = 0;
          for (let pass = 0; pass < 4; pass++) {
            for (let toRow = offsets[pass]; toRow < rows; toRow += steps2[pass]) {
              cpRow(toRow, fromRow);
              fromRow++;
            }
          }
          return newPixels;
        };
        img.leftPos = this._st.readUnsigned();
        img.topPos = this._st.readUnsigned();
        img.width = this._st.readUnsigned();
        img.height = this._st.readUnsigned();
        const bits = byteToBitArr(this._st.readByte());
        img.lctFlag = bits.shift();
        img.interlaced = bits.shift();
        img.sorted = bits.shift();
        img.reserved = bits.splice(0, 2);
        img.lctSize = bitsToNum(bits.splice(0, 3));
        if (img.lctFlag) {
          img.lct = this.parseColorTable(1 << img.lctSize + 1);
        }
        img.lzwMinCodeSize = this._st.readByte();
        const lzwData = this.readSubBlocks();
        img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);
        if (img.interlaced) {
          img.pixels = deinterlace(img.pixels, img.width);
        }
        this.frames.push(img);
        this.arrayToImage(img);
        if (this._handler.img && this._handler.img(img)) {
          this.checkBytes.push(this._handler);
        }
      };
      this.parseBlock = () => {
        const block = {
          sentinel: this._st.readByte(),
          type: ""
        };
        const blockChar = String.fromCharCode(block.sentinel);
        switch (blockChar) {
          case "!":
            block.type = "ext";
            this.parseExt(block);
            break;
          case ",":
            block.type = "img";
            this.parseImg(block);
            break;
          case ";":
            block.type = "eof";
            if (this._handler.eof && this._handler.eof(block)) {
              this.checkBytes.push(this._handler.eof);
            }
            break;
          default:
            throw new Error("Unknown block: 0x" + block.sentinel.toString(16));
        }
        if (block.type !== "eof") {
          this.parseBlock();
        }
      };
      this.arrayToImage = (frame2) => {
        let count = 0;
        const c2 = document.createElement("canvas");
        c2.id = count.toString();
        c2.width = frame2.width;
        c2.height = frame2.height;
        count++;
        const context = c2.getContext("2d");
        const pixSize = 1;
        let y2 = 0;
        let x2 = 0;
        for (let i2 = 0; i2 < frame2.pixels.length; i2++) {
          if (x2 % frame2.width === 0) {
            y2++;
            x2 = 0;
          }
          if (this.globalColorTable[frame2.pixels[i2]] === this._transparentColor.toHex()) {
            context.fillStyle = `rgba(0, 0, 0, 0)`;
          } else {
            context.fillStyle = this.globalColorTable[frame2.pixels[i2]];
          }
          context.fillRect(x2, y2, pixSize, pixSize);
          x2++;
        }
        const img = new Image();
        img.src = c2.toDataURL();
        this.images.push(img);
      };
      this._st = stream;
      this._handler = {};
      this._transparentColor = color2;
      this.parseHeader();
      this.parseBlock();
    }
  }
  class Line extends Graphic {
    constructor(options) {
      super();
      this.color = Color.Black;
      this.thickness = 1;
      const { start, end, color: color2, thickness } = options;
      this.start = start;
      this.end = end;
      this.color = color2 !== null && color2 !== void 0 ? color2 : this.color;
      this.thickness = thickness !== null && thickness !== void 0 ? thickness : this.thickness;
      const { width, height } = BoundingBox.fromPoints([start, end]);
      this.width = width;
      this.height = height;
    }
    _drawImage(ctx, _x, _y) {
      ctx.drawLine(this.start, this.end, this.color, this.thickness);
    }
    clone() {
      return new Line({
        start: this.start,
        end: this.end,
        color: this.color,
        thickness: this.thickness
      });
    }
  }
  class Polygon extends Raster {
    get points() {
      return this._points;
    }
    set points(points) {
      this._points = points;
      const min = this.minPoint;
      this.width = this._points.reduce((max, p2) => Math.max(p2.x, max), 0) - min.x;
      this.height = this._points.reduce((max, p2) => Math.max(p2.y, max), 0) - min.y;
      this.flagDirty();
    }
    get minPoint() {
      const minX = this._points.reduce((min, p2) => Math.min(p2.x, min), Infinity);
      const minY = this._points.reduce((min, p2) => Math.min(p2.y, min), Infinity);
      return vec(minX, minY);
    }
    constructor(options) {
      super(options);
      this.points = options.points;
      this.filtering = ImageFiltering.Blended;
      this.rasterize();
    }
    clone() {
      return new Polygon({
        points: this.points.map((p2) => p2.clone()),
        ...this.cloneGraphicOptions(),
        ...this.cloneRasterOptions()
      });
    }
    execute(ctx) {
      if (this.points && this.points.length) {
        ctx.beginPath();
        const min = this.minPoint.negate();
        const firstPoint = this.points[0].add(min);
        ctx.moveTo(firstPoint.x, firstPoint.y);
        this.points.forEach((point2) => {
          ctx.lineTo(point2.x + min.x, point2.y + min.y);
        });
        ctx.lineTo(firstPoint.x, firstPoint.y);
        ctx.closePath();
        if (this.color) {
          ctx.fill();
        }
        if (this.strokeColor) {
          ctx.stroke();
        }
      }
    }
  }
  class AsyncWaitQueue {
    constructor() {
      this._queue = [];
    }
    get length() {
      return this._queue.length;
    }
    enqueue() {
      const future = new Future();
      this._queue.push(future);
      return future.promise;
    }
    dequeue(value) {
      const future = this._queue.shift();
      future.resolve(value);
    }
  }
  class Semaphore {
    constructor(_count) {
      this._count = _count;
      this._waitQueue = new AsyncWaitQueue();
    }
    get count() {
      return this._count;
    }
    get waiting() {
      return this._waitQueue.length;
    }
    async enter() {
      if (this._count !== 0) {
        this._count--;
        return Promise.resolve();
      }
      return this._waitQueue.enqueue();
    }
    exit(count = 1) {
      if (count === 0) {
        return;
      }
      while (count !== 0 && this._waitQueue.length !== 0) {
        this._waitQueue.dequeue(null);
        count--;
      }
      this._count += count;
    }
  }
  const EX_VERSION = "0.28.0";
  polyfill2();
})();
__webpack_exports__.fWn;
__webpack_exports__.Ia8;
__webpack_exports__.rqv;
__webpack_exports__.hLI;
__webpack_exports__.yyv;
__webpack_exports__.tX5;
var __webpack_exports__Actor = __webpack_exports__.vtX;
__webpack_exports__.r7K;
__webpack_exports__.lCh;
__webpack_exports__.cE4;
var __webpack_exports__Animation = __webpack_exports__.fwF;
__webpack_exports__.sce;
__webpack_exports__.AQ6;
__webpack_exports__._c7;
__webpack_exports__.KUs;
__webpack_exports__.Ajp;
__webpack_exports__.dkO;
var __webpack_exports__Axis = __webpack_exports__.RDh;
__webpack_exports__._H9;
__webpack_exports__.mxs;
__webpack_exports__.OmD;
var __webpack_exports__BoundingBox = __webpack_exports__.kBf;
__webpack_exports__.C4F;
__webpack_exports__.NQt;
__webpack_exports__.JjN;
__webpack_exports__.EK_;
__webpack_exports__.V1s;
__webpack_exports__.xHm;
__webpack_exports__.Xz7;
__webpack_exports__.Cdc;
__webpack_exports__.FKn;
__webpack_exports__.SUY;
__webpack_exports__.ab2;
__webpack_exports__.GfZ;
__webpack_exports__.YMS;
__webpack_exports__.oyv;
__webpack_exports__.aUb;
__webpack_exports__.SdD;
__webpack_exports__.JUv;
__webpack_exports__.jEj;
__webpack_exports__.TFq;
__webpack_exports__.HDU;
__webpack_exports__.R_y;
__webpack_exports__.ydN;
__webpack_exports__.t50;
__webpack_exports__.s$$;
var __webpack_exports__CollisionType = __webpack_exports__.v2G;
var __webpack_exports__Color = __webpack_exports__.Ilk;
__webpack_exports__.s9i;
__webpack_exports__.dxL;
__webpack_exports__.LLX;
__webpack_exports__.wA2;
__webpack_exports__.R_p;
__webpack_exports__.IQ$;
__webpack_exports__.I5F;
__webpack_exports__.X8$;
__webpack_exports__.FR6;
__webpack_exports__.U8o;
__webpack_exports__.kbG;
__webpack_exports__.iS_;
__webpack_exports__.cGG;
__webpack_exports__.RPN;
__webpack_exports__.skb;
__webpack_exports__.SLU;
__webpack_exports__.RdJ;
__webpack_exports__.cNu;
__webpack_exports__.gU7;
__webpack_exports__.LSk;
__webpack_exports__.Nmp;
var __webpack_exports__DisplayMode = __webpack_exports__.d1Y;
__webpack_exports__.xrL;
__webpack_exports__.sRW;
__webpack_exports__.cmV;
__webpack_exports__.qWz;
__webpack_exports__.N0Q;
var __webpack_exports__EasingFunctions = __webpack_exports__.q8b;
__webpack_exports__.ynB;
__webpack_exports__.jT9;
__webpack_exports__.wAz;
var __webpack_exports__Engine = __webpack_exports__.D4V;
__webpack_exports__.NLr;
__webpack_exports__.N6H;
__webpack_exports__.W1A;
__webpack_exports__.JHW;
__webpack_exports__.ZZ$;
__webpack_exports__.v2K;
__webpack_exports__.pBf;
__webpack_exports__.vpe;
__webpack_exports__.GMl;
__webpack_exports__.zW2;
__webpack_exports__.B0K;
__webpack_exports__.Nv7;
__webpack_exports__.C_p;
__webpack_exports__.MUA;
__webpack_exports__.xqU;
__webpack_exports__.pTp;
__webpack_exports__.vUK;
__webpack_exports__.j9l;
__webpack_exports__.Zxw;
__webpack_exports__.v51;
__webpack_exports__.Hdx;
__webpack_exports__.Z$d;
__webpack_exports__.iqV;
__webpack_exports__.o$7;
__webpack_exports__.olM;
__webpack_exports__.Zm$;
__webpack_exports__.$QH;
__webpack_exports__.i78;
__webpack_exports__.nJg;
__webpack_exports__.h6u;
__webpack_exports__.hts;
__webpack_exports__.j88;
__webpack_exports__.VME;
__webpack_exports__.fy2;
__webpack_exports__.nt;
__webpack_exports__.Ukr;
__webpack_exports__.zsu;
__webpack_exports__.oA6;
__webpack_exports__.TVh;
__webpack_exports__.TwZ;
__webpack_exports__.GTT;
__webpack_exports__.xxj;
__webpack_exports__.XdK;
__webpack_exports__.Jmb;
var __webpack_exports__ImageSource = __webpack_exports__.cXo;
__webpack_exports__.Dm5;
__webpack_exports__.IIB;
__webpack_exports__.ebW;
__webpack_exports__.zI0;
__webpack_exports__.LYD;
__webpack_exports__.cEG;
__webpack_exports__.SEl;
__webpack_exports__.t9V;
__webpack_exports__.ez5;
__webpack_exports__.N1d;
var __webpack_exports__Keys = __webpack_exports__.R8U;
__webpack_exports__.SKZ;
__webpack_exports__.__J;
__webpack_exports__.RI$;
__webpack_exports__.x12;
__webpack_exports__.ccz;
var __webpack_exports__Loader = __webpack_exports__.aNw;
__webpack_exports__.XrL;
__webpack_exports__.xwn;
__webpack_exports__.dNK;
__webpack_exports__.ini;
__webpack_exports__.YdH;
__webpack_exports__.F5T;
__webpack_exports__.y3G;
__webpack_exports__.l57;
__webpack_exports__.xn0;
__webpack_exports__.t2V;
__webpack_exports__.uxB;
__webpack_exports__.cpd;
__webpack_exports__.fiy;
__webpack_exports__.$XZ;
__webpack_exports__.UG6;
__webpack_exports__.uqK;
__webpack_exports__.STE;
__webpack_exports__.y$z;
__webpack_exports__.mAD;
__webpack_exports__.sOq;
__webpack_exports__.hUw;
__webpack_exports__._0G;
__webpack_exports__.Sqs;
__webpack_exports__.hpZ;
__webpack_exports__.Vol;
__webpack_exports__.vYX;
var __webpack_exports__Physics = __webpack_exports__.wIZ;
__webpack_exports__.cBi;
__webpack_exports__.c30;
__webpack_exports__.MPV;
__webpack_exports__.RFv;
__webpack_exports__.Ux6;
__webpack_exports__.rxy;
__webpack_exports__.I$c;
__webpack_exports__.kfC;
__webpack_exports__.VjY;
__webpack_exports__.mgq;
__webpack_exports__.YVA;
__webpack_exports__.Kgp;
__webpack_exports__.HH$;
__webpack_exports__.M_d;
__webpack_exports__.rgh;
__webpack_exports__.Ra6;
__webpack_exports__.KhR;
__webpack_exports__.BS5;
__webpack_exports__.xhz;
__webpack_exports__.xOq;
__webpack_exports__.a9j;
__webpack_exports__.bHk;
__webpack_exports__.CgK;
__webpack_exports__.cuY;
__webpack_exports__.kvE;
__webpack_exports__.SBu;
__webpack_exports__.AE_;
__webpack_exports__.ctO;
__webpack_exports__.OLH;
__webpack_exports__.kky;
__webpack_exports__.nSF;
__webpack_exports__.zHn;
__webpack_exports__.zwx;
__webpack_exports__.AeJ;
__webpack_exports__.hLz;
__webpack_exports__.D9g;
__webpack_exports__.wA;
__webpack_exports__.jhr;
__webpack_exports__.GVs;
__webpack_exports__._zO;
__webpack_exports__.LXZ;
__webpack_exports__.w6$;
__webpack_exports__.mhV;
__webpack_exports__.MOD;
__webpack_exports__.kwd;
__webpack_exports__.Lmr;
__webpack_exports__.xsS;
__webpack_exports__.K5l;
__webpack_exports__.lLr;
__webpack_exports__.Z$r;
__webpack_exports__.IXb;
__webpack_exports__.SGH;
__webpack_exports__.SMj;
__webpack_exports__.L34;
__webpack_exports__.exe;
var __webpack_exports__Shape = __webpack_exports__.bnF;
var __webpack_exports__Side = __webpack_exports__.MFA;
__webpack_exports__.$uU;
__webpack_exports__.Sap;
var __webpack_exports__Sprite = __webpack_exports__.jyi;
__webpack_exports__.E03;
__webpack_exports__.V6q;
__webpack_exports__.rg2;
__webpack_exports__.DVW;
__webpack_exports__.nVo;
__webpack_exports__.F6N;
__webpack_exports__.xP7;
__webpack_exports__.Odq;
__webpack_exports__.Zif;
__webpack_exports__.ZGJ;
__webpack_exports__.MJk;
__webpack_exports__.xvT;
__webpack_exports__.PHM;
__webpack_exports__.dpR;
__webpack_exports__.n9L;
__webpack_exports__.KwO;
__webpack_exports__.SxM;
__webpack_exports__.B7y;
__webpack_exports__.x7r;
__webpack_exports__.wx7;
__webpack_exports__.Uvn;
__webpack_exports__.OFT;
__webpack_exports__.xzN;
__webpack_exports__.CcZ;
__webpack_exports__.M5Z;
__webpack_exports__.ZrN;
var __webpack_exports__Vector = __webpack_exports__.OWs;
__webpack_exports__.dF9;
__webpack_exports__.oZy;
__webpack_exports__.rD2;
__webpack_exports__.VHo;
__webpack_exports__.ohE;
__webpack_exports__.R$E;
__webpack_exports__.xQN;
__webpack_exports__.AdJ;
__webpack_exports__.q3I;
__webpack_exports__.Pab;
__webpack_exports__.uZ5;
__webpack_exports__.McK;
__webpack_exports__.F9c;
__webpack_exports__.k0b;
__webpack_exports__.hnT;
__webpack_exports__.RSJ;
__webpack_exports__.Mku;
__webpack_exports__.h90;
__webpack_exports__.rms;
__webpack_exports__.ErP;
__webpack_exports__.aVg;
__webpack_exports__.lPc;
__webpack_exports__.Z8E;
__webpack_exports__._N2;
__webpack_exports__.yFn;
__webpack_exports__.lNv;
__webpack_exports__.cu9;
__webpack_exports__.MZQ;
__webpack_exports__.FUM;
__webpack_exports__.BxR;
__webpack_exports__.vdf;
__webpack_exports__.iaL;
__webpack_exports__.w6H;
__webpack_exports__.Q4c;
__webpack_exports__.Xxe;
__webpack_exports__.Uxb;
__webpack_exports__.Yr5;
var __webpack_exports__vec = __webpack_exports__.Bhw;
__webpack_exports__.yOA;
const neneIdle = "/2023/nene/assets/nene_idle-e442b347.png";
const neneJump = "/2023/nene/assets/nene_jump-adeb89e1.png";
const neneRun1 = "/2023/nene/assets/nene_running_1-941ed1a3.png";
const neneRun2 = "/2023/nene/assets/nene_running_2-3639975d.png";
const resources = {
  neneIdle: new __webpack_exports__ImageSource(neneIdle),
  neneRun1: new __webpack_exports__ImageSource(neneRun1),
  neneRun2: new __webpack_exports__ImageSource(neneRun2),
  neneJump: new __webpack_exports__ImageSource(neneJump)
};
const neneSprite = {
  idleLeft: resources.neneIdle.toSprite(),
  idleRight: new __webpack_exports__Sprite({ image: resources.neneIdle, flipHorizontal: true }),
  runLeft: new __webpack_exports__Animation({
    frames: [
      { graphic: resources.neneRun1.toSprite(), duration: 150 },
      { graphic: resources.neneRun2.toSprite(), duration: 150 }
    ]
  }),
  runRight: new __webpack_exports__Animation({
    frames: [
      { graphic: resources.neneRun1.toSprite(), duration: 200 },
      { graphic: resources.neneRun2.toSprite(), duration: 200 }
    ],
    flipHorizontal: true
  }),
  jumpLeft: resources.neneJump.toSprite(),
  jumpRight: new __webpack_exports__Sprite({ image: resources.neneJump, flipHorizontal: true })
};
for (const res of Object.values(neneSprite)) {
  res.scale = new __webpack_exports__Vector(0.3, 0.3);
}
const loader = new __webpack_exports__Loader();
loader.backgroundColor = "transparent";
loader.suppressPlayButton = true;
for (const res of Object.values(resources)) {
  loader.addResource(res);
}
const $game = atom(null);
const $nene = atom(null);
const $floor = atom(null);
const $parallaxX = atom(0);
const $section = atom([]);
const $activeSection = atom(
  "intro"
);
const $gameInit = atom(() => {
});
function updateCollisionActors() {
  const sections = ["intro", "messages", "art", "cake"];
  $section.set(
    sections.map((section) => {
      const el2 = document.getElementById(section);
      return {
        section,
        left: el2.offsetLeft
      };
    })
  );
}
const randomInt = (min, max) => {
  return Math.floor(Math.random() * (max - min + 1) + min);
};
const randomChoice = (arr) => {
  return arr[randomInt(0, arr.length - 1)];
};
function Preloader() {
  const [counter, setCounter] = reactExports.useState(0);
  const [totalImages, setTotalImages] = reactExports.useState(999);
  const game = useStore($game);
  const isLoaded = counter >= totalImages;
  const incrementCounter = () => setCounter((prev) => prev + 1);
  reactExports.useEffect(() => {
    const cancel = setTimeout(() => {
      const images = document.querySelectorAll("img");
      setTotalImages(images.length);
      images.forEach((img) => {
        img.onload = incrementCounter;
        if (img.complete) {
          incrementCounter();
        }
      });
    }, 1e3);
    return () => {
      clearTimeout(cancel);
      const images = document.querySelectorAll("img");
      images.forEach((img) => {
        img.removeEventListener("load", incrementCounter);
      });
    };
  }, []);
  reactExports.useEffect(() => {
    if (isLoaded && game) {
      game == null ? void 0 : game.start(loader);
      updateCollisionActors();
    }
  }, [counter, game, isLoaded, totalImages]);
  if (isLoaded)
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fixed inset-0 z-50 bg-other flex flex-col justify-center items-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "/logo.png", alt: "", className: "w-full max-w-[40%] mb-20" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "text-5xl text-white", children: [
      counter,
      "/",
      totalImages,
      " resources loaded"
    ] })
  ] });
}
const Index = reactExports.lazy(() => __vitePreload(() => import("./index-ac3a3f55.js"), true ? ["assets/index-ac3a3f55.js","assets/index-67352cb9.css"] : void 0));
function App() {
  const { i18n } = useTranslation();
  const location = useLocation();
  reactExports.useEffect(() => {
    const lang = localStorage.getItem("opt_lang");
    if (lang) {
      i18n.changeLanguage(lang.toLowerCase());
    }
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Routes, { location, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(WrapRoute, { Element: Index }) }) }, location.pathname) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Preloader, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Ie, {})
  ] });
}
function WrapRoute({
  Element: Element2
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    motion.div,
    {
      initial: {
        opacity: 0
      },
      animate: {
        opacity: 1
      },
      exit: {
        opacity: 0
      },
      transition: {
        ease: "easeInOut",
        duration: 0.5
      },
      className: "h-full",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        reactExports.Suspense,
        {
          fallback: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, { className: "fixed inset-0 bg-paper flex justify-center items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "svg",
                {
                  "aria-hidden": "true",
                  className: "w-24 h-24 text-white animate-spin fill-sky-400",
                  viewBox: "0 0 100 101",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "path",
                      {
                        d: "M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z",
                        fill: "currentColor"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "path",
                      {
                        d: "M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z",
                        fill: "currentFill"
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Loading..." })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-screen" })
          ] }),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Element2, {})
        }
      )
    }
  );
}
function _() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "-translate-x-full -translate-y-full translate-x-full sr-only" });
}
const consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    if (console && console[type])
      console[type].apply(console, args);
  }
};
class Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug)
      return null;
    if (typeof args[0] === "string")
      args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger(this.logger, options);
  }
}
var baseLogger = new Logger();
class EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event) => {
      this.observers[event] = this.observers[event] || [];
      this.observers[event].push(listener);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event])
      return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event] = this.observers[event].filter((l2) => l2 !== listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = [].concat(this.observers[event]);
      cloned.forEach((observer) => {
        observer(...args);
      });
    }
    if (this.observers["*"]) {
      const cloned = [].concat(this.observers["*"]);
      cloned.forEach((observer) => {
        observer.apply(observer, [event, ...args]);
      });
    }
  }
}
function defer() {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy(a2, s2, t2) {
  a2.forEach((m2) => {
    if (s2[m2])
      t2[m2] = s2[m2];
  });
}
function getLastOfPath(object, path, Empty) {
  function cleanKey(key) {
    return key && key.indexOf("###") > -1 ? key.replace(/###/g, ".") : key;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  const stack = typeof path !== "string" ? [].concat(path) : path.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    const key = cleanKey(stack.shift());
    if (!object[key] && Empty)
      object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
function setPath(object, path, newValue) {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path, Object);
  obj[k2] = newValue;
}
function pushPath(object, path, newValue, concat) {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path, Object);
  obj[k2] = obj[k2] || [];
  if (concat)
    obj[k2] = obj[k2].concat(newValue);
  if (!concat)
    obj[k2].push(newValue);
}
function getPath(object, path) {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path);
  if (!obj)
    return void 0;
  return obj[k2];
}
function getPathWithDefaults(data, defaultData, key) {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, (s2) => _entityMap[s2]);
  }
  return data;
}
const chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c2) => nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0);
  if (possibleChars.length === 0)
    return true;
  const r2 = new RegExp(`(${possibleChars.map((c2) => c2 === "?" ? "\\?" : c2).join("|")})`);
  let matched = !r2.test(key);
  if (!matched) {
    const ki2 = key.indexOf(keySeparator);
    if (ki2 > 0 && !r2.test(key.substring(0, ki2))) {
      matched = true;
    }
  }
  return matched;
}
function deepFind(obj, path) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path])
    return obj[path];
  const paths = path.split(keySeparator);
  let current = obj;
  for (let i2 = 0; i2 < paths.length; ++i2) {
    if (!current)
      return void 0;
    if (typeof current[paths[i2]] === "string" && i2 + 1 < paths.length) {
      return void 0;
    }
    if (current[paths[i2]] === void 0) {
      let j2 = 2;
      let p2 = paths.slice(i2, i2 + j2).join(keySeparator);
      let mix2 = current[p2];
      while (mix2 === void 0 && paths.length > i2 + j2) {
        j2++;
        p2 = paths.slice(i2, i2 + j2).join(keySeparator);
        mix2 = current[p2];
      }
      if (mix2 === void 0)
        return void 0;
      if (mix2 === null)
        return null;
      if (path.endsWith(p2)) {
        if (typeof mix2 === "string")
          return mix2;
        if (p2 && typeof mix2[p2] === "string")
          return mix2[p2];
      }
      const joinedPath = paths.slice(i2 + j2).join(keySeparator);
      if (joinedPath)
        return deepFind(mix2, joinedPath, keySeparator);
      return void 0;
    }
    current = current[paths[i2]];
  }
  return current;
}
function getCleanedCode(code) {
  if (code && code.indexOf("_") > 0)
    return code.replace("_", "-");
  return code;
}
class ResourceStore extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path = [lng, ns];
    if (key && typeof key !== "string")
      path = path.concat(key);
    if (key && typeof key === "string")
      path = path.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
    }
    const result = getPath(this.data, path);
    if (result || !ignoreJSONStructure || typeof key !== "string")
      return result;
    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
  }
  addResource(lng, ns, key, value) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path = [lng, ns];
    if (key)
      path = path.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      value = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path, value);
    if (!options.silent)
      this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources2) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m2 in resources2) {
      if (typeof resources2[m2] === "string" || Object.prototype.toString.apply(resources2[m2]) === "[object Array]")
        this.addResource(lng, ns, m2, resources2[m2], {
          silent: true
        });
    }
    if (!options.silent)
      this.emit("added", lng, ns, resources2);
  }
  addResourceBundle(lng, ns, resources2, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false
    };
    let path = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      deep = resources2;
      resources2 = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path) || {};
    if (deep) {
      deepExtend(pack, resources2, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources2
      };
    }
    setPath(this.data, path, pack);
    if (!options.silent)
      this.emit("added", lng, ns, resources2);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns)
      ns = this.options.defaultNS;
    if (this.options.compatibilityAPI === "v1")
      return {
        ...{},
        ...this.getResource(lng, ns)
      };
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n2 = data && Object.keys(data) || [];
    return !!n2.find((v2) => data[v2] && Object.keys(data[v2]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      if (this.processors[processor])
        value = this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
const checkedLoadedFor = {};
class Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng)
      this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key === void 0 || key === null) {
      return false;
    }
    const resolved = this.resolve(key, options);
    return resolved && resolved.res !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0)
      nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m2 = key.match(this.interpolator.nestingRegexp);
      if (m2 && m2.length > 0) {
        return {
          key,
          namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
        namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    if (typeof namespaces === "string")
      namespaces = [namespaces];
    return {
      key,
      namespaces
    };
  }
  translate(keys, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object")
      options = {
        ...options
      };
    if (!options)
      options = {};
    if (keys === void 0 || keys === null)
      return "";
    if (!Array.isArray(keys))
      keys = [String(keys)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, options);
    let res = resolved && resolved.res;
    const resUsedKey = resolved && resolved.usedKey || key;
    const resExactUsedKey = resolved && resolved.exactUsedKey || key;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r2;
          return resolved;
        }
        return r2;
      }
      if (keySeparator) {
        const resTypeIsArray = resType === "[object Array]";
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m2 in res) {
          if (Object.prototype.hasOwnProperty.call(res, m2)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m2}`;
            copy2[m2] = this.translate(deepKey, {
              ...options,
              ...{
                joinArrays: false,
                ns: namespaces
              }
            });
            if (copy2[m2] === deepKey)
              copy2[m2] = res[m2];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
      res = res.join(joinArrays);
      if (res)
        res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
      const hasDefaultValue = Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : "";
      const defaultValue = options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk2 = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk2 && fk2.res)
            this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i2 = 0; i2 < fallbackLngs.length; i2++) {
            lngs.push(fallbackLngs[i2]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l2, k2, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector && this.backendConnector.saveMissing) {
            this.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l2, namespace, k2, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              this.pluralResolver.getSuffixes(language, options).forEach((suffix) => {
                send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
        res = `${namespace}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        if (this.options.compatibilityAPI !== "v1") {
          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0);
        } else {
          res = this.options.parseMissingKeyHandler(res);
        }
      }
    }
    if (returnDetails) {
      resolved.res = res;
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat && this.i18nFormat.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation)
        this.interpolator.init({
          ...options,
          ...{
            interpolation: {
              ...this.options.interpolation,
              ...options.interpolation
            }
          }
        });
      const skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb2 = res.match(this.interpolator.nestingRegexp);
        nestBef = nb2 && nb2.length;
      }
      let data = options.replace && typeof options.replace !== "string" ? options.replace : options;
      if (this.options.interpolation.defaultVariables)
        data = {
          ...this.options.interpolation.defaultVariables,
          ...data
        };
      res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft)
          options.nest = false;
      }
      if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res)
        options.lng = resolved.usedLng;
      if (options.nest !== false)
        res = this.interpolator.nest(res, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (lastKey && lastKey[0] === args[0] && !options.context) {
            _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
            return null;
          }
          return _this.translate(...args, key);
        }, options);
      if (options.interpolation)
        this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
    if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: resolved,
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (typeof keys === "string")
      keys = [keys];
    keys.forEach((k2) => {
      if (this.isValidLookup(found))
        return;
      const extracted = this.extractFromKey(k2, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS)
        namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found))
          return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found))
            return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling)
              pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat && this.i18nFormat.getResource)
      return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
}
function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
class LanguageUtil {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0)
      return null;
    const p2 = code.split("-");
    if (p2.length === 2)
      return null;
    p2.pop();
    if (p2[p2.length - 1].toLowerCase() === "x")
      return null;
    return this.formatLanguageCode(p2.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0)
      return code;
    const p2 = code.split("-");
    return this.formatLanguageCode(p2[0]);
  }
  formatLanguageCode(code) {
    if (typeof code === "string" && code.indexOf("-") > -1) {
      const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let p2 = code.split("-");
      if (this.options.lowerCaseLng) {
        p2 = p2.map((part) => part.toLowerCase());
      } else if (p2.length === 2) {
        p2[0] = p2[0].toLowerCase();
        p2[1] = p2[1].toUpperCase();
        if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
          p2[1] = capitalize(p2[1].toLowerCase());
      } else if (p2.length === 3) {
        p2[0] = p2[0].toLowerCase();
        if (p2[1].length === 2)
          p2[1] = p2[1].toUpperCase();
        if (p2[0] !== "sgn" && p2[2].length === 2)
          p2[2] = p2[2].toUpperCase();
        if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
          p2[1] = capitalize(p2[1].toLowerCase());
        if (specialCases.indexOf(p2[2].toLowerCase()) > -1)
          p2[2] = capitalize(p2[2].toLowerCase());
      }
      return p2.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes)
      return null;
    let found;
    codes.forEach((code) => {
      if (found)
        return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng))
        found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found)
          return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly))
          return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly)
            return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0)
            return;
          if (supportedLng.indexOf(lngOnly) === 0)
            return supportedLng;
        });
      });
    }
    if (!found)
      found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks)
      return [];
    if (typeof fallbacks === "function")
      fallbacks = fallbacks(code);
    if (typeof fallbacks === "string")
      fallbacks = [fallbacks];
    if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
      return fallbacks;
    if (!code)
      return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found)
      found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found)
      found = fallbacks[this.formatLanguageCode(code)];
    if (!found)
      found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found)
      found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c2) => {
      if (!c2)
        return;
      if (this.isSupportedCode(c2)) {
        codes.push(c2);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c2}`);
      }
    };
    if (typeof code === "string" && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly")
        addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
        addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly")
        addCode(this.getLanguagePartFromCode(code));
    } else if (typeof code === "string") {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc2) => {
      if (codes.indexOf(fc2) < 0)
        addCode(this.formatLanguageCode(fc2));
    });
    return codes;
  }
}
let sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
let _rulesPluralsTypes = {
  1: function(n2) {
    return Number(n2 > 1);
  },
  2: function(n2) {
    return Number(n2 != 1);
  },
  3: function(n2) {
    return 0;
  },
  4: function(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  5: function(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5);
  },
  6: function(n2) {
    return Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2);
  },
  7: function(n2) {
    return Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  8: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3);
  },
  9: function(n2) {
    return Number(n2 >= 2);
  },
  10: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4);
  },
  11: function(n2) {
    return Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3);
  },
  12: function(n2) {
    return Number(n2 % 10 != 1 || n2 % 100 == 11);
  },
  13: function(n2) {
    return Number(n2 !== 0);
  },
  14: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3);
  },
  15: function(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  16: function(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2);
  },
  17: function(n2) {
    return Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1);
  },
  18: function(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2);
  },
  19: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3);
  },
  20: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2);
  },
  21: function(n2) {
    return Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0);
  },
  22: function(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3);
  }
};
const nonIntlVersions = ["v1", "v2", "v3"];
const intlVersions = ["v4"];
const suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  const rules = {};
  sets.forEach((set) => {
    set.lngs.forEach((l2) => {
      rules[l2] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}
class PluralResolver {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) {
      try {
        return new Intl.PluralRules(getCleanedCode(code), {
          type: options.ordinal ? "ordinal" : "cardinal"
        });
      } catch {
        return;
      }
    }
    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (this.shouldUseIntlApi()) {
      return rule && rule.resolvedOptions().pluralCategories.length > 1;
    }
    return rule && rule.numbers.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (!rule) {
      return [];
    }
    if (this.shouldUseIntlApi()) {
      return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
    }
    return rule.numbers.map((number2) => this.getSuffix(code, number2, options));
  }
  getSuffix(code, count) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code, options);
    if (rule) {
      if (this.shouldUseIntlApi()) {
        return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
      }
      return this.getSuffixRetroCompatible(rule, count);
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return "";
  }
  getSuffixRetroCompatible(rule, count) {
    const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
    let suffix = rule.numbers[idx];
    if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      if (suffix === 2) {
        suffix = "plural";
      } else if (suffix === 1) {
        suffix = "";
      }
    }
    const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
    if (this.options.compatibilityJSON === "v1") {
      if (suffix === 1)
        return "";
      if (typeof suffix === "number")
        return `_plural_${suffix.toString()}`;
      return returnSuffix();
    } else if (this.options.compatibilityJSON === "v2") {
      return returnSuffix();
    } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      return returnSuffix();
    }
    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  }
  shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  }
}
function deepFindWithDefaults(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path = getPathWithDefaults(data, defaultData, key);
  if (!path && ignoreJSONStructure && typeof key === "string") {
    path = deepFind(data, key, keySeparator);
    if (path === void 0)
      path = deepFind(defaultData, key, keySeparator);
  }
  return path;
}
class Interpolator {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || ((value) => value);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation)
      options.interpolation = {
        escapeValue: true
      };
    const iOpts = options.interpolation;
    this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape;
    this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
    this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
    this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
    this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
    this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
    this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
    this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options)
      this.init(this.options);
  }
  resetRegExp() {
    const regexpStr = `${this.prefix}(.+?)${this.suffix}`;
    this.regexp = new RegExp(regexpStr, "g");
    const regexpUnescapeStr = `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`;
    this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
    const nestingRegexpStr = `${this.nestingPrefix}(.+?)${this.nestingSuffix}`;
    this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    function regexSafe(val) {
      return val.replace(/\$/g, "$$$$");
    }
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path;
      }
      const p2 = key.split(this.formatSeparator);
      const k2 = p2.shift().trim();
      const f2 = p2.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k2, this.options.keySeparator, this.options.ignoreJSONStructure), f2, lng, {
        ...options,
        ...data,
        interpolationkey: k2
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value = typeof temp === "string" ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (typeof value !== "string" && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc2) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match;
    let value;
    let clonedOptions;
    function handleHasOptions(key, inheritedOptions) {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0)
        return key;
      const c2 = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c2[1]}`;
      key = c2[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions)
          clonedOptions = {
            ...inheritedOptions,
            ...clonedOptions
          };
      } catch (e2) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e2);
        return `${key}${sep}${optionsString}`;
      }
      delete clonedOptions.defaultValue;
      return key;
    }
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== "string" ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
        const r2 = match[1].split(this.formatSeparator).map((elem) => elem.trim());
        match[1] = r2.shift();
        formatters = r2;
        doReduce = true;
      }
      value = fc2(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && typeof value !== "string")
        return value;
      if (typeof value !== "string")
        value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = "";
      }
      if (doReduce) {
        value = formatters.reduce((v2, f2) => this.format(v2, f2, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
}
function parseFormatStr(formatStr) {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    const optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (!opt)
          return;
        const [key, ...rest] = opt.split(":");
        const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
        if (!formatOptions[key.trim()])
          formatOptions[key.trim()] = val;
        if (val === "false")
          formatOptions[key.trim()] = false;
        if (val === "true")
          formatOptions[key.trim()] = true;
        if (!isNaN(val))
          formatOptions[key.trim()] = parseInt(val, 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
function createCachedFormatter(fn) {
  const cache = {};
  return function invokeFormatter(val, lng, options) {
    const key = lng + JSON.stringify(options);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(lng, options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
}
class Formatter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    const iOpts = options.interpolation;
    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
  }
  add(name, fc2) {
    this.formats[name.toLowerCase().trim()] = fc2;
  }
  addCached(name, fc2) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc2);
  }
  format(value, format, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format.split(this.formatSeparator);
    const result = formats.reduce((mem, f2) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f2);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
          const l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l2, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
}
function removePending(q2, name) {
  if (q2.pending[name] !== void 0) {
    delete q2.pending[name];
    q2.pendingCount--;
  }
}
class Connector extends EventEmitter {
  constructor(backend, store, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    if (this.backend && this.backend.init) {
      this.backend.init(services, options.backend, options);
    }
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0)
          ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0)
            pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0)
            pending[name] = true;
          if (toLoad[name] === void 0)
            toLoad[name] = true;
          if (toLoadNamespaces[ns] === void 0)
            toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces)
        toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s2 = name.split("|");
    const lng = s2[0];
    const ns = s2[1];
    if (err)
      this.emit("failedLoading", lng, ns, err);
    if (data) {
      this.store.addResourceBundle(lng, ns, data);
    }
    this.state[name] = err ? -1 : 2;
    const loaded = {};
    this.queue.forEach((q2) => {
      pushPath(q2.loaded, [lng], ns);
      removePending(q2, name);
      if (err)
        q2.errors.push(err);
      if (q2.pendingCount === 0 && !q2.done) {
        Object.keys(q2.loaded).forEach((l2) => {
          if (!loaded[l2])
            loaded[l2] = {};
          const loadedKeys = q2.loaded[l2];
          if (loadedKeys.length) {
            loadedKeys.forEach((n2) => {
              if (loaded[l2][n2] === void 0)
                loaded[l2][n2] = true;
            });
          }
        });
        q2.done = true;
        if (q2.errors.length) {
          q2.callback(q2.errors);
        } else {
          q2.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q2) => !q2.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length)
      return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc2 = this.backend[fcName].bind(this.backend);
    if (fc2.length === 2) {
      try {
        const r2 = fc2(lng, ns);
        if (r2 && typeof r2.then === "function") {
          r2.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r2);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc2(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (typeof languages === "string")
      languages = this.languageUtils.toResolveHierarchy(languages);
    if (typeof namespaces === "string")
      namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length)
        callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s2 = name.split("|");
    const lng = s2[0];
    const ns = s2[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err)
        this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data)
        this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "")
      return;
    if (this.backend && this.backend.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc2 = this.backend.create.bind(this.backend);
      if (fc2.length < 6) {
        try {
          let r2;
          if (fc2.length === 5) {
            r2 = fc2(languages, namespace, key, fallbackValue, opts);
          } else {
            r2 = fc2(languages, namespace, key, fallbackValue);
          }
          if (r2 && typeof r2.then === "function") {
            r2.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r2);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc2(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0])
      return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
}
function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: false,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle(args) {
      let ret = {};
      if (typeof args[1] === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (typeof args[2] === "object" || typeof args[3] === "object") {
        const options = args[3] || args[2];
        Object.keys(options).forEach((key) => {
          ret[key] = options[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: (value, format, lng, options) => value,
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === "string")
    options.ns = [options.ns];
  if (typeof options.fallbackLng === "string")
    options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string")
    options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
}
function noop() {
}
function bindMemberFunctions(inst) {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
class I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initImmediate) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (typeof options.ns === "string") {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    if (this.options.compatibilityAPI !== "v1") {
      this.options.interpolation = {
        ...defOpts.interpolation,
        ...this.options.interpolation
      };
    }
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    function createClassOnDemand(ClassOrObject) {
      if (!ClassOrObject)
        return null;
      if (typeof ClassOrObject === "function")
        return new ClassOrObject();
      return ClassOrObject;
    }
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else if (typeof Intl !== "undefined") {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s2 = this.services;
      s2.logger = baseLogger;
      s2.resourceStore = this.store;
      s2.languageUtils = lu;
      s2.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s2.formatter = createClassOnDemand(formatter);
        s2.formatter.init(s2, this.options);
        this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
      }
      s2.interpolator = new Interpolator(this.options);
      s2.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
      s2.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s2.languageDetector.init)
          s2.languageDetector.init(s2, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s2.i18nFormat.init)
          s2.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m2) => {
        if (m2.init)
          m2.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback)
      callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev")
        this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t2) => {
        if (this.isInitialized && !this.initializedStoreOnce)
          this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone)
          this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized)
        return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initImmediate) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    let usedCallback = callback;
    const usedLng = typeof language === "string" ? language : this.language;
    if (typeof language === "function")
      usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === "cimode")
        return usedCallback();
      const toLoad = [];
      const append = (lng) => {
        if (!lng)
          return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l2) => {
          if (toLoad.indexOf(l2) < 0)
            toLoad.push(l2);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l2) => append(l2));
      } else {
        append(usedLng);
      }
      if (this.options.preload) {
        this.options.preload.forEach((l2) => append(l2));
      }
      this.services.backendConnector.load(toLoad, this.options.ns, (e2) => {
        if (!e2 && !this.resolvedLanguage && this.language)
          this.setResolvedLanguage(this.language);
        usedCallback(e2);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (!lngs)
      lngs = this.languages;
    if (!ns)
      ns = this.options.ns;
    if (!callback)
      callback = noop;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module)
      throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type)
      throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l2) {
    if (!l2 || !this.languages)
      return;
    if (["cimode", "dev"].indexOf(l2) > -1)
      return;
    for (let li2 = 0; li2 < this.languages.length; li2++) {
      const lngInLngs = this.languages[li2];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1)
        continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l2) => {
      this.language = l2;
      this.languages = this.services.languageUtils.toResolveHierarchy(l2);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l2);
    };
    const done = (err, l2) => {
      if (l2) {
        setLngProps(l2);
        this.translator.changeLanguage(l2);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l2);
        this.logger.log("languageChanged", l2);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback)
        callback(err, function() {
          return _this2.t(...arguments);
        });
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector)
        lngs = [];
      const l2 = typeof lngs === "string" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l2) {
        if (!this.language) {
          setLngProps(l2);
        }
        if (!this.translator.language)
          this.translator.changeLanguage(l2);
        if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage)
          this.services.languageDetector.cacheUserLanguage(l2);
      }
      this.loadResources(l2, (err) => {
        done(err, l2);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k2) => `${options.keyPrefix}${keySeparator}${k2}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    };
    if (typeof lng === "string") {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode")
      return true;
    const loadNotPending = (l2, n2) => {
      const loadState = this.services.backendConnector.state[`${l2}|${n2}`];
      return loadState === -1 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0)
        return preResult;
    }
    if (this.hasResourceBundle(lng, ns))
      return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
      return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
      return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback)
        callback();
      return Promise.resolve();
    }
    if (typeof ns === "string")
      ns = [ns];
    ns.forEach((n2) => {
      if (this.options.ns.indexOf(n2) < 0)
        this.options.ns.push(n2);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback)
        callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (typeof lngs === "string")
      lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0);
    if (!newLngs.length) {
      if (callback)
        callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback)
        callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng)
      lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
    if (!lng)
      return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore)
      delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m2) => {
      clone[m2] = this[m2];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      clone.store = new ResourceStore(this.store.data, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", function(event) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const translations = {
  en: {
    translation: {
      nav: {
        intro: "Intro",
        messages: "Messages",
        art: "Art",
        cake: "Cake",
        credits: "Credits",
        langChange: "Language changed to English"
      },
      credits: {
        check: "Also check out",
        nepolabo: "Nepolabo 2023 Anniversary",
        lamy: "Lamy Anniversary"
      }
    }
  },
  jp: {
    translation: {
      nav: {
        intro: "",
        messages: "",
        art: "",
        cake: "",
        credits: "",
        langChange: ""
      },
      credits: {
        check: "",
        nepolabo: "",
        lamy: ""
      }
    }
  }
};
instance.use(initReactI18next).init({
  resources: translations,
  lng: "jp",
  // language to use, more information here: https://www.i18next.com/overview/configuration-options#languages-namespaces-resources
  // you can use the i18n.changeLanguage function to change the language manually: https://www.i18next.com/overview/api#changelanguage
  // if you're using a language detector, do not define the lng option
  interpolation: {
    escapeValue: false
    // react already safes from xss
  }
});
const globals = "";
const reset = "";
const ArtLogo = "/2023/nene/assets/artlogo-482f588e.png";
const CakeLogo = "/2023/nene/assets/cakelogo-cc662378.png";
const Logo = "/2023/nene/assets/logo2-9d3a3df4.png";
const MessagesLogo = "/2023/nene/assets/messageslogo-6ebe3700.png";
client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(BrowserRouter, { basename: "/2023/nene", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(_, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: Logo, className: "sr-only", alt: "" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: MessagesLogo, className: "sr-only", alt: "" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: ArtLogo, className: "sr-only", alt: "" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: CakeLogo, className: "sr-only", alt: "" })
  ] }) })
);
export {
  $activeSection as $,
  AnimatePresence as A,
  __webpack_exports__Vector as B,
  CakeLogo as C,
  __webpack_exports__Axis as D,
  __webpack_exports__BoundingBox as E,
  updateCollisionActors as F,
  Logo as L,
  MessagesLogo as M,
  React as R,
  __webpack_exports__Actor as _,
  reactDomExports as a,
  useStore as b,
  ArtLogo as c,
  randomChoice as d,
  __webpack_exports__Color as e,
  __webpack_exports__CollisionType as f,
  __webpack_exports__Shape as g,
  __webpack_exports__Side as h,
  __webpack_exports__Keys as i,
  jsxRuntimeExports as j,
  $parallaxX as k,
  $floor as l,
  motion as m,
  neneSprite as n,
  $section as o,
  _t as p,
  $gameInit as q,
  reactExports as r,
  $game as s,
  __webpack_exports__vec as t,
  useTranslation as u,
  __webpack_exports__EasingFunctions as v,
  $nene as w,
  __webpack_exports__Engine as x,
  __webpack_exports__DisplayMode as y,
  __webpack_exports__Physics as z
};
